<!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>&#x524d;&#x7aef;&#x6574;&#x7406;&#x5408;&#x96c6;</title>
            <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only],
.vscode-high-contrast:not(.vscode-high-contrast-light) img[src$=\#gh-light-mode-only],
.vscode-high-contrast-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

</style>
            <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
<style>
:root {
  --color-note: #0969da;
  --color-tip: #1a7f37;
  --color-warning: #9a6700;
  --color-severe: #bc4c00;
  --color-caution: #d1242f;
  --color-important: #8250df;
}

</style>
<style>
@media (prefers-color-scheme: dark) {
  :root {
    --color-note: #2f81f7;
    --color-tip: #3fb950;
    --color-warning: #d29922;
    --color-severe: #db6d28;
    --color-caution: #f85149;
    --color-important: #a371f7;
  }
}

</style>
<style>
.markdown-alert {
  padding: 0.5rem 1rem;
  margin-bottom: 16px;
  color: inherit;
  border-left: .25em solid #888;
}

.markdown-alert>:first-child {
  margin-top: 0
}

.markdown-alert>:last-child {
  margin-bottom: 0
}

.markdown-alert .markdown-alert-title {
  display: flex;
  font-weight: 500;
  align-items: center;
  line-height: 1
}

.markdown-alert .markdown-alert-title .octicon {
  margin-right: 0.5rem;
  display: inline-block;
  overflow: visible !important;
  vertical-align: text-bottom;
  fill: currentColor;
}

.markdown-alert.markdown-alert-note {
  border-left-color: var(--color-note);
}

.markdown-alert.markdown-alert-note .markdown-alert-title {
  color: var(--color-note);
}

.markdown-alert.markdown-alert-important {
  border-left-color: var(--color-important);
}

.markdown-alert.markdown-alert-important .markdown-alert-title {
  color: var(--color-important);
}

.markdown-alert.markdown-alert-warning {
  border-left-color: var(--color-warning);
}

.markdown-alert.markdown-alert-warning .markdown-alert-title {
  color: var(--color-warning);
}

.markdown-alert.markdown-alert-tip {
  border-left-color: var(--color-tip);
}

.markdown-alert.markdown-alert-tip .markdown-alert-title {
  color: var(--color-tip);
}

.markdown-alert.markdown-alert-caution {
  border-left-color: var(--color-caution);
}

.markdown-alert.markdown-alert-caution .markdown-alert-title {
  color: var(--color-caution);
}

</style>
        
        </head>
        <body class="vscode-body vscode-light">
            <h1 id="前端整理合集">前端整理合集</h1>
<ul>
<li><a href="#%E5%89%8D%E7%AB%AF%E6%95%B4%E7%90%86%E5%90%88%E9%9B%86">前端整理合集</a>
<ul>
<li><a href="#html">html</a>
<ul>
<li><a href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3html%E8%AF%AD%E4%B9%89%E5%8C%96">如何理解html语义化</a></li>
<li><a href="#p%E6%A0%87%E7%AD%BE%E9%87%8C%E9%9D%A2%E4%B8%8D%E8%83%BD%E5%B5%8C%E5%A5%97uldiv%E7%AD%89%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E5%8E%9F%E5%9B%A0">p标签里面不能嵌套ul、div等块级元素原因</a></li>
</ul>
</li>
<li><a href="#css">css</a>
<ul>
<li><a href="#offsetwidth">offsetWidth</a></li>
<li><a href="#margin%E8%B4%9F%E5%80%BC">margin负值</a></li>
<li><a href="#bfc">BFC</a>
<ul>
<li><a href="#margin%E9%87%8D%E5%8F%A0">margin重叠</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80">三栏布局</a></li>
<li><a href="#%E7%B2%98%E8%BF%9E%E5%B8%83%E5%B1%80">粘连布局</a></li>
<li><a href="#%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8">清除浮动</a></li>
<li><a href="#%E7%9B%92%E6%A8%A1%E5%9E%8B">盒模型</a></li>
<li><a href="#%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1">响应式设计</a></li>
<li><a href="#%E5%85%83%E7%B4%A0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD">元素水平垂直居中</a></li>
<li><a href="#line-height%E7%BB%A7%E6%89%BF">line-height继承</a></li>
<li><a href="#css%E9%A2%84%E5%A4%84%E7%90%86%E8%AF%AD%E8%A8%80">css预处理语言</a></li>
<li><a href="#flex%E5%B8%83%E5%B1%80">flex布局</a></li>
<li><a href="#%E5%85%83%E7%B4%A0%E7%AB%96%E5%90%91%E7%9A%84%E7%99%BE%E5%88%86%E6%AF%94%E8%AE%BE%E5%AE%9A%E6%98%AF%E7%9B%B8%E5%AF%B9%E4%BA%8E%E5%AE%B9%E5%99%A8%E7%9A%84%E9%AB%98%E5%BA%A6%E5%90%97">元素竖向的百分比设定是相对于容器的高度吗？</a></li>
<li><a href="#css%E9%80%89%E6%8B%A9%E5%99%A8">css选择器</a>
<ul>
<li><a href="#css%E9%80%89%E6%8B%A9%E5%99%A8%E8%AF%BB%E5%8F%96%E9%A1%BA%E5%BA%8F">css选择器读取顺序</a></li>
<li><a href="#%E5%8F%AF%E7%BB%A7%E6%89%BF">可继承</a></li>
</ul>
</li>
<li><a href="#css%E5%85%83%E7%B4%A0%E9%9A%90%E8%97%8F">css元素隐藏</a></li>
<li><a href="#css%E7%94%BB%E4%B8%89%E8%A7%92%E5%BD%A2">css画三角形</a></li>
<li><a href="#css%E8%A7%86%E5%B7%AE%E6%BB%9A%E5%8A%A8%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88">css视差滚动实现方案</a></li>
<li><a href="#3d%E7%AB%8B%E4%BD%93%E6%84%9F%E7%BB%95x%E8%BD%B4%E6%97%8B%E8%BD%AC">3D立体感绕x轴旋转</a>
<ul>
<li><a href="#transform-style%E7%AB%8B%E4%BD%93%E4%BA%A4%E5%8F%89%E9%81%AE%E7%9B%96">transform-style立体交叉遮盖</a></li>
</ul>
</li>
<li><a href="#css%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">css性能优化</a></li>
</ul>
</li>
<li><a href="#js">js</a>
<ul>
<li><a href="#windowgetcomputedstyleelement-%E8%8E%B7%E5%8F%96%E4%BC%AA%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%86%85%E5%AE%B9">window.getComputedStyle(element) 获取伪类中的内容</a></li>
<li><a href="#js%E4%B8%AD%E5%93%AA%E4%BA%9B%E4%BC%9A%E8%A2%AB%E5%88%A4%E6%96%AD%E4%B8%BAfalse">js中哪些会被判断为false</a></li>
<li><a href="#js-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%9C%BA%E5%88%B6">js 类型转换机制</a></li>
<li><a href="#let-const-var">let const var</a></li>
<li><a href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E7%90%86%E8%A7%A3">作用域的理解</a>
<ul>
<li><a href="#%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%A1%88%E4%BE%8B">词法作用域案例</a></li>
<li><a href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE">作用域链</a></li>
</ul>
</li>
<li><a href="#%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A0%88">执行上下文和执行栈</a>
<ul>
<li><a href="#%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">执行上下文的生命周期</a></li>
</ul>
</li>
<li><a href="#%E9%97%AD%E5%8C%85">闭包</a>
<ul>
<li><a href="#%E4%B8%8D%E8%A6%81%E6%BB%A5%E7%94%A8%E9%97%AD%E5%8C%85">不要滥用闭包</a></li>
<li><a href="#%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81">防抖和节流</a></li>
<li><a href="#%E9%97%AD%E5%8C%85%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%BB%B6%E9%95%BF%E5%8F%98%E9%87%8F%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">闭包为什么会延长变量的生命周期</a></li>
</ul>
</li>
<li><a href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F">内存泄漏</a>
<ul>
<li><a href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6">垃圾回收机制</a></li>
<li><a href="#%E5%8F%AF%E8%83%BD%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%9C%BA%E6%99%AF">可能的内存泄漏场景</a></li>
</ul>
</li>
<li><a href="#10-20-30mapparseint">[10, 20, 30].map(parseInt)</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E5%92%8C%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%BA%E5%88%AB">函数声明和函数表达式区别</a></li>
<li><a href="#-%E5%92%8C-">== 和 ===</a>
<ul>
<li><a href="#%E7%9A%84%E6%B3%A8%E6%84%8F%E4%B9%8B%E5%A4%84">==的注意之处</a></li>
<li><a href="#-%E7%9A%84%E7%BB%93%E6%9E%9C">[]==![] {}==!{}的结果</a></li>
</ul>
</li>
<li><a href="#objectis-%E4%B8%8E%E6%AF%94%E8%BE%83%E6%93%8D%E4%BD%9C%E7%AC%A6--%E7%9A%84%E5%8C%BA%E5%88%AB">Object.is() 与比较操作符 “===”、“==” 的区别？</a></li>
<li><a href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D">深拷贝和浅拷贝</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">数据类型</a>
<ul>
<li><a href="#undefined%E5%92%8Cnull%E7%9A%84%E5%8C%BA%E5%88%AB">undefined和null的区别</a></li>
<li><a href="#%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95">判断数据类型的方法</a></li>
</ul>
</li>
<li><a href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</a>
<ul>
<li><a href="#%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">数组和链表的应用场景</a></li>
</ul>
</li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95">字符串常用的方法</a>
<ul>
<li><a href="#match-matchall">match matchAll</a></li>
<li><a href="#substring-slice%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E5%8C%BA%E5%88%AB">substring slice字符串处理区别</a></li>
</ul>
</li>
<li><a href="#%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95">数组常用的方法</a>
<ul>
<li><a href="#%E5%BD%B1%E5%93%8D%E5%88%B0%E5%8E%9F%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95">影响到原数组的方法</a></li>
<li><a href="#%E6%95%B0%E7%BB%84reduce%E6%96%B9%E6%B3%95%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">数组reduce方法应用场景</a></li>
</ul>
</li>
<li><a href="#%E5%87%BD%E6%95%B0%E7%BC%93%E5%AD%98">函数缓存</a></li>
<li><a href="#event-loop">event loop</a>
<ul>
<li><a href="#event-loop-%E5%AE%8F%E4%BB%BB%E5%8A%A1-%E5%BE%AE%E4%BB%BB%E5%8A%A1-%E5%92%8Cdom%E6%B8%B2%E6%9F%93%E7%9A%84%E5%85%B3%E8%81%94">event loop 宏任务 微任务 和dom渲染的关联</a></li>
</ul>
</li>
<li><a href="#class%E5%92%8C%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%85%B3%E7%B3%BB%E4%BB%A5%E5%8F%8A%E5%8E%9F%E5%9E%8B%E9%93%BE">Class和实例的关系以及原型链</a>
<ul>
<li><a href="#%E5%87%BD%E6%95%B0%E7%9A%84%E7%89%B9%E6%AE%8A%E6%80%A7">函数的特殊性</a></li>
</ul>
</li>
<li><a href="#js%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF">js如何实现继承</a>
<ul>
<li><a href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E6%A1%88">继承的方案</a></li>
</ul>
</li>
<li><a href="#promise">Promise</a>
<ul>
<li><a href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">应用场景</a></li>
</ul>
</li>
<li><a href="#async-await">async await</a>
<ul>
<li><a href="#async-await%E5%BC%82%E6%AD%A5%E6%9C%AC%E8%B4%A8">async await异步本质</a></li>
</ul>
</li>
<li><a href="#generator%E7%90%86%E8%A7%A3%E5%92%8C%E5%BA%94%E7%94%A8">Generator理解和应用</a></li>
<li><a href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">正则表达式</a>
<ul>
<li><a href="#%E6%AD%A3%E5%88%99%E7%9A%84%E8%B4%AA%E5%A9%AA%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%87%92%E6%83%B0%E6%A8%A1%E5%BC%8F">正则的贪婪模式和懒惰模式</a></li>
</ul>
</li>
<li><a href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95">对象的一些方法</a></li>
<li><a href="#new-object%E5%92%8Cobjectcretate%E4%BB%A5%E5%8F%8Aobjectassign%E5%8C%BA%E5%88%AB">new Object()和Object.cretate()以及Object.assign()区别</a></li>
<li><a href="#%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E6%A1%88">关于对象的遍历方案</a>
<ul>
<li><a href="#forof-%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D">for...of 对象适配</a></li>
</ul>
</li>
<li><a href="#this%E6%8C%87%E5%90%91">this指向</a>
<ul>
<li><a href="#this%E9%9A%90%E5%BC%8F%E7%BB%91%E5%AE%9A%E4%B8%A2%E5%A4%B1">this隐式绑定丢失</a></li>
<li><a href="#call-appy-bind%E7%9A%84%E7%94%A8%E6%B3%95%E5%92%8C%E5%8C%BA%E5%88%AB">call appy bind的用法和区别</a></li>
</ul>
</li>
<li><a href="#new%E6%93%8D%E4%BD%9C%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88">new操作做了什么</a></li>
<li><a href="#js%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1">JS基本类型的装箱与拆箱</a></li>
<li><a href="#new-string-%E5%92%8Cstring%E5%8C%BA%E5%88%AB">new String 和String区别</a></li>
<li><a href="#%E4%BA%8B%E4%BB%B6-%E4%BA%8B%E4%BB%B6%E6%B5%81">事件 事件流</a>
<ul>
<li><a href="#%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B">事件模型</a>
<ul>
<li><a href="#eventeventphase">event.eventPhase</a></li>
</ul>
</li>
<li><a href="#ie%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B">IE事件模型</a></li>
<li><a href="#%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86">事件代理</a></li>
<li><a href="#%E9%98%BB%E6%AD%A2%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E5%92%8C%E9%BB%98%E8%AE%A4%E4%BA%8B%E4%BB%B6">阻止事件冒泡和默认事件</a></li>
</ul>
</li>
<li><a href="#eventtarget%E5%92%8Ceventcurrenttarget%E4%BA%8C%E8%80%85%E5%90%AB%E4%B9%89">event.target和event.currentTarget二者含义</a></li>
<li><a href="#%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E6%98%AF%E5%90%A6%E5%9C%A8%E5%8F%AF%E8%A7%86%E5%8C%BA">判断一个元素是否在可视区</a></li>
<li><a href="#%E7%9B%91%E5%90%AC%E4%B8%80%E4%B8%AAdiv%E5%AE%BD%E5%BA%A6%E5%8F%98%E5%8C%96">监听一个div宽度变化</a></li>
<li><a href="#mutationobserver%E8%A7%A6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">MutationObserver触发机制及应用场景</a></li>
<li><a href="#js%E5%8D%95%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3">Js单线程详解</a></li>
<li><a href="#%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E5%92%8C%E5%9C%BA%E6%99%AF">本地存储和场景</a>
<ul>
<li><a href="#cookie%E7%9A%84%E4%BF%AE%E6%94%B9%E6%B3%A8%E6%84%8F">cookie的修改注意</a></li>
<li><a href="#localstorange%E6%9C%AC%E5%9C%B0%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4">localstorange本地过期时间</a></li>
<li><a href="#cookie%E6%9F%A5%E7%9C%8B%E8%8C%83%E5%9B%B4%E5%92%8C%E8%B7%A8%E5%9F%9F%E6%90%BA%E5%B8%A6">cookie查看范围和跨域携带</a></li>
</ul>
</li>
<li><a href="#%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95">单点登录</a></li>
<li><a href="#%E8%B7%A8%E5%9F%9F">跨域</a>
<ul>
<li><a href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">解决方案</a></li>
</ul>
</li>
<li><a href="#web%E7%AB%AF%E5%B8%B8%E8%A7%81%E7%9A%84%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F">web端常见的攻击方式</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E6%8D%95%E8%8E%B7js%E5%BC%82%E5%B8%B8">如何捕获js异常</a></li>
<li><a href="#js%E8%AE%A1%E7%AE%97%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98">js计算精度丢失问题</a></li>
<li><a href="#%E5%89%8D%E7%AB%AF%E9%98%B2%E6%8A%A4xss%E5%92%8Cxsrf%E6%94%BB%E5%87%BB">前端防护xss和xsrf攻击</a></li>
</ul>
</li>
<li><a href="#es6">ES6</a>
<ul>
<li><a href="#%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6-%E5%89%A9%E4%BD%99%E8%BF%90%E7%AE%97%E7%AC%A6">扩展运算符 剩余运算符</a></li>
<li><a href="#%E6%95%B0%E7%BB%84%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95">数组的静态方法</a>
<ul>
<li><a href="#%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95">创建数组的方法</a></li>
</ul>
</li>
<li><a href="#set%E5%92%8Cmap%E7%9A%84%E5%BA%94%E7%94%A8">Set和Map的应用</a>
<ul>
<li><a href="#weakset-weakmap">weakSet weakMap</a></li>
</ul>
</li>
<li><a href="#decorator%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">Decorator应用场景</a></li>
<li><a href="#proxy%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">Proxy的应用场景</a></li>
<li><a href="#es6%E4%B8%AD%E7%9A%84module">ES6中的Module</a></li>
<li><a href="#map%E4%B8%8Eobject%E5%92%8C-set%E4%B8%8Earray%E7%9A%84%E5%8C%BA%E5%88%AB">Map与Object和 Set与Array的区别</a></li>
</ul>
</li>
<li><a href="#vue2">Vue2</a>
<ul>
<li><a href="#vue-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">Vue 生命周期</a>
<ul>
<li><a href="#mounted-created-%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE">mounted created 请求数据</a></li>
</ul>
</li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A">数据双向绑定</a></li>
<li><a href="#vue%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E7%9A%84%E5%8E%9F%E7%90%86">Vue双向绑定的原理</a></li>
<li><a href="#vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F">Vue组件通信方式</a></li>
<li><a href="#data%E7%9A%84%E5%86%99%E6%B3%95%E6%98%AF%E5%87%BD%E6%95%B0%E4%B8%8D%E6%98%AF%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8E%9F%E5%9B%A0">data的写法是函数不是对象的原因</a></li>
<li><a href="#vue%E7%9B%B4%E6%8E%A5%E7%BB%99%E5%AF%B9%E8%B1%A1%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7%E7%9A%84%E9%97%AE%E9%A2%98">vue直接给对象添加属性的问题</a></li>
<li><a href="#v-if%E5%92%8Cv-for%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7">v-if和v-for的优先级</a></li>
<li><a href="#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7computed%E5%92%8Cmethods%E7%9A%84%E5%8C%BA%E5%88%AB">计算属性computed和methods的区别</a></li>
<li><a href="#v-show-v-if%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">v-show v-if的应用场景</a></li>
<li><a href="#vue%E4%B8%ADkey%E7%9A%84%E5%8E%9F%E7%90%86">vue中key的原理</a></li>
<li><a href="#vueextend-%E5%92%8C-vuecomponent">Vue.extend 和 Vue.component</a></li>
<li><a href="#vue%E4%B8%ADmixin%E7%9A%84%E7%90%86%E8%A7%A3%E5%92%8C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">vue中mixin的理解和应用场景</a>
<ul>
<li><a href="#mixin%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">mixin注意事项</a></li>
<li><a href="#mixins-%E5%92%8C-composition-api%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9">mixins 和 composition api的优缺点</a></li>
</ul>
</li>
<li><a href="#vue%E4%B8%AD%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%AC%A6">vue中的修饰符</a>
<ul>
<li><a href="#%E6%B3%A8%E6%84%8F%E4%BF%AE%E9%A5%B0%E7%AC%A6%E9%A1%BA%E5%BA%8F">注意修饰符顺序</a></li>
</ul>
</li>
<li><a href="#vue%E4%B8%AD%E7%9A%84nexttick">vue中的$nextTick</a>
<ul>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89nexttick">为什么要有$nextTick</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">使用场景</a></li>
</ul>
</li>
<li><a href="#v-model%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E5%AE%9E%E7%8E%B0">v-model自定义组件实现</a>
<ul>
<li><a href="#v-bindsync">v-bind:sync</a></li>
<li><a href="#vue3%E4%B8%AD%E7%9A%84v-model%E4%B8%8D%E5%90%8C%E4%B9%8B%E5%A4%84">Vue3中的v-model不同之处</a></li>
</ul>
</li>
<li><a href="#diff%E7%AE%97%E6%B3%95">diff算法</a>
<ul>
<li><a href="#vue%E4%B8%ADdiff%E7%AE%97%E6%B3%95%E6%80%8E%E6%A0%B7%E9%99%8D%E4%BD%8E%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">Vue中diff算法怎样降低时间复杂度</a></li>
</ul>
</li>
<li><a href="#vue%E4%B8%AD%E7%BB%84%E4%BB%B6%E5%92%8C%E6%8F%92%E4%BB%B6%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">Vue中组件和插件有什么区别</a></li>
<li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">自定义指令的应用场景</a></li>
<li><a href="#vue%E8%BF%87%E6%BB%A4%E5%99%A8">vue过滤器</a></li>
<li><a href="#vue%E6%8F%92%E6%A7%BDslot">vue插槽slot</a></li>
<li><a href="#vue%E8%99%9A%E6%8B%9Fdom">vue虚拟dom</a></li>
<li><a href="#vueobservable">Vue.observable</a></li>
<li><a href="#vue%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF">vue处理错误</a>
<ul>
<li><a href="#vue%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">vue前端代码错误处理</a></li>
</ul>
</li>
<li><a href="#vue-keep-alvie">vue keep-alvie</a>
<ul>
<li><a href="#%E7%BC%93%E5%AD%98%E5%90%8E%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE">缓存后如何获取数据</a></li>
</ul>
</li>
<li><a href="#keep-alive%E5%92%8Cv-if%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5">Keep-alive和v-if一起使用情况</a></li>
<li><a href="#vue%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E5%92%8C%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6">Vue动态组件和异步组件</a></li>
<li><a href="#vuex%E7%9A%84%E4%BD%BF%E7%94%A8">Vuex的使用</a></li>
<li><a href="#%E4%BB%8B%E7%BB%8Dvue%E7%9A%84%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91">介绍Vue的模板编译</a></li>
<li><a href="#spa">SPA</a>
<ul>
<li><a href="#%E5%8E%9F%E7%90%86%E5%92%8Cseo%E4%BC%98%E5%8C%96">原理和SEO优化</a></li>
<li><a href="#spa%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96">SPA首屏加载优化</a></li>
<li><a href="#hisotory%E8%B7%AF%E7%94%B1404">hisotory路由404</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#vue3">Vue3</a>
<ul>
<li><a href="#%E4%B8%8Evue2%E7%9A%84%E4%B8%8D%E5%90%8C">与Vue2的不同</a>
<ul>
<li><a href="#%E5%8A%9F%E8%83%BD%E6%94%B9%E5%8F%98">功能改变</a></li>
</ul>
</li>
<li><a href="#vue3%E7%9A%84composition-api%E7%9A%84%E5%A5%BD%E5%A4%84">vue3的Composition Api的好处</a></li>
<li><a href="#vue3%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87%E4%B8%BB%E8%A6%81%E4%BD%93%E7%8E%B0%E5%9C%A8%E5%93%AA%E5%87%A0%E4%B8%AA%E6%96%B9%E9%9D%A2">vue3性能提升主要体现在哪几个方面</a></li>
<li><a href="#vue3proxy%E5%8F%96%E4%BB%A3defineproperty-api%E5%8E%9F%E5%9B%A0">vue3proxy取代defineProperty API原因</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3ref-reactive-toref-torefs">如何理解ref reactive toRef toRefs</a>
<ul>
<li><a href="#ref">ref</a></li>
<li><a href="#reactive">reactive</a></li>
<li><a href="#toref">toRef</a></li>
<li><a href="#torefs">toRefs</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#react">React</a>
<ul>
<li><a href="#%E8%AF%B4%E8%AF%B4react%E7%89%B9%E6%80%A7">说说React特性</a></li>
<li><a href="#state-%E5%92%8C-props-%E5%8C%BA%E5%88%AB">state 和 props 区别</a></li>
<li><a href="#super-%E5%92%8C-superprops-%E5%8C%BA%E5%88%AB">super() 和 super(props) 区别</a></li>
<li><a href="#%E7%B1%BB%E7%BB%84%E4%BB%B6%E5%92%8C%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB">类组件和函数组件的区别</a>
<ul>
<li><a href="#%E7%B1%BB%E7%BB%84%E4%BB%B6%E7%9A%84this%E7%BB%91%E5%AE%9A">类组件的this绑定</a></li>
</ul>
</li>
<li><a href="#react%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E5%92%8C%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6">react受控组件和非受控组件</a></li>
<li><a href="#react%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6">react事件机制</a></li>
<li><a href="#react%E6%9E%84%E5%BB%BA%E7%BB%84%E4%BB%B6%E6%96%B9%E5%BC%8F">react构建组件方式</a></li>
<li><a href="#react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">react生命周期</a></li>
<li><a href="#react%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1">react组件间通信</a>
<ul>
<li><a href="#context%E7%B1%BB%E7%BB%84%E4%BB%B6%E5%92%8C%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8">context类组件和函数组件的使用</a></li>
</ul>
</li>
<li><a href="#react%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%E7%9A%84%E7%90%86%E8%A7%A3%E5%92%8C%E5%BA%94%E7%94%A8">react高阶组件的理解和应用</a>
<ul>
<li><a href="#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0">高阶函数</a></li>
<li><a href="#%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6">高阶组件</a></li>
<li><a href="#%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">高阶组件的应用场景</a></li>
</ul>
</li>
<li><a href="#react%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB">react过渡动画</a>
<ul>
<li><a href="#react-transition-group">react-transition-group</a></li>
</ul>
</li>
<li><a href="#react%E6%8D%95%E8%8E%B7%E9%94%99%E8%AF%AF">react捕获错误</a></li>
<li><a href="#%E5%AF%B9react-refs-%E7%9A%84%E7%90%86%E8%A7%A3%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">对React refs 的理解，应用场景</a>
<ul>
<li><a href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-1">应用场景</a></li>
</ul>
</li>
<li><a href="#setstate%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6">setState执行机制</a>
<ul>
<li><a href="#setstate%E6%9B%B4%E6%96%B0%E7%B1%BB%E5%9E%8B">setState更新类型</a></li>
<li><a href="#%E6%89%B9%E9%87%8F%E6%9B%B4%E6%96%B0">批量更新</a></li>
</ul>
</li>
<li><a href="#react-render%E7%90%86%E8%A7%A3">react render理解</a>
<ul>
<li><a href="#render%E7%9A%84%E8%A7%A6%E5%8F%91%E6%97%B6%E6%9C%BA">render的触发时机</a></li>
</ul>
</li>
<li><a href="#react%E4%B8%AD%E6%80%8E%E6%A0%B7%E9%81%BF%E5%85%8D%E5%AD%90%E7%BB%84%E4%BB%B6%E6%97%A0%E6%95%88%E6%B8%B2%E6%9F%93%E5%92%8C%E5%87%8F%E5%B0%91%E8%AE%A1%E7%AE%97%E6%B8%B2%E6%9F%93">react中怎样避免子组件无效渲染和减少计算渲染</a></li>
<li><a href="#react-jsx%E8%BD%AC%E6%8D%A2%E6%88%90%E7%9C%9F%E5%AE%9Edom%E8%BF%87%E7%A8%8B">React Jsx转换成真实DOM过程</a></li>
<li><a href="#fiber%E6%9E%B6%E6%9E%84%E7%9A%84%E7%90%86%E8%A7%A3">Fiber架构的理解</a>
<ul>
<li><a href="#react-fiber">React Fiber</a></li>
</ul>
</li>
<li><a href="#react%E4%B8%ADkey%E7%9A%84%E4%BD%9C%E7%94%A8">react中key的作用</a></li>
<li><a href="#react-diff%E7%AE%97%E6%B3%95">react diff算法</a>
<ul>
<li><a href="#%E5%8E%9F%E7%90%86">原理</a></li>
<li><a href="#%E7%AE%80%E5%8D%95%E7%B1%BB%E5%9E%8B%E5%8A%A0key%E5%92%8C%E4%B8%8D%E5%8A%A0key%E7%9A%84%E6%80%A7%E8%83%BD">简单类型加key和不加key的性能</a></li>
</ul>
</li>
<li><a href="#react-hooks%E7%9A%84%E7%90%86%E8%A7%A3">react hooks的理解</a>
<ul>
<li><a href="#%E5%B8%B8%E8%A7%81%E7%9A%84hooks">常见的hooks</a></li>
<li><a href="#hooks%E4%BD%9C%E7%94%A8">hooks作用</a></li>
<li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89hooks">自定义hooks</a></li>
</ul>
</li>
<li><a href="#react-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">react 性能优化</a></li>
<li><a href="#react-router%E7%90%86%E8%A7%A3">react-router理解</a>
<ul>
<li><a href="#usesearchparams%E7%9A%84%E5%BA%94%E7%94%A8">useSearchParams的应用</a></li>
<li><a href="#react%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82%E7%9A%84%E5%BD%A2%E5%BC%8F">react路由传参的形式</a></li>
</ul>
</li>
<li><a href="#%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8redux%E7%BB%93%E6%9E%84%E5%88%92%E5%88%86">项目中使用redux，结构划分</a>
<ul>
<li><a href="#react-redux-redux-thunk">react-redux redux-thunk</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#dom">DOM</a>
<ul>
<li><a href="#dom%E6%93%8D%E4%BD%9C%E8%8A%82%E7%82%B9%E7%9A%84%E5%9F%BA%E6%9C%ACapi">DOM操作节点的基本API</a>
<ul>
<li><a href="#innerhtml-outerhtml-createtextnode-innertext-textcontent%E5%BC%82%E5%90%8C">innerHTML outerHTML createTextNode innerText textContent异同</a></li>
</ul>
</li>
<li><a href="#property-%E5%92%8Cattribute%E4%BD%BF%E7%94%A8">property 和attribute使用</a></li>
<li><a href="#%E8%AF%B4%E8%AF%B4-real-dom-%E5%92%8C-virtual-dom-%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BC%98%E7%BC%BA%E7%82%B9">说说 Real DOM 和 Virtual DOM 的区别？优缺点？</a></li>
<li><a href="#windowonload%E5%92%8C-domcontentloaded%E5%8D%B3ready%E5%8C%BA%E5%88%AB">Window.onload和 DOMContentLoaded（即ready）区别</a></li>
</ul>
</li>
<li><a href="#bom">BOM</a>
<ul>
<li><a href="#bom%E7%9A%84%E5%90%AB%E4%B9%89">BOM的含义</a>
<ul>
<li><a href="#moveto-moveby-scrollto-scrollby-resizeto-resizeby">moveTo moveBy scrollTo scrollBy resizeTo resizeBy</a></li>
</ul>
</li>
<li><a href="#location">location</a></li>
<li><a href="#history">history</a></li>
<li><a href="#%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E9%A1%B5%E9%9D%A2url%E5%8F%82%E6%95%B0">获取当前页面URL参数</a></li>
</ul>
</li>
<li><a href="#%E7%A7%BB%E5%8A%A8%E7%AB%AF">移动端</a>
<ul>
<li><a href="#%E4%B8%8A%E6%8B%89%E5%8A%A0%E8%BD%BD%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%E5%AE%9E%E7%8E%B0">上拉加载下拉刷新实现</a></li>
<li><a href="#rem-em-vw-vh-dpr">rem em vw vh dpr</a>
<ul>
<li><a href="#%E7%A7%BB%E5%8A%A8%E7%AB%AF1px%E5%AE%9E%E7%8E%B0">移动端1px实现</a></li>
<li><a href="#%E7%A7%BB%E5%8A%A8%E7%AB%AF2x3x%E5%9B%BE">移动端2X3X图</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#http">http</a>
<ul>
<li><a href="#%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%95%B4%E4%B8%AA%E8%BF%87%E7%A8%8B">从输入URL到渲染页面的整个过程</a></li>
<li><a href="#http%E7%8A%B6%E6%80%81%E7%A0%81">http状态码</a></li>
<li><a href="#udp-tcp">UDP TCP</a></li>
<li><a href="#http11-%E5%92%8C-http2">http1.1 和 http2</a></li>
<li><a href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98">浏览器缓存</a>
<ul>
<li><a href="#%E5%BC%BA%E7%BC%93%E5%AD%98">强缓存</a></li>
<li><a href="#%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98">协商缓存</a></li>
</ul>
</li>
<li><a href="#http%E5%A4%B4%E9%83%A8%E5%AD%97%E6%AE%B5">http头部字段</a>
<ul>
<li><a href="#if-match%E7%9A%84%E7%94%A8%E6%B3%95">if-match的用法</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">性能优化</a>
<ul>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88css%E5%9C%A8%E9%A1%B5%E9%9D%A2headjs%E5%9C%A8body%E5%B0%BE%E9%83%A8">为什么css在页面head，js在body尾部</a></li>
<li><a href="#%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">浅谈前端性能优化</a></li>
<li><a href="#%E9%95%BF%E5%88%97%E8%A1%A8%E8%99%9A%E6%8B%9F%E5%88%97%E8%A1%A8">长列表虚拟列表</a></li>
</ul>
</li>
<li><a href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1">数据结构</a>
<ul>
<li><a href="#%E6%8A%8A%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E6%94%B9%E6%88%90%E4%B8%80%E4%B8%AA%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8">把一个数组改成一个单向链表</a></li>
<li><a href="#%E5%A0%86%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%85%B3%E7%B3%BB">堆和二叉树的关系</a></li>
</ul>
</li>
<li><a href="#%E7%AE%97%E6%B3%95">算法</a>
<ul>
<li><a href="#%E9%80%92%E5%BD%92">递归</a>
<ul>
<li><a href="#%E9%80%92%E5%BD%92%E5%92%8C%E5%B0%BE%E9%80%92%E5%BD%92">递归和尾递归</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#write">write</a>
<ul>
<li><a href="#%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E9%80%9A%E7%94%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%87%BD%E6%95%B0">封装一个通用的事件监听函数</a></li>
<li><a href="#%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AAajax%E5%87%BD%E6%95%B0">封装一个ajax函数</a></li>
<li><a href="#%E6%89%8B%E5%86%99instanceof">手写instanceOf</a></li>
<li><a href="#%E6%89%8B%E5%86%99new%E6%93%8D%E4%BD%9C%E7%AC%A6">手写new操作符</a></li>
<li><a href="#%E6%89%8B%E5%86%99call-apply-bind">手写call apply bind</a></li>
<li><a href="#%E6%89%8B%E5%86%99%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81">手写防抖节流</a></li>
<li><a href="#%E6%89%8B%E5%86%99%E6%B7%B1%E6%8B%B7%E8%B4%9D">手写深拷贝</a></li>
<li><a href="#%E6%89%8B%E5%86%99objectcreate">手写Object.create</a></li>
<li><a href="#%E6%89%8B%E5%86%99%E7%AE%80%E5%8D%95axios">手写简单axios</a></li>
<li><a href="#%E6%89%8B%E5%86%99router">手写router</a></li>
</ul>
</li>
<li><a href="#webpack">webpack</a>
<ul>
<li><a href="#webpack%E4%BA%94%E4%B8%AA%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5">webpack五个核心概念</a></li>
<li><a href="#%E8%B0%88%E8%B0%88webpack%E5%8D%87%E7%BA%A7%E5%8F%98%E5%8C%96">谈谈webpack升级变化</a></li>
<li><a href="#%E8%AF%B4%E5%87%BA%E5%87%A0%E4%B8%AA%E5%B8%B8%E8%A7%81%E7%9A%84loader%E5%92%8Cplugin">说出几个常见的loader和plugin</a>
<ul>
<li><a href="#loader%E5%92%8Cplugin">loader和plugin</a></li>
</ul>
</li>
<li><a href="#bundlechunkmodule%E6%98%AF%E4%BB%80%E4%B9%88">bundle，chunk，module是什么</a></li>
<li><a href="#webpack%E8%B0%83%E7%94%A8%E5%92%8Cwebpack-cli">webpack调用和webpack-cli</a></li>
<li><a href="#webpack-loader">webpack loader</a>
<ul>
<li><a href="#loader%E5%86%99%E6%B3%95">loader写法</a></li>
<li><a href="#loader%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F">loader的执行顺序</a></li>
<li><a href="#%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AAloader">手写一个loader</a></li>
<li><a href="#%E5%90%88%E5%B9%B6loader">合并loader</a></li>
<li><a href="#webpack%E4%B8%AD%E7%9A%84-asset-module-type">webpack中的 asset module type</a></li>
</ul>
</li>
<li><a href="#webpack%E5%AF%B9css%E5%A4%84%E7%90%86">webpack对css处理</a>
<ul>
<li><a href="#%E6%8A%BD%E7%A6%BB%E5%8D%95%E7%8B%ACcss%E6%96%87%E4%BB%B6">抽离单独css文件</a></li>
<li><a href="#importloaders-%E9%85%8D%E7%BD%AE">importLoaders 配置</a></li>
</ul>
</li>
<li><a href="#babel-loader">babel-loader</a>
<ul>
<li><a href="#babel%E4%B8%8D%E8%83%BD%E5%A4%84%E7%90%86%E7%9A%84es%E8%AF%AD%E6%B3%95">babel不能处理的es语法</a></li>
<li><a href="#%E5%8D%95%E7%8B%AC%E4%BD%BF%E7%94%A8">单独使用</a></li>
</ul>
</li>
<li><a href="#webpack-%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E5%92%8C%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83">webpack 实现生产和测试环境</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="html">html</h2>
<h3 id="如何理解html语义化">如何理解html语义化</h3>
<ol>
<li>让人更容易读懂（增加代码可读性）</li>
<li>去掉或丢失样式的时候能够让页面呈现出清晰结构</li>
<li>让搜素引擎更容易理解（SEO优化）</li>
</ol>
<h3 id="p标签里面不能嵌套uldiv等块级元素原因">p标签里面不能嵌套ul、div等块级元素原因</h3>
<p>不符合语义化规定，w3c规定，对于P元素，它指定了以下内容，这表明P元素只允许包含内联元素（包括p元素本身也不行）。</p>
<pre><code>&lt;!ELEMENT P - O (%inline;)* -- paragraph --&gt;
</code></pre>
<p>简而言之，不可能在DOM中放置<code>&lt;div&gt;</code>元素，因为开放的<code>&lt;div&gt;</code>标签会自动closures<code>&lt;p&gt;</code>元素。</p>
<pre><code class="language-js">&lt;p&gt;
    <span class="hljs-number">11</span>
    &lt;div href=<span class="hljs-string">&#x27;www.baidu.com&#x27;</span>&gt;baidu1&lt;/div&gt;
    <span class="hljs-number">22</span>
&lt;/p&gt;
</code></pre>
<p><img src="file:///e:\studying\book_files\1.jpg" alt="p标签"></p>
<h2 id="css">css</h2>
<h3 id="offsetwidth">offsetWidth</h3>
<p>offsetWidth 属性是一个只读属性,返回一个元素的布局宽度.一个典型的（译者注：各浏览器的 offsetWidth <code>可能有所不同</code>）.offsetWidth = border + padding + scrollbar(竖直方向滚动条) + width.</p>
<p><img src="file:///e:\studying\book_files\2.jpg" alt="offsetWidth"></p>
<pre><code class="language-html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>盒模型<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><span class="language-css">
        <span class="hljs-selector-id">#div1</span> {
            <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;
			<span class="hljs-attribute">height</span>:<span class="hljs-number">50px</span>;
            <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;
            <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;
            <span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span>;
			<span class="hljs-attribute">overflow-y</span>:auto ;
            <span class="hljs-comment">/* box-sizing: border-box; */</span>
        }
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div1&quot;</span>&gt;</span>
        this is div1
		this is div1
		this is div1
		this is div1
		this is div1
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">
 		<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;div1&#x27;</span>).<span class="hljs-property">offsetWidth</span>) <span class="hljs-comment">// 122</span>
		<span class="hljs-keyword">let</span> div1 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;div1&#x27;</span>)
		<span class="hljs-comment">// 使用 getComputedStyle 获取元素的计算后样式  </span>
		<span class="hljs-keyword">var</span> style = <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">getComputedStyle</span>(div1); 
		<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(style.<span class="hljs-property">paddingLeft</span>) <span class="hljs-comment">// 10px</span>
		<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(style.<span class="hljs-property">paddingRight</span>)<span class="hljs-comment">// 10px</span>
		<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(style.<span class="hljs-property">width</span>) <span class="hljs-comment">//83.2px // 滚动条占据了一定的宽度</span>
		<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(style.<span class="hljs-property">marginLeft</span>)<span class="hljs-comment">//10px</span>
		<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(style.<span class="hljs-property">marginRight</span>)<span class="hljs-comment">//10px</span>
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<blockquote>
<p>offsetWidth 注意不同盒模型时结果，IE盒模型给的width已经包含了boder padding 故就是100</p>
</blockquote>
<h3 id="margin负值">margin负值</h3>
<ol>
<li>margin-top和margin-left为负值时，元素向上或者向左移动</li>
<li>margin-bottom为负值时，下方元素上移，自身不受影响</li>
<li>margin-right为负值时，右侧元素左移，自身不受影响(margin-right负值也可以理解为自身在越来越小，当不占width又是float时可以浮动上去，三栏布局可应用到)</li>
</ol>
<pre><code class="language-html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>margin 负值<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><span class="language-css">
        <span class="hljs-selector-tag">body</span> {
            <span class="hljs-attribute">margin</span>: <span class="hljs-number">20px</span>;
        }

        <span class="hljs-selector-class">.float-left</span> {
            <span class="hljs-attribute">float</span>: left;
        }
        <span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">:after</span> {
            <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27;&#x27;</span>;
            <span class="hljs-attribute">display</span>: table;
            <span class="hljs-attribute">clear</span>: both;
        }

        <span class="hljs-selector-class">.container</span> {
            <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;
            <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;
        }
        <span class="hljs-selector-class">.container</span> <span class="hljs-selector-class">.item</span> {
            <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;
            <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;
        }
        <span class="hljs-selector-class">.container</span> <span class="hljs-selector-class">.border-blue</span> {
            <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid blue;
            <span class="hljs-attribute">margin-right</span>:-<span class="hljs-number">10px</span>;
        }
        <span class="hljs-selector-class">.container</span> <span class="hljs-selector-class">.border-red</span> {
            <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid red;
        }
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>用于测试 margin top bottom 的负数情况<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item border-blue&quot;</span>&gt;</span>
            this is item 1
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item border-red&quot;</span>&gt;</span>
            this is item 2
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>用于测试 margin left right 的负数情况<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container clearfix&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item border-blue float-left&quot;</span>&gt;</span>
            this is item 3
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item border-red float-left&quot;</span>&gt;</span>
            this is item 4
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<p><img src="file:///e:\studying\book_files\9.jpg" alt="margin负值"></p>
<p>k1和k2是两个div</p>
<ol>
<li>上下布局
<ul>
<li>k1 margin-top 负值，k1往上移动，k2跟随移动对应距离</li>
<li>k2 margin-top 负值，k1不动，k2往上移动，层级比k1高，可覆盖点击不到K1的事件</li>
<li>k1 margin-bottom 负值 k1不动 k2往上移动</li>
<li>k2 margin-bottom 负值 k2不动，k2后如果有相邻的元素比如k3存在，则会向上移动</li>
</ul>
</li>
<li>左右布局
<ul>
<li>k1 margin-left 负值 k1往左移动，k2跟随移动对应距离</li>
<li>k2 margin-left 负值 k1不动，k2 往左移动，层级比k1高</li>
<li>k1 margin-right 负值 k1不动 k2往左移动</li>
<li>k2 margin-right 负值 k2不动 k2后如果有相邻的元素比如k3存在，则会向左移动</li>
</ul>
</li>
</ol>
<p>实际应用：<code>圣杯布局+粘连布局</code></p>
<h3 id="bfc">BFC</h3>
<p>在页面中元素都有一个隐含的属性叫作<code>Block Formatting Context</code>，即块级格式化上下文，简称BFC。该属性能够设置打开或关闭，默认是关闭的。页面上的一个<code>隔离渲染区域</code>，<strong>容器里面的子元素不会在布局上影响到外面的元素</strong></p>
<p>一旦开启元素的BFC后，元素将会具备如下特性：</p>
<ul>
<li>父元素的垂直<code>外边距</code>不会和子元素重叠</li>
<li>开启BFC的元素<code>不会被浮动元素</code>所覆盖</li>
<li>开启BFC的元素能够包含浮动的子元素</li>
</ul>
<ol>
<li>普通文档流布局规则
<ul>
<li>浮动的元素是不会被父级计算高度</li>
<li>非浮动元素会占据浮动元素的位置</li>
<li>margin会传递给父级[根据规范，一个盒子如果没有上补白和上边框，那么它的上边距应该和其文档流中的第一个孩子元素的上边距重叠。]</li>
<li>两个相邻元素上下margin会重叠</li>
</ul>
</li>
<li>BFC布局规则
<ul>
<li>浮动的元素会被父级计算高度（父级触发了BFC）</li>
<li><code>非浮动元素不会占据浮动元素位置（非浮动元素触发了BFC）</code></li>
<li>margin不会传递给父级（父级触发了BFC）</li>
<li>两个相邻元素上下margin会重叠（给其中一个元素增加一个父级，然后让他的父级触发）【margin重叠三个条件:同属于一个BFC;相邻;块级元素】</li>
</ul>
</li>
<li>产生方式
<ul>
<li>float 不为none</li>
<li>overflow不为visible</li>
<li>position不为relative和static</li>
<li>display为table-cell table-caption <code>inline-block</code>之一</li>
<li>根元素HTML</li>
</ul>
</li>
<li>BFC作用 :多栏布局,清除浮动,上下margin重叠</li>
</ol>
<blockquote>
<p>多栏布局指的是左侧float，然后给整体父级加上BFC模式，这样就可以避免右侧的内容占据左侧</p>
</blockquote>
<pre><code class="language-html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css">
            *{<span class="hljs-attribute">margin</span>:<span class="hljs-number">0</span>;<span class="hljs-attribute">padding</span>:<span class="hljs-number">0</span>}
            <span class="hljs-selector-class">.k1</span>{
                <span class="hljs-attribute">width</span>:<span class="hljs-number">100px</span>;
                <span class="hljs-attribute">height</span>:<span class="hljs-number">100px</span>;
                <span class="hljs-attribute">border</span>:<span class="hljs-number">1px</span> solid <span class="hljs-number">#00D6B2</span>;
                <span class="hljs-attribute">float</span><span class="hljs-selector-pseudo">:left</span>;
                
            }
            <span class="hljs-selector-class">.k2</span>{
                <span class="hljs-attribute">width</span>:<span class="hljs-number">200px</span>;
                <span class="hljs-attribute">height</span>:<span class="hljs-number">200px</span>;
                <span class="hljs-attribute">background-color</span>: bisque;
                <span class="hljs-comment">/* overflow: hidden; */</span>
                
            }
        </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;k1&quot;</span>&gt;</span>
            
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;k2&quot;</span>&gt;</span>
            abc def weq1 abcdef weq1
            abc def weq1 abcdef weq1
            abc def weq1 abcdef weq1
            abc def weq1 abcdef weq1
            abc def weq1 abcdef weq1
            abc def weq1 abcdef weq1
            abc def weq1 abcdef weq1
            abc def weq1 abcdef weq1
            abc def weq1 abcdef weq1
            abc def weq1 abcdef weq1
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> 
    
    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<p><img src="file:///e:\studying\book_files\4.jpg" alt="图一"></p>
<p>放开k2中/* overflow: hidden; */</p>
<p><img src="file:///e:\studying\book_files\5.jpg" alt="图二"></p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css">
  <span class="hljs-selector-tag">div</span> {
    <span class="hljs-attribute">border</span>: solid <span class="hljs-number">1px</span> red;
    <span class="hljs-attribute">width</span>: <span class="hljs-number">50px</span>;
    <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;
  }
  <span class="hljs-selector-class">.float</span> {
    <span class="hljs-attribute">float</span>: left;
  }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;float&quot;</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;float&quot;</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;background: red;&#x27;</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#x27;background: blue;&#x27;</span>&gt;</span>5<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;float&quot;</span>&gt;</span>6<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p>如果给2设置上背景色且不透明，那么就看不到4的背景色red的样式了，相当于2脱离了文档流，浮动在4的上方了。</p>
<p><img src="file:///e:\studying\book_files\6.jpg" alt="图片">
<img src="file:///e:\studying\book_files\7.jpg" alt="图片">
<img src="file:///e:\studying\book_files\8.jpg" alt="图片"></p>
<h4 id="margin重叠">margin重叠</h4>
<p>margin-top和margin-bottom重叠，空白p被忽略，所以最后相距<code>15px</code></p>
<pre><code class="language-html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><span class="language-css">
        <span class="hljs-selector-tag">p</span> {
            <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;
            <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1</span>;
            <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">10px</span>;
            <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">15px</span>;
        }
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>AAA<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>BBB<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<p><img src="file:///e:\studying\book_files\3.jpg" alt="图例"></p>
<h3 id="三栏布局">三栏布局</h3>
<ul>
<li>flex grid</li>
<li>absolute + margin</li>
<li>圣杯布局：center left right在同一层级全部浮动，父级设左右padding，左侧：left:-100% + right对应宽度，右边margin-right对应宽度</li>
<li>双飞翼布局：多一个div包裹，中间div用margin不是padding，左侧不需要再借助定位改变位置，右侧不需要通过margin-right直接使用margin-left即可</li>
</ul>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css">
*{
    <span class="hljs-attribute">margin</span>:<span class="hljs-number">0</span>;
    <span class="hljs-attribute">padding</span>:<span class="hljs-number">0</span>
}
<span class="hljs-selector-id">#container</span> {
  <span class="hljs-attribute">padding-left</span>: <span class="hljs-number">200px</span>; 
  <span class="hljs-attribute">padding-right</span>: <span class="hljs-number">150px</span>;
}
<span class="hljs-selector-id">#container</span> <span class="hljs-selector-class">.column</span> {
  <span class="hljs-attribute">float</span>: left;
}

<span class="hljs-selector-id">#center</span> {
  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;
  <span class="hljs-attribute">background</span>:greenyellow
}

<span class="hljs-selector-id">#left</span> {
  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>; 
  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;
  <span class="hljs-attribute">position</span>: relative;
  <span class="hljs-attribute">right</span>: <span class="hljs-number">200px</span>;
  <span class="hljs-attribute">background</span>: skyblue;
}
<span class="hljs-selector-id">#right</span> {
  <span class="hljs-attribute">width</span>: <span class="hljs-number">150px</span>; 
  <span class="hljs-attribute">margin-right</span>: -<span class="hljs-number">150px</span>; 
  <span class="hljs-attribute">background</span>: mediumvioletred;
}

<span class="hljs-selector-id">#footer</span> {
  <span class="hljs-attribute">clear</span>: both;
}

</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;header&quot;</span>&gt;</span>header<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;center&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;column&quot;</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;left&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;column&quot;</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;right&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;column&quot;</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;footer&quot;</span>&gt;</span>footer<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p><img src="file:///e:\studying\book_files\10.jpg" alt="1"></p>
<p>div内容为2的位置因为浮动本应该在1之后，然后设置margin-left：-100%；相当于向左移动了整个#container位置，还需要在通过定位移动200px</p>
<p><img src="file:///e:\studying\book_files\11.jpg" alt="2"></p>
<p>div内容为3的位置，设置了margin-right负值，本来应该影响右侧内容，但是它的右侧没内容，假设有，右侧内容会慢慢左移，当margin-right负值等于div3的大小，就相当于完全遮盖住，<strong>外界感觉div3相当于没了宽度，没了宽度的div3自然可以移动上去。</strong></p>
<p><img src="file:///e:\studying\book_files\12.jpg" alt="3"></p>
<p>双飞翼布局</p>
<pre><code class="language-html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;ie=edge&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>双飞翼布局<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><span class="language-css">
        <span class="hljs-selector-tag">body</span> {
            <span class="hljs-attribute">min-width</span>: <span class="hljs-number">550px</span>;
        }
        <span class="hljs-selector-class">.col</span> {
            <span class="hljs-attribute">float</span>: left;
        }

        <span class="hljs-selector-id">#main</span> {
            <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;
            <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;
            <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ccc</span>;
        }
        <span class="hljs-selector-id">#main-wrap</span> {
            <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">190px</span> <span class="hljs-number">0</span> <span class="hljs-number">190px</span>;
        }

        <span class="hljs-selector-id">#left</span> {
            <span class="hljs-attribute">width</span>: <span class="hljs-number">190px</span>;
            <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;
            <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#0000FF</span>;
            <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;
        }
        <span class="hljs-selector-id">#right</span> {
            <span class="hljs-attribute">width</span>: <span class="hljs-number">190px</span>;
            <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;
            <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#FF0000</span>;
            <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">190px</span>;
        }
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;main&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;main-wrap&quot;</span>&gt;</span>
            this is main
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;left&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col&quot;</span>&gt;</span>
        this is left
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;right&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;col&quot;</span>&gt;</span>
        this is right
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>

</code></pre>
<h3 id="粘连布局">粘连布局</h3>
<ol>
<li>为内容区域添加最小的高度
<ul>
<li>min-height</li>
<li>padding-bottom top元素</li>
<li>margin-top bottom元素(margin负值的应用)</li>
</ul>
</li>
</ol>
<pre><code class="language-html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css">
		*{
			<span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;
			<span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;         
		}
		<span class="hljs-selector-tag">html</span>,<span class="hljs-selector-tag">body</span>{
			<span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;
		}
		<span class="hljs-selector-id">#main</span>{
			<span class="hljs-attribute">min-height</span>: <span class="hljs-number">100%</span>;  
			<span class="hljs-attribute">background-color</span>: orange;
		}
		<span class="hljs-selector-class">.main</span>{
			<span class="hljs-attribute">padding-bottom</span>: <span class="hljs-number">100px</span>;
		}
		<span class="hljs-selector-id">#footer</span>{
			<span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;
		    <span class="hljs-attribute">background</span>: pink;
			<span class="hljs-attribute">margin-top</span>: -<span class="hljs-number">100px</span>;
		}
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span>
            main<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>
            main<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>
            main<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>
            main<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>
            main<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>
            main<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>	
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;footer&quot;</span>&gt;</span>
        footer
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<ol start="2">
<li>flex布局：footer的flex设为0，这样footer获得其固有的高度;content的flex设为1</li>
</ol>
<h3 id="清除浮动">清除浮动</h3>
<ol>
<li>overflow:hidden</li>
<li>父级设置固定高度</li>
<li>clear:both;兼容性好，需要一个空div，语义化不好</li>
<li>万能清除法</li>
</ol>
<pre><code class="language-css">.类名<span class="hljs-selector-pseudo">:after</span> {
  <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;
  <span class="hljs-attribute">clear</span>: both;
  <span class="hljs-attribute">display</span>: block;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">overflow</span>: hidden;
  <span class="hljs-attribute">visibility</span>: hidden;
  zoom:<span class="hljs-number">1</span>;
}
</code></pre>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><span class="language-css">
	<span class="hljs-selector-class">.parent</span><span class="hljs-selector-pseudo">::after</span> {  
	    <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">/* 必须设置内容，即使它是空的 */</span>  
	    <span class="hljs-attribute">display</span>: table; <span class="hljs-comment">/* 创建一个匿名表格块级盒子 */</span>  
	    <span class="hljs-attribute">clear</span>: both; <span class="hljs-comment">/* 清除浮动 */</span>  
	}  
	<span class="hljs-selector-class">.parent</span>{
		<span class="hljs-attribute">border</span>:<span class="hljs-number">3px</span> slateblue solid 
	}
	<span class="hljs-selector-class">.float-child</span> {  
	    <span class="hljs-attribute">float</span>: left; <span class="hljs-comment">/* 或者使用 float: right; */</span>  
	    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;  
	    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;  
	    <span class="hljs-attribute">background-color</span>: lightblue;  
	    <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">10px</span>; <span class="hljs-comment">/* 如果是左浮动的话 */</span>  
	}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;parent&quot;</span>&gt;</span>  
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;float-child&quot;</span>&gt;</span>我是浮动元素我是浮动元素我是浮动元素我是浮动元素我是浮动元素我是浮动元素我是浮动元素<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  
    <span class="hljs-comment">&lt;!-- 注意这里没有额外的清除标签 --&gt;</span>  
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p><img src="file:///e:\studying\book_files\13.jpg" alt="img"></p>
<h3 id="盒模型">盒模型</h3>
<p>盒模型指的是HTML元素在渲染时所占据的空间，包括元素的内容（content）、内边距（padding）、边框（border）和外边距（margin）。</p>
<pre><code>box-sizing: content-box(标准盒模型)|border-box(IE盒模型)|inherit:
</code></pre>
<h3 id="响应式设计">响应式设计</h3>
<p>适配不同尺寸屏幕</p>
<ul>
<li>媒体查询 @media</li>
<li>百分比</li>
<li>vw/vh</li>
<li>rem</li>
</ul>
<h3 id="元素水平垂直居中">元素水平垂直居中</h3>
<ul>
<li>position 定位四个方向值一致，margin:auto</li>
<li>position + transform</li>
<li>position + margin负值(需知道宽高)</li>
<li>grid</li>
<li>flex</li>
<li>table</li>
</ul>
<pre><code class="language-css"><span class="hljs-selector-class">.father</span> {  
	<span class="hljs-attribute">display</span>: flex;  
	<span class="hljs-attribute">justify-content</span>: center; <span class="hljs-comment">/* 水平居中 */</span>  
	<span class="hljs-attribute">align-items</span>: center; <span class="hljs-comment">/* 垂直居中 */</span>  
}  
</code></pre>
<pre><code class="language-css">	<span class="hljs-selector-class">.father</span> {
		<span class="hljs-attribute">display</span>: table-cell;
		<span class="hljs-attribute">vertical-align</span>: middle;
		<span class="hljs-attribute">text-align</span>: center; 
	}
	<span class="hljs-selector-class">.son</span> {
		<span class="hljs-attribute">display</span>: inline-block;
	}
</code></pre>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;ie=edge&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>水平垂直居中方案<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><span class="language-css">
        <span class="hljs-selector-class">.container</span> {
            <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;
            <span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span>;
            <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;
            <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;
        }
        <span class="hljs-selector-class">.item</span> {
            <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ccc</span>;
        }
		 <span class="hljs-comment">/*行内元素*/</span>
        <span class="hljs-selector-class">.container-1</span>{
            <span class="hljs-attribute">text-align</span>: center;
            <span class="hljs-attribute">line-height</span>: <span class="hljs-number">200px</span>;
            <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;
        }

        <span class="hljs-selector-class">.container-2</span> {
            <span class="hljs-attribute">position</span>: relative;
        }
		 <span class="hljs-comment">/*需要知道宽高*/</span>
        <span class="hljs-selector-class">.container-2</span> <span class="hljs-selector-class">.item</span> {
            <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;
            <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;
            <span class="hljs-attribute">position</span>: absolute;
            <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;
            <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">150px</span>;
            <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;
            <span class="hljs-attribute">margin-top</span>: -<span class="hljs-number">50px</span>;
        }

        <span class="hljs-selector-class">.container-3</span> {
            <span class="hljs-attribute">position</span>: relative;
        }
		<span class="hljs-comment">/*不需要知道宽高，但是不兼容低版本浏览器*/</span>
        <span class="hljs-selector-class">.container-3</span> <span class="hljs-selector-class">.item</span> {
            <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;
            <span class="hljs-attribute">height</span>: <span class="hljs-number">80px</span>;
            <span class="hljs-attribute">position</span>: absolute;
            <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;
            <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;
            <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>, -<span class="hljs-number">50%</span>)
        }

        <span class="hljs-selector-class">.container-4</span> {
            <span class="hljs-attribute">position</span>: relative;
        }
		 <span class="hljs-comment">/*比较优秀的处理方案*/</span>
        <span class="hljs-selector-class">.container-4</span> <span class="hljs-selector-class">.item</span> {
            <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;
            <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;
            <span class="hljs-attribute">position</span>: absolute;
            <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;
            <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;
            <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;
            <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;
            <span class="hljs-attribute">margin</span>: auto;
        }
 		<span class="hljs-selector-class">.container-5</span> {
           <span class="hljs-attribute">position</span>: relative;
          <span class="hljs-attribute">justify-content</span>: center;
          <span class="hljs-attribute">align-items</span>: center;
          <span class="hljs-attribute">display</span>:flex;
          
        }
        <span class="hljs-selector-class">.container-5</span> <span class="hljs-selector-class">.item</span> {
            <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;
            <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;
        }

    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container container-1&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>一段文字<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container container-2&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span>
            this is item
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container container-3&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span>
            this is item
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container container-4&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span>
            this is item
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container container-5&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;item&quot;</span>&gt;</span>
            this is item
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>

</code></pre>
<h3 id="line-height继承">line-height继承</h3>
<ol>
<li>写具体数值，如30px，则继承父级该值</li>
<li>写比例如1/2/3.5等,则继承该比例（<strong>自己的</strong>font-size*父级中的比例）</li>
<li>写百分比,如200%,则继承计算出来的结果(<strong>父级</strong>的font-size*200%)</li>
</ol>
<h3 id="css预处理语言">css预处理语言</h3>
<p>扩充css语言，增加了变量，混合，函数，嵌套，代码模块化等功能，方便复用和开发</p>
<ul>
<li>嵌套 scss less stylus</li>
</ul>
<pre><code class="language-css"><span class="hljs-selector-class">.a</span> {
	&amp;<span class="hljs-selector-class">.b</span> {
		<span class="hljs-attribute">color</span>: red;
	}
}
</code></pre>
<ul>
<li>变量处理</li>
</ul>
<pre><code class="language-less"><span class="hljs-comment">// less要求变量@开头</span>
<span class="hljs-variable">@red :</span> <span class="hljs-number">#c00</span>;
<span class="hljs-selector-tag">strong</span> {
	<span class="hljs-attribute">color</span>: <span class="hljs-variable">@red</span>;
}
</code></pre>
<pre><code class="language-scss"><span class="hljs-comment">/* sass变量$开头 */</span>
<span class="hljs-variable">$red</span>: <span class="hljs-number">#c00</span>;
<span class="hljs-selector-tag">strong</span> {
	<span class="hljs-attribute">color</span>: <span class="hljs-variable">$red</span>;
}
</code></pre>
<pre><code class="language-css"><span class="hljs-comment">/* stylus变量可以$也可以不加符号，不要用@ */</span>
$mainColor = <span class="hljs-selector-id">#0982c1</span>  
$siteWidth = <span class="hljs-number">1024px</span>  
borderStyle = dotted  
  
<span class="hljs-selector-tag">body</span>  
  <span class="hljs-attribute">color</span> $mainColor  
  <span class="hljs-attribute">border</span> <span class="hljs-number">1px</span> borderStyle $mainColor  
  <span class="hljs-attribute">max-width</span> $siteWidth
</code></pre>
<ul>
<li>作用域概念:和js类似，但是最好不要去定义重复名称变量，除非真的需要</li>
</ul>
<blockquote>
<p>sass测试也一样，有的人说显示unscoped 会是white，实际测试不是</p>
</blockquote>
<pre><code class="language-less"><span class="hljs-variable">@color:</span> black;
<span class="hljs-selector-class">.scoped</span> {
 <span class="hljs-variable">@bg:</span> blue;
 <span class="hljs-variable">@color:</span> white;
 <span class="hljs-attribute">color</span>: <span class="hljs-variable">@color</span>;
 <span class="hljs-attribute">background-color</span>:<span class="hljs-variable">@bg</span>;
}
<span class="hljs-selector-class">.unscoped</span> {
 <span class="hljs-attribute">color</span>:<span class="hljs-variable">@color</span>;
}
</code></pre>
<pre><code class="language-css"><span class="hljs-selector-class">.scoped</span> {
  <span class="hljs-attribute">color</span>: <span class="hljs-number">#ffffff</span>;
  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#0000ff</span>;
}
<span class="hljs-selector-class">.unscoped</span> {
  <span class="hljs-attribute">color</span>: <span class="hljs-number">#000000</span>;
}
</code></pre>
<ul>
<li>混入(mixins)是预处理器最精髓之一，抽离提取。</li>
</ul>
<p>在less中，混合的用法是指将定义好的classA引入classB中，同时还可以传参和带有默认参数</p>
<pre><code class="language-less"><span class="hljs-selector-class">.alert</span> {
 <span class="hljs-attribute">font-weight</span>: <span class="hljs-number">700</span>;
}
<span class="hljs-comment">// 函数一样</span>
<span class="hljs-selector-class">.highlight</span>(<span class="hljs-variable">@color</span>: red) {
 <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1.2em</span>;
 <span class="hljs-attribute">color</span>: <span class="hljs-variable">@color</span>;
}
<span class="hljs-selector-class">.heads-up</span> {
 <span class="hljs-selector-class">.alert</span>;
 <span class="hljs-selector-class">.highlight</span>(red);
}
</code></pre>
<pre><code class="language-css"><span class="hljs-selector-class">.alert</span> {
  <span class="hljs-attribute">font-weight</span>: <span class="hljs-number">700</span>;
}
<span class="hljs-selector-class">.heads-up</span> {
  <span class="hljs-attribute">font-weight</span>: <span class="hljs-number">700</span>;
  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1.2em</span>;
  <span class="hljs-attribute">color</span>: <span class="hljs-number">#ff0000</span>;
}

</code></pre>
<p>sass需要关键词@mixin和引入时@include</p>
<pre><code class="language-scss"><span class="hljs-keyword">@mixin</span> large-text {
 <span class="hljs-attribute">font</span>: {
 family: Arial;
 size: <span class="hljs-number">20px</span>;
 weight: bold;
 }
 <span class="hljs-attribute">color</span>: <span class="hljs-number">#ff0000</span>;
}
<span class="hljs-selector-class">.page-title</span> {
 <span class="hljs-keyword">@include</span> large-text;
 <span class="hljs-attribute">padding</span>: <span class="hljs-number">4px</span>;
 <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">10px</span>;
}
</code></pre>
<pre><code class="language-scss"><span class="hljs-comment">// 定义一个带参数的mixin  </span>
<span class="hljs-keyword">@mixin</span> large-text(<span class="hljs-variable">$family</span>, <span class="hljs-variable">$size</span>, <span class="hljs-variable">$weight</span>) {  
  <span class="hljs-attribute">font-family</span>: <span class="hljs-variable">$family</span>;  
  <span class="hljs-attribute">font-size</span>: <span class="hljs-variable">$size</span>;  
  <span class="hljs-attribute">font-weight</span>: <span class="hljs-variable">$weight</span>;  
  <span class="hljs-attribute">color</span>: <span class="hljs-number">#ff0000</span>;  
}  
  
<span class="hljs-comment">// 使用mixin，并传递参数  </span>
<span class="hljs-selector-class">.page-title</span> {  
  <span class="hljs-keyword">@include</span> large-text(Arial, <span class="hljs-number">40px</span>, bold);  
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">4px</span>;  
  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">10px</span>;  
}
</code></pre>
<pre><code class="language-css"><span class="hljs-selector-class">.page-title</span> {
  <span class="hljs-attribute">font-family</span>: Arial;
  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">40px</span>;
  <span class="hljs-attribute">font-weight</span>: bold;
  <span class="hljs-attribute">color</span>: <span class="hljs-number">#ff0000</span>;
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">4px</span>;
  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">10px</span>; }
</code></pre>
<p>stylus可以不加关键字,参数和函数写法一致，用等号</p>
<pre><code class="language-css">error(borderWidth= <span class="hljs-number">2px</span>) {
 <span class="hljs-attribute">border</span>: borderWidth solid <span class="hljs-number">#F00</span>;
 <span class="hljs-attribute">color</span>: <span class="hljs-number">#F00</span>;
}
<span class="hljs-selector-class">.generic-error</span> {
 <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;
 <span class="hljs-attribute">margin</span>: <span class="hljs-number">4px</span>;
 error(); <span class="hljs-comment">/* error mixins */</span>
}
<span class="hljs-selector-class">.login-error</span> {
 <span class="hljs-attribute">left</span>: <span class="hljs-number">12px</span>;
 <span class="hljs-attribute">position</span>: absolute;
 <span class="hljs-attribute">top</span>: <span class="hljs-number">20px</span>;
 error(<span class="hljs-number">5px</span>); <span class="hljs-comment">/* error mixins $borderWidth 5px */</span>
}
</code></pre>
<ul>
<li>其他逻辑判断</li>
</ul>
<pre><code class="language-scss"><span class="hljs-keyword">@for</span> <span class="hljs-variable">$i</span> from <span class="hljs-number">1</span> through <span class="hljs-number">3</span> {  
  <span class="hljs-selector-class">.item-</span>#{<span class="hljs-variable">$i</span>} { <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span> * <span class="hljs-variable">$i</span>; }  
}
<span class="hljs-variable">$type</span>: monster;  
<span class="hljs-selector-tag">body</span> {  
  <span class="hljs-keyword">@if</span> <span class="hljs-variable">$type</span> == monster {  
    <span class="hljs-attribute">background</span>: green;  
  } <span class="hljs-keyword">@else</span> if <span class="hljs-variable">$type</span> == demon {  
    <span class="hljs-attribute">background</span>: red;  
  } <span class="hljs-keyword">@else</span> {  
    <span class="hljs-attribute">background</span>: blue;  
  }  
}
</code></pre>
<pre><code class="language-css"><span class="hljs-selector-class">.item-1</span> {
  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>; }
<span class="hljs-selector-class">.item-2</span> {
  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>; }
<span class="hljs-selector-class">.item-3</span> {
  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>; }
<span class="hljs-selector-tag">body</span> {
  <span class="hljs-attribute">background</span>: green; }
</code></pre>
<p>stylus语法</p>
<pre><code class="language-css">for <span class="hljs-selector-tag">i</span> in <span class="hljs-number">1</span>..<span class="hljs-number">3</span>  
  <span class="hljs-selector-class">.item-</span>{<span class="hljs-selector-tag">i</span>}  
    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span> * i
type = <span class="hljs-string">&#x27;monster&#x27;</span>  
body  
  if type == <span class="hljs-string">&#x27;monster&#x27;</span>  
    background: green  
  else if type == <span class="hljs-string">&#x27;demon&#x27;</span>  
    background: red  
  else  
    background: blue
</code></pre>
<pre><code class="language-css"><span class="hljs-selector-class">.item-1</span> {  
  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;  
}  
<span class="hljs-selector-class">.item-2</span> {  
  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;  
}  
<span class="hljs-selector-class">.item-3</span> {  
  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;  
}
<span class="hljs-selector-tag">body</span> {  
  <span class="hljs-attribute">background</span>: green;  
}
</code></pre>
<h3 id="flex布局">flex布局</h3>
<ul>
<li>flex-direction: 设置主轴的方向</li>
<li><strong>justify-content</strong>: <code>设置主轴上的子元素排列方式</code></li>
<li>flex-wrap: 设置子元素是否换行</li>
<li>align-content: 设置侧轴的子元素的排列方式（多行）</li>
<li><strong>align-items</strong>:<code>设置侧轴上的子元素排列方式（单行）</code></li>
<li>align-self:<code>允许单个项目有与其他项目不一样的对齐方式</code>，可覆盖align-items属性。</li>
<li>flex-flow:复合属性，相当于同时设置了flex-direction 和 flex-wrap</li>
<li>order：定义项目的排列顺序。数值越小，排列越靠前，默认为0。</li>
</ul>
<pre><code class="language-css"><span class="hljs-selector-class">.box</span> {
 <span class="hljs-attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around;
}
</code></pre>
<ul>
<li>space-between：两端对齐，项目之间的间隔都相等。</li>
<li>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li>
</ul>
<p><img src="file:///e:\studying\book_files\14.jpg" alt="1"></p>
<pre><code class="language-css"><span class="hljs-selector-class">.box</span> { <span class="hljs-attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch; }
</code></pre>
<p><img src="file:///e:\studying\book_files\15.jpg" alt="2"></p>
<ul>
<li>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li>
</ul>
<pre><code class="language-css"><span class="hljs-selector-class">.box</span> {
  <span class="hljs-attribute">align-content</span>: flex-start | flex-end | center | space-between | space-around | stretch;
}
</code></pre>
<p><img src="file:///e:\studying\book_files\16.jpg" alt="3"></p>
<ul>
<li>align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</li>
</ul>
<pre><code class="language-css"><span class="hljs-selector-class">.item</span> {
  <span class="hljs-attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;
}
</code></pre>
<p><img src="file:///e:\studying\book_files\17.jpg" alt="4"></p>
<ul>
<li>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</li>
</ul>
<h3 id="元素竖向的百分比设定是相对于容器的高度吗">元素竖向的百分比设定是相对于容器的高度吗？</h3>
<p>当按百分比设定一个元素的宽度时，它是相对于父容器的宽度计算的，但是，对于一些表示竖向距离的属性，例如 <code>padding-top , padding-bottom , margin-top , margin-bottom</code> 等，当按百分比设定它们时，依据的也是父容器的<code>宽度</code>，而不是高度。</p>
<h3 id="css选择器">css选择器</h3>
<p>id选择器 标签选择器 类选择器 后代选择器 子选择器(div&gt;p) 相邻选择器(a+div) 群组选择器(div,p 选择所有div和p) 伪类选择器 伪元素选择器 属性选择器 层级选择器(p~ul 选择前面有p元素的所有ul)</p>
<h4 id="css选择器读取顺序">css选择器读取顺序</h4>
<p>CSS选择器的解析是从右向左解析的。若从左向右的匹配，发现不符合规则，需要进行回溯，会损失很多性能。</p>
<p>若从右向左匹配，先找到所有的最右节点，对于每一个节点，向上寻找其父节点直到找到根元素或满足条件的匹配规则，则结束这个分支的遍历。</p>
<p>两种匹配规则的性能差别很大，是因为从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点（叶子节点），而从左向右的匹配规则的性能都浪费在了失败的查找上面。</p>
<h4 id="可继承">可继承</h4>
<ul>
<li>可继承的属性：font-size, font-family, color</li>
<li>不可继承的样式：border, padding, margin, width, height</li>
<li>注意a标签不继承父级的<code>color</code>，h1-h6不继承font-size(是按照一定的em比例呈现的)</li>
</ul>
<h3 id="css元素隐藏">css元素隐藏</h3>
<ul>
<li>display:none</li>
<li>visibility:didden</li>
<li>opacity:0</li>
<li>宽高设为0</li>
<li>定位出可视区</li>
<li>clip-path</li>
</ul>
<p><img src="file:///e:\studying\book_files\18.jpg" alt="对比"></p>
<h3 id="css画三角形">css画三角形</h3>
<p>可以看到,设置不同颜色的各个边框，就会发现边框是梯形，极限情况下，width height为0，其他边框颜色留一个边框就可以得到三角形</p>
<p><img src="file:///e:\studying\book_files\19.jpg" alt="三角形"></p>
<h3 id="css视差滚动实现方案">css视差滚动实现方案</h3>
<ul>
<li>perspective  transform: translateZ() scale();</li>
<li>background-attachment</li>
</ul>
<p><img src="file:///e:\studying\book_files\22.jpg" alt="perspective"></p>
<p>translateZ 值调节元素在 Z 轴的位置（近大远小），同时配合 scale 值让元素的大小看起来和原来无异。那么就实现了滚动过程中，不同元素看起来的运动速度不同。</p>
<pre><code class="language-css"><span class="hljs-selector-class">.container</span> {
  <span class="hljs-attribute">width</span>: <span class="hljs-number">100vw</span>;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">100vh</span>;
  <span class="hljs-attribute">overflow-x</span>: auto;
  <span class="hljs-attribute">overflow-y</span>: hidden;
  <span class="hljs-attribute">perspective</span>: <span class="hljs-number">1px</span>;
}
<span class="hljs-selector-class">.img-1</span> {
  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateZ</span>(-<span class="hljs-number">1px</span>) <span class="hljs-built_in">scale</span>(<span class="hljs-number">2</span>); //变慢两倍
}
<span class="hljs-selector-class">.img-2</span> {
  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateZ</span>(-<span class="hljs-number">2px</span>) <span class="hljs-built_in">scale</span>(<span class="hljs-number">3</span>); //变慢三倍
}
<span class="hljs-selector-class">.text-1</span> {
  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateZ</span>(<span class="hljs-number">0.5px</span>) <span class="hljs-built_in">scale</span>(<span class="hljs-number">0.5</span>); //变快两倍
}

</code></pre>
<h3 id="3d立体感绕x轴旋转">3D立体感绕x轴旋转</h3>
<pre><code class="language-html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span> 
<span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span> 
<span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css">
<span class="hljs-selector-id">#div1</span>
{
	<span class="hljs-attribute">position</span>: relative;
	<span class="hljs-attribute">height</span>: <span class="hljs-number">150px</span>;
	<span class="hljs-attribute">width</span>: <span class="hljs-number">150px</span>;
	<span class="hljs-attribute">margin</span>: <span class="hljs-number">50px</span>;
	<span class="hljs-attribute">padding</span>:<span class="hljs-number">10px</span>;
	<span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid black;
	<span class="hljs-attribute">perspective</span>:<span class="hljs-number">150</span>;
	-webkit-<span class="hljs-attribute">perspective</span>:<span class="hljs-number">150</span>; <span class="hljs-comment">/* Safari and Chrome */</span>
}

<span class="hljs-selector-id">#div2</span>
{
	<span class="hljs-attribute">padding</span>:<span class="hljs-number">50px</span>;
	<span class="hljs-attribute">position</span>: absolute;
	<span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid black;
	<span class="hljs-attribute">background-color</span>: red;
	<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotateX</span>(<span class="hljs-number">50deg</span>);
	
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div1&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div2&quot;</span>&gt;</span>HELLO<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
 
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<p><img src="file:///e:\studying\book_files\21.jpg" alt="案例"></p>
<h4 id="transform-style立体交叉遮盖">transform-style立体交叉遮盖</h4>
<p>transform-style 属性指定嵌套元素是怎样在三维空间中呈现。</p>
<pre><code class="language-html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span> 
<span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css">
<span class="hljs-selector-id">#div5</span>
{
	<span class="hljs-attribute">position</span>: relative;
	<span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;
	<span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;
	<span class="hljs-attribute">margin</span>: <span class="hljs-number">100px</span>;
	<span class="hljs-attribute">padding</span>:<span class="hljs-number">10px</span>;
	<span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid black;
}

<span class="hljs-selector-id">#div6</span>
{
	<span class="hljs-attribute">padding</span>:<span class="hljs-number">50px</span>;
	<span class="hljs-attribute">position</span>: absolute;
	<span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid black;
	<span class="hljs-attribute">background-color</span>: red;
	<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotateY</span>(<span class="hljs-number">60deg</span>);
	<span class="hljs-attribute">transform-style</span>: preserve-<span class="hljs-number">3</span>d;
	-webkit-<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotateY</span>(<span class="hljs-number">60deg</span>); 
	-webkit-<span class="hljs-attribute">transform-style</span>: preserve-<span class="hljs-number">3</span>d;
}

<span class="hljs-selector-id">#div7</span>
{
	<span class="hljs-attribute">padding</span>:<span class="hljs-number">40px</span>;
	<span class="hljs-attribute">position</span>: absolute;
	<span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid black;
	<span class="hljs-attribute">background-color</span>: yellow;
	<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotateY</span>(-<span class="hljs-number">60deg</span>);
	-webkit-<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotateY</span>(-<span class="hljs-number">60deg</span>); 

}

</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div5&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div6&quot;</span>&gt;</span>HELLO
  	<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div7&quot;</span>&gt;</span>YELLOW<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<p><img src="file:///e:\studying\book_files\23.jpg" alt="图"></p>
<h3 id="css性能优化">css性能优化</h3>
<ol>
<li>内联首屏<code>关键css</code>，可下载完html立刻渲染，不需要外链下载再渲染，但是不能缓存且代码不能过多(阻塞)</li>
<li>异步加载css</li>
</ol>
<pre><code class="language-js"><span class="hljs-comment">//方案1</span>
<span class="hljs-keyword">const</span> myCSS = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>( <span class="hljs-string">&quot;link&quot;</span> );
myCSS.<span class="hljs-property">rel</span> = <span class="hljs-string">&quot;stylesheet&quot;</span>;
myCSS.<span class="hljs-property">href</span> = <span class="hljs-string">&quot;mystyles.css&quot;</span>;
<span class="hljs-comment">// header</span>
<span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.<span class="hljs-title function_">insertBefore</span>( myCSS, <span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.<span class="hljs-property">childNodes</span>[ <span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.
childNodes.<span class="hljs-property">length</span> - <span class="hljs-number">1</span> ].<span class="hljs-property">nextSibling</span> );
</code></pre>
<pre><code class="language-html"><span class="hljs-comment">&lt;!-- 方案2： media设置noexist，再onload改为all，这样一开始不加载，等页面加载完毕后再去解析css --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;mystyles.css&quot;</span> <span class="hljs-attr">media</span>=<span class="hljs-string">&quot;noexist&quot;</span> <span class="hljs-attr">onload</span>=<span class="hljs-string">&quot;this.med
ia=&#x27;all&#x27;&quot;</span>&gt;</span>
</code></pre>
<pre><code class="language-html"><span class="hljs-comment">&lt;!-- 方案3：先rel配置可选，后加载完删除可选alternate --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;alternate stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;mystyles.css&quot;</span> <span class="hljs-attr">onload</span>=<span class="hljs-string">&quot;this.rel=&#x27;styl
esheet&#x27;&quot;</span>&gt;</span>
</code></pre>
<ol start="3">
<li>资源压缩 webpack gulp</li>
<li>选择器(从右往左执行，不要写太多层级div #x 直接写 #x更快)，尽量不用通配符和属性选择器</li>
<li>减少昂贵属性使用 border-radius filter :nth-child box-shadow,重绘时会降低浏览器性能</li>
<li>少使用@import</li>
</ol>
<h2 id="js">js</h2>
<h3 id="windowgetcomputedstyleelement-获取伪类中的内容">window.getComputedStyle(element) 获取伪类中的内容</h3>
<ol>
<li>返回一个对象，可得到元素的所有 CSS 属性的值。私有的 CSS 属性值可以通过对象提供的 API 或通过简单地使用 CSS 属性名称进行索引来访问。</li>
</ol>
<pre><code class="language-js"><span class="hljs-keyword">let</span> div1 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;div1&#x27;</span>)
<span class="hljs-comment">// 使用 getComputedStyle 获取元素的计算后样式  </span>
<span class="hljs-keyword">var</span> style = <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">getComputedStyle</span>(div1); 
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(style.<span class="hljs-property">paddingLeft</span>) <span class="hljs-comment">// 10px</span>
</code></pre>
<ol start="2">
<li>与伪元素一起使用:getComputedStyle 可以从<strong>伪元素拉取样式信息</strong></li>
</ol>
<pre><code class="language-css"> <span class="hljs-selector-class">.k1</span><span class="hljs-selector-pseudo">::after</span> {
    <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;rocks!&quot;</span>;
  }
</code></pre>
<pre><code class="language-js"><span class="hljs-keyword">let</span> k1=<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByClassName</span>(<span class="hljs-string">&quot;k1&quot;</span>)[<span class="hljs-number">0</span>]
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">getComputedStyle</span>(k1, <span class="hljs-string">&#x27;:before&#x27;</span>).<span class="hljs-title function_">getPropertyValue</span>(<span class="hljs-string">&quot;content&quot;</span>)) <span class="hljs-comment">//rocks!</span>
<span class="hljs-comment">//	console.log(window.getComputedStyle(k1, &#x27;:before&#x27;).content)也可以这样写</span>
</code></pre>
<h3 id="js中哪些会被判断为false">js中哪些会被判断为false</h3>
<p>以下这些都会： 0 null undefined NaN &quot;&quot;</p>
<pre><code class="language-js"><span class="hljs-keyword">if</span> (<span class="hljs-number">0</span>) {  
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;This will not be logged because 0 is falsy.&quot;</span>);  
}  
  
<span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span>) {  
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;This will not be logged because null is falsy.&quot;</span>);  
}  
  
<span class="hljs-keyword">if</span> (<span class="hljs-literal">undefined</span>) {  
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;This will not be logged because undefined is falsy.&quot;</span>);  
}  
  
<span class="hljs-keyword">if</span> (<span class="hljs-title class_">NaN</span>) {  
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;This will not be logged because NaN is falsy.&quot;</span>);  
}  
  
<span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;&quot;</span>) {  
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;This will not be logged because an empty string is falsy.&quot;</span>);  
}
</code></pre>
<h3 id="js-类型转换机制">js 类型转换机制</h3>
<ul>
<li>显式转换： Number() parseInt() Boolean() String()...</li>
<li>隐式转换: 根据运行的代码自动做了某些转换</li>
</ul>
<pre><code class="language-js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-title class_">Number</span>(<span class="hljs-string">&#x27;1a&#x27;</span>))<span class="hljs-comment">//NaN</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-title class_">Number</span>(<span class="hljs-literal">true</span>))<span class="hljs-comment">//1</span>
<span class="hljs-keyword">const</span> obj ={
	<span class="hljs-attr">toString</span>:<span class="hljs-function">()=&gt;</span>{
		<span class="hljs-keyword">return</span> <span class="hljs-number">112</span>
	}
}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>(obj))<span class="hljs-comment">// 112</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;22a1&#x27;</span>))<span class="hljs-comment">//22</span>
<span class="hljs-comment">//console.log(Number(Symbol(1)))// Cannot convert a Symbol value to a number</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>(<span class="hljs-literal">null</span>))<span class="hljs-comment">//0</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>([<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]))<span class="hljs-comment">//NaN</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>([<span class="hljs-number">3</span>]))<span class="hljs-comment">//3</span>
<span class="hljs-keyword">const</span> arr=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]
arr.<span class="hljs-property">toString</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){
	<span class="hljs-keyword">return</span> <span class="hljs-number">1111</span>
}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>(arr))<span class="hljs-comment">//1111</span>
</code></pre>
<pre><code class="language-js">+<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()<span class="hljs-comment">// 转换成时间戳</span>
<span class="hljs-literal">null</span>+<span class="hljs-number">1</span> <span class="hljs-comment">//1</span>
<span class="hljs-literal">undefined</span>+<span class="hljs-number">1</span><span class="hljs-comment">//NaN</span>
</code></pre>
<h3 id="let-const-var">let const var</h3>
<ul>
<li>let: 块级作用域 无变量提升 暂时性死域</li>
<li>const: 块级作用域 定义后不可更改</li>
<li>var: 全局作用域，可重复定义</li>
</ul>
<h3 id="作用域的理解">作用域的理解</h3>
<p>作用域（Scope）指的是变量和函数<code>可访问的区域或范围</code>。</p>
<ul>
<li>全局作用域 在顶层的var或者其他层级没加var的变量</li>
<li>块级作用域 大括号中let const 声明</li>
<li>函数作用域 function中</li>
</ul>
<h4 id="词法作用域案例">词法作用域案例</h4>
<p>词法作用域，也被称为<code>静态作用域</code>，是定义在词法阶段的作用域，即在写代码时就已经确定了变量和函数的作用范围。词法作用域关注的是函数在<code>何处声明</code>，而不是从何处调用。</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>){
 <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>){
 <span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span>;
 <span class="hljs-title function_">foo</span>();
}
<span class="hljs-title function_">bar</span>()

<span class="hljs-comment">// 2</span>
</code></pre>
<p><img src="file:///e:\studying\book_files\41.jpg" alt="词法环境应用"></p>
<h4 id="作用域链">作用域链</h4>
<p>当尝试访问一个变量或函数时，JavaScript引擎会首先在当前的执行环境中进行查找。如果在当前环境中找到了对应的标识符，那么就直接使用它；如果没有找到，则会沿着作用域链向上一级作用域进行查找，这个过程会一直持续到找到对应的标识符或到达全局作用域为止。</p>
<h3 id="执行上下文和执行栈">执行上下文和执行栈</h3>
<p>执行上下文是JavaScript引擎在执行代码时的内部概念，执行上下文提供了<code>代码执行的环境</code>，而作用域则决定了在这个环境中<code>哪些变量和函数是可访问的</code>。每一个执行上下文都是与特定的<code>变量对象</code>（Variable Object）相关联的。变量对象是一个<code>包含</code>了执行上下文中所有变量和函数声明的对象。当JavaScript代码执行时，它会创建一个或多个执行上下文，这些上下文按照特定的顺序（称为执行栈）进行管理。</p>
<p>JavaScript中有三种类型的执行上下文：</p>
<ol>
<li>全局执行上下文：当脚本开始执行时创建的全局作用域。</li>
<li>函数执行上下文：每次调用函数时都会创建一个新的函数执行上下文。</li>
<li>Eval函数执行上下文：由eval()函数创建的上下文，但eval()在现代JavaScript开发中很少使用，因此通常可以忽略。</li>
</ol>
<p>执行栈是一种后进先出（<code>LIFO</code>）的数据结构，用于<code>管理</code>JavaScript程序的执行上下文。当脚本开始执行时，JavaScript引擎会创建一个全局执行上下文并将其推入执行栈。然后，每当调用一个函数时，都会为该函数创建一个新的执行上下文并将其推入执行栈。当函数执行完毕后，其对应的执行上下文会从执行栈中弹出，控制权返回给之前的执行上下文。</p>
<p>这种机制确保了JavaScript代码按照正确的顺序执行。例如，在嵌套函数调用中，内层函数的执行上下文会先被推入执行栈，并在其执行完毕后弹出，然后控制权返回给<code>外层函数</code>。</p>
<p><img src="file:///e:\studying\book_files\42.jpg" alt="执行栈"></p>
<h4 id="执行上下文的生命周期">执行上下文的生命周期</h4>
<p>创建阶段（Creation phase）、执行阶段（Execution phase）和回收阶段（Cleanup phase）。</p>
<ul>
<li>创建阶段：当函数被调用，但尚未执行任何其内部代码之前，会进入创建阶段。在这个阶段，JavaScript引擎会进行以下操作：
<ul>
<li>创建变量对象（Variable Object）：该对象用于存储变量和函数声明。对于全局上下文，变量对象是全局对象（如window对象）。对于函数上下文，变量对象会初始化为函数的参数对象（arguments），然后提升函数声明和变量声明。</li>
<li>确定this的指向</li>
<li>创建作用域链</li>
</ul>
</li>
<li>执行阶段：在此阶段，变量会被赋值，函数会被调用，代码的逻辑会按照顺序执行。</li>
<li>回收阶段：在这个阶段，JavaScript引擎会进行垃圾回收，释放不再需要的内存和对象，清理执行上下文，并将其从执行栈中弹出。</li>
</ul>
<h3 id="闭包">闭包</h3>
<p>函数嵌套函数，闭包就是将函数内部和函数外部连接起来的一座桥梁。</p>
<p><img src="file:///e:\studying\book_files\36.jpg" alt="闭包"></p>
<p>场景：[权限收敛] [设置鼠标样式] [抖动和节流] [延长变量的生命周期] [函数柯里化] [缓存][私有仓库]</p>
<pre><code class="language-js"><span class="hljs-comment">// 闭包隐藏数据，只提供 API</span>
	<span class="hljs-keyword">function</span> <span class="hljs-title function_">createCache</span>(<span class="hljs-params"></span>) {
	    <span class="hljs-keyword">const</span> data = {} <span class="hljs-comment">// 闭包中的数据，被隐藏，不被外界访问</span>
	    <span class="hljs-keyword">return</span> {
	        <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">key, val</span>) {
	            data[key] = val
	        },
	        get (key) {
	            <span class="hljs-keyword">return</span> data[key]
	        }
	    }
	}
	
	<span class="hljs-keyword">const</span> c = <span class="hljs-title function_">createCache</span>()
	c.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">100</span>)
	c.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">160</span>)
	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( c.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;a&#x27;</span>) )
</code></pre>
<pre><code class="language-js"><span class="hljs-keyword">const</span> updateCursor = (<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
  <span class="hljs-comment">// 如果这个换成全局变量，其实也可以，找的时候都可能有些麻烦。</span>
  <span class="hljs-keyword">let</span> selectTableCol = <span class="hljs-literal">false</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">updateLeftStaple: boolean</span>) {
   <span class="hljs-comment">// xxx处理</span>
   <span class="hljs-comment">// selectTableCol= xxxx</span>
  }
})()
</code></pre>
<h4 id="不要滥用闭包">不要滥用闭包</h4>
<ol>
<li>构造函数的方法尽可能定义在函数原型上</li>
</ol>
<pre><code class="language-js"><span class="hljs-comment">// 定义在内部每次都要占内存且消耗时间，这种闭包不是需要的</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">MyObject</span>(<span class="hljs-params">name, message</span>) {
 <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name.<span class="hljs-title function_">toString</span>();
 <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span> = message.<span class="hljs-title function_">toString</span>();
 <span class="hljs-variable language_">this</span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
 <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;
 };
 <span class="hljs-variable language_">this</span>.<span class="hljs-property">getMessage</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
 <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span>;
 };
}
</code></pre>
<ol start="2">
<li>避免循环引用的问题</li>
</ol>
<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params"></span>) {
	<span class="hljs-keyword">var</span> test = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test&#x27;</span>);
	test.<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
		<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello world&#x27;</span>);
	}
	test = <span class="hljs-literal">null</span>;<span class="hljs-comment">//没有这一步，则会形成不必要的闭包</span>
	<span class="hljs-comment">//再给test赋值onclick的时候点击事件已经存在dom上了，test只是一个暂存dom元素的变量</span>
	<span class="hljs-comment">//这仅仅断开了局部变量 test 和 DOM 元素之间的引用，但并没有改变 DOM 元素本身或它的任何属性，包括 onclick 事件处理器。，如果是要解绑点击事件，需要把dom上的onclick设置为null</span>
	<span class="hljs-comment">// document.getElementById(&#x27;test&#x27;).onclick = null;</span>
}
</code></pre>
<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">func</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">var</span> test = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test&#x27;</span>);
	<span class="hljs-comment">// 使click的handler无法再满足闭包条件</span>
    test.<span class="hljs-property">onclick</span> = funcTest;
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">funcTest</span>(<span class="hljs-params"></span>){
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello world&#x27;</span>);
}
</code></pre>
<blockquote>
<p>当闭包不需要时，需要手动置为null，释放内存</p>
</blockquote>
<h4 id="防抖和节流">防抖和节流</h4>
<p>防抖（debounce）和节流（throttle）是两种常用的浏览器事件处理方法，它们的主要目的都是为了减少事件触发频率，优化性能。</p>
<ul>
<li>防抖：在一定时间内，事件处理函数只执行一次，如果在这个时间段内又触发了这个事件，则重新计算执行时间。【搜索框自动补全、表单验证、按钮点击等】</li>
<li>节流：在一段时间内，无论事件触发多少次，都只执行一次事件处理函数。【页面滚动、鼠标移动、懒加载】</li>
</ul>
<h4 id="闭包为什么会延长变量的生命周期">闭包为什么会延长变量的生命周期</h4>
<pre><code class="language-js"><span class="hljs-keyword">var</span> message = <span class="hljs-string">&#x27;hello&#x27;</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>){
  <span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;foo&#x27;</span>;
  <span class="hljs-keyword">var</span> age = <span class="hljs-number">18</span>;

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>){
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(age);
  }

  <span class="hljs-keyword">return</span> bar
}

<span class="hljs-keyword">var</span> fn = <span class="hljs-title function_">foo</span>();
<span class="hljs-title function_">fn</span>()
</code></pre>
<ol>
<li>在执行所有代码之前，引擎会在内存里创建GO对象或者VE（ox100），它里面有String对象，window对象等内置对象。是被提前创建好的。然后现在去执行代码，GO对象是不会被销毁的。</li>
<li>创建执行上下文栈，然后执行全局代码，创建全局执行上下文VO，这个VO指向GO。</li>
<li>然后，这个时候解析全局代码，往全局GO里面加东西了，原来的全局里面有Date,window,String等等，现在又加入message（undefined）foo(oxa00)，test(oxboo)等变量。解析foo是函数，就<strong>创建一个函数对象 foo（oxa00）</strong>，里面有函数的父级作用域，也就是全局的GO对象（ox100）,还有函数执行体（函数代码）。</li>
<li>接下来执行执行代码，先给message赋值，变成了hello，然后执行函数foo。</li>
<li>创建foo函数的函数执行上下文。往里面创建VO对象，VO指向AO对象。 创建一个foo函数的AO对象（ox200）。默认里面没有对象，然后<strong>解析函数</strong>，里面放入name:undefined,age:undefined</li>
</ol>
<p><img src="file:///e:\studying\book_files\37.jpg" alt="图"></p>
<ol start="6">
<li>然后执行一行一行执行foo里面的代码，同时把AO里面的name赋值'foo'，age赋值18；</li>
</ol>
<p><img src="file:///e:\studying\book_files\38.jpg" alt="图"></p>
<ol start="7">
<li>foo函数执行完之后，栈里面的foo函数执行上下文就会被销毁，一旦销毁，对foo的AO对象的引用将会没有，然后ox2oo就会被销毁。</li>
<li>存在闭包的情况，然后foo的执行上下文被销毁，但是bar不会被销毁，因为fn指着它。 然后bar对象不会被销毁，它上面的 foo的ao对象也不会被销毁的。因为bar里面有parentScope这个东西，它指向foo的AO对象。</li>
<li>把fn=null;虽然这时候bar和foo的AO循环引用，但是根据标记清除法，只要从根对象GO开始能找到的对象就不会被销毁。但是bar和foo的AO从根对象指不向他们，他们就会被销毁。</li>
</ol>
<p><img src="file:///e:\studying\book_files\39.jpg" alt="图">
<img src="file:///e:\studying\book_files\40.jpg" alt="图"></p>
<h3 id="内存泄漏">内存泄漏</h3>
<p>内存泄漏（Memory Leak）是指在程序运行过程中，动态分配的内存没有得到及时的释放，从而导致系统内存的浪费，甚至可能导致程序运行缓慢、崩溃或系统资源耗尽。</p>
<h4 id="垃圾回收机制">垃圾回收机制</h4>
<p>原理：垃圾收集器会定期找出不再继续使用的变量，然后释放其内存</p>
<ul>
<li>标记清除算法：</li>
</ul>
<p>标记清除算法是JavaScript中最常用的垃圾回收机制。它的工作原理大致可以分为两个阶段：<code>标记阶段和清除阶段。</code></p>
<p>在标记阶段，垃圾收集器从根对象（通常是全局对象）开始，递归地访问对象的属性，并将所有访问到的对象都标记为“活动”或“可达”。这样，所有从根对象直接或间接可达的对象都会被标记。</p>
<p>在清除阶段，垃圾收集器会遍历堆中的所有对象，找出那些没有被标记为活动的对象。这些对象就是不再被引用的“垃圾”，垃圾收集器会释放它们的内存。</p>
<p>标记清除算法的优点是它能够准确地识别出不再被使用的对象，并释放它们的内存。然而，它也有一定的开销，因为需要定期进行标记和清除操作。</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> m = <span class="hljs-number">0</span>,n = <span class="hljs-number">19</span> <span class="hljs-comment">// m,n,add()标记进入环境</span>
<span class="hljs-title function_">add</span>(m, n) <span class="hljs-comment">// a, b, c标记进入环境</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(n) <span class="hljs-comment">// a,b,c标记离开环境，准备回收</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>) {
 a++
 <span class="hljs-keyword">var</span> c = a + b
 <span class="hljs-keyword">return</span> c
}
</code></pre>
<ul>
<li>引用计数算法：引擎有一个“引用表”，保存所有资源的引用次数</li>
</ul>
<p>引用计数算法是另一种垃圾回收策略，它的工作原理是给每个对象维护一个引用计数器，记录当前有多少引用指向该对象。当一个新的引用指向某个对象时，该对象的引用计数会增加；当引用被释放或重新赋值时，引用计数会减少。当引用计数为0时，表示该对象已经没有任何引用指向它，可以被垃圾收集器回收。</p>
<p>引用计数算法的优点是<code>实时性好</code>，可以及时回收不再使用的对象。然而，它也存在一些问题，特别是<code>循环引用</code>的情况。如果两个或多个对象相互引用，即使它们都不再被外部引用，它们的引用计数也不会变为0，从而导致内存泄漏。</p>
<p>在现代的JavaScript引擎中，主要使用的是基于<code>标记清除</code>的垃圾回收机制，因为它能够更准确地识别出不再被使用的对象。然而，引用计数算法在某些情况下仍然可能被使用，或者作为标记清除算法的<code>辅助手段</code>。</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello world&#x27;</span>);
<span class="hljs-comment">// 数组[1, 2, 3, 4]会占用内存，因为arr引用次数为1，尽管后面没用到arr，他还是一直占据</span>
arr = <span class="hljs-literal">null</span>
<span class="hljs-comment">// arr置为null，则引用次数为0</span>
<span class="hljs-comment">// 这只是个例子，标记清除也是可以实现arr = null 后的回收机制</span>
</code></pre>
<h4 id="可能的内存泄漏场景">可能的内存泄漏场景</h4>
<ul>
<li>意外的全局变量</li>
<li>this创建的意外的全局变量</li>
<li>循环引用</li>
</ul>
<pre><code class="language-js"><span class="hljs-comment">// 使用严格模式可避免</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params"></span>){
	f = <span class="hljs-number">1000</span>
}
</code></pre>
<pre><code class="language-js"><span class="hljs-comment">// 使用严格模式可避免</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">fun</span>(<span class="hljs-params"></span>){
	<span class="hljs-variable language_">this</span>.<span class="hljs-property">f</span> =<span class="hljs-number">1000</span>
}
<span class="hljs-title function_">fun</span>()
</code></pre>
<pre><code class="language-js"><span class="hljs-keyword">var</span> test = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;test&#x27;</span>);
...... <span class="hljs-comment">//绑定事件</span>
test = <span class="hljs-literal">null</span>;<span class="hljs-comment">//接触关联</span>
</code></pre>
<pre><code class="language-js"><span class="hljs-keyword">const</span> refA = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;refA&#x27;</span>);
<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">removeChild</span>(refA); <span class="hljs-comment">// dom</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(refA, <span class="hljs-string">&#x27;refA&#x27;</span>); <span class="hljs-comment">// console div</span>
refA = <span class="hljs-literal">null</span>; <span class="hljs-comment">//及时清除移除且不用的游离元素</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(refA, <span class="hljs-string">&#x27;refA&#x27;</span>); <span class="hljs-comment">// </span>
</code></pre>
<h3 id="10-20-30mapparseint">[10, 20, 30].map(parseInt)</h3>
<p>在 JavaScript 中，map() 方法用于对数组的每个元素执行一个函数，并创建一个新数组，其结果是该函数在原始数组的每个元素上执行的结果。但是，当 map() 与 parseInt() 结合使用时，特别是在没有指定基数（即第二个参数）时，可能会产生意外的结果。</p>
<p>对于 parseInt() 函数，其接受两个参数：</p>
<ol>
<li>要解析的字符串</li>
<li>解析时使用的基数（介于 2 和 36 之间）。如果没有提供基数，并且字符串以 &quot;0x&quot; 或 &quot;0X&quot; 开头，那么基数为 16（十六进制）。如果字符串以 &quot;0&quot; 开头且没有 &quot;x&quot; 或 &quot;X&quot;，那么 JavaScript 可能会将其解析为八进制数（但在 ECMAScript 5 严格模式以及之后的版本中，前导零被视为十进制）。</li>
</ol>
<p>在 [10, 20, 30].map(parseInt) 的情况下，map() 会将数组的每个元素（这里是数字）转换为字符串，并作为 parseInt() 的第一个参数传递。同时，map() 的回调函数默认接收三个参数：当前元素的值、当前元素的索引和数组本身。在这里，由于我们没有为 map() 提供自定义的回调函数，它默认使用这些参数。因此，parseInt() 的第二个参数（基数）实际上是数组的索引。</p>
<p>所以，对于 [10, 20, 30].map(parseInt)：</p>
<ul>
<li>对于第一个元素 10（索引为 0）：parseInt('10', 0)，由于基数为 0 并且字符串不以 &quot;0x&quot; 或 &quot;0X&quot; 开头，所以将其解析为十进制数 10。</li>
<li>对于第二个元素 20（索引为 1）：parseInt('20', 1)，由于基数为 1（这不是一个有效的基数），所以结果将是 NaN（不是一个数字）。</li>
<li>对于第三个元素 30（索引为 2）：parseInt('30', 2)，由于基数为 2（二进制），但字符串 '30' 在二进制中不是有效的，所以结果将是 NaN。</li>
</ul>
<p>因此，[10, 20, 30].map(parseInt) 的结果将是 [10, NaN, NaN]。</p>
<h3 id="函数声明和函数表达式区别">函数声明和函数表达式区别</h3>
<pre><code class="language-js"><span class="hljs-comment">// 函数声明 函数提升</span>
<span class="hljs-keyword">const</span> res = <span class="hljs-title function_">sum</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)
<span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">x, y</span>) {
    <span class="hljs-keyword">return</span> x + y
}

<span class="hljs-comment">// 函数表达式 直接报错</span>
<span class="hljs-keyword">var</span> res = <span class="hljs-title function_">sum</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)
<span class="hljs-keyword">var</span> sum = <span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) {
    <span class="hljs-keyword">return</span> x + y
}
</code></pre>
<h3 id="-和-">== 和 ===</h3>
<p>全等不会存在隐式转换问题</p>
<h4 id="的注意之处">==的注意之处</h4>
<p>两等操作符存在隐式转换的情形。</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> obj = {<span class="hljs-attr">valueOf</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>}}
<span class="hljs-keyword">let</span> result1 = (obj == <span class="hljs-number">1</span>); <span class="hljs-comment">// true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result1)<span class="hljs-comment">//true</span>

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">NaN</span> == <span class="hljs-title class_">NaN</span>) <span class="hljs-comment">//false</span>

<span class="hljs-keyword">let</span> obj1 = {<span class="hljs-attr">toString</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>}}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj1 == <span class="hljs-number">1</span>)<span class="hljs-comment">//true</span>

<span class="hljs-comment">// 运算操作时，valueOf的优先级高于toString</span>
<span class="hljs-keyword">let</span> obj2 = {<span class="hljs-attr">toString</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>},<span class="hljs-attr">valueOf</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){<span class="hljs-keyword">return</span> <span class="hljs-number">2</span>}}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2 == <span class="hljs-number">1</span>)<span class="hljs-comment">//false</span>
</code></pre>
<p>两等操作符总结：</p>
<ol>
<li>两个都为简单类型，字符串和布尔值都会转换成<strong>数值</strong>，再比较</li>
<li>简单类型与引用类型比较，<strong>对象转化成其原始类型的值</strong>，再比较</li>
<li>两个都为引用类型，<strong>则比较它们是否指向同一个对象</strong></li>
<li>null 和 undefined 相等</li>
<li>存在 NaN 则返回 false</li>
</ol>
<h4 id="-的结果">[]==![] {}==!{}的结果</h4>
<pre><code class="language-js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>([] == ![])<span class="hljs-comment">//true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>({} == !{})<span class="hljs-comment">//false</span>

<span class="hljs-comment">// Number([]) //=&gt; 0</span>
<span class="hljs-comment">// [].valueOf() -&gt; []</span>
<span class="hljs-comment">// [].toString() -&gt; &#x27;&#x27;</span>
<span class="hljs-comment">//  Number(&#x27;&#x27;) -&gt; 0</span>
<span class="hljs-comment">// Number({})// =&gt; NaN</span>
<span class="hljs-comment">// ({}).valueOf() -&gt; {}</span>
<span class="hljs-comment">// ({}).toString() -&gt; &#x27;[object Object]&#x27;</span>
<span class="hljs-comment">// Number(&#x27;[object Object]&#x27;) -&gt; NaN</span>
</code></pre>
<h3 id="objectis-与比较操作符--的区别"><a href="http://Object.is">Object.is</a>() 与比较操作符 “===”、“==” 的区别？</h3>
<ol>
<li>使用双等号（==）进行相等判断时，如果两边的类型不一致，则会进行强制类型转化后再进行比较。</li>
<li>使用三等号（===）进行相等判断时，如果两边的类型不一致时，不会做强制类型准换，直接返回 false。</li>
<li>使用 <a href="http://Object.is">Object.is</a> 来进行相等判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN是相等的。</li>
</ol>
<h3 id="深拷贝和浅拷贝">深拷贝和浅拷贝</h3>
<p><img src="file:///e:\studying\book_files\24.jpg" alt="深拷贝浅拷贝"></p>
<p>浅拷贝只复制对象的顶层属性和值，而深拷贝则会层层递归。</p>
<ul>
<li>JavaScript中的<code>Object.assign()</code> <code>Object.create</code> 方法和数组和对象的<code>扩展运算符</code>（...）都执行的是浅拷贝。数组的concat和slice也属于浅拷贝</li>
<li>JSON.parse(JSON.stringify(obj))深拷贝,但是会忽略掉value是undefined,Symbol,function,也不能处理对象循环引用的问题,set类型数据和map类型会被处理为{}</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">const</span> fxArr = [<span class="hljs-string">&quot;One&quot;</span>, <span class="hljs-string">&quot;Two&quot;</span>, <span class="hljs-string">&quot;Three&quot;</span>]
<span class="hljs-keyword">const</span> fxArrs = fxArr.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>)
fxArrs[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;love&quot;</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fxArr) <span class="hljs-comment">// [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fxArrs) <span class="hljs-comment">// [&quot;One&quot;, &quot;love&quot;, &quot;Three&quot;]</span>
</code></pre>
<pre><code class="language-js"><span class="hljs-keyword">const</span> fxArr = [<span class="hljs-string">&quot;One&quot;</span>, <span class="hljs-string">&quot;Two&quot;</span>, <span class="hljs-string">&quot;Three&quot;</span>]
<span class="hljs-keyword">const</span> fxArrs = fxArr.<span class="hljs-title function_">concat</span>()
fxArrs[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;love&quot;</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fxArr) <span class="hljs-comment">// [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fxArrs) <span class="hljs-comment">// [&quot;One&quot;, &quot;love&quot;, &quot;Three&quot;]</span>
</code></pre>
<h3 id="数据类型">数据类型</h3>
<ul>
<li>基本类型： number string boolean undefined <code>null symbol</code> bigInt</li>
<li>引用类型： object function array</li>
</ul>
<p>Symbol 代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。</p>
<p>基本类型存储在栈中，引用类型存储在堆中
<img src="file:///e:\studying\book_files\25.jpg" alt="栈">
<img src="file:///e:\studying\book_files\26.jpg" alt="堆"></p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> intNum = <span class="hljs-number">55</span> <span class="hljs-comment">// 10进制 55</span>
<span class="hljs-keyword">let</span> num1 = <span class="hljs-number">070</span> <span class="hljs-comment">// 8进制 56 (0开头)</span>
<span class="hljs-keyword">let</span> hexNum1 = <span class="hljs-number">0xA</span> <span class="hljs-comment">//16进制 10(0x开头)</span>
</code></pre>
<h4 id="undefined和null的区别">undefined和null的区别</h4>
<ul>
<li>undefined是声明后未赋值，而null通常表示一个空的对象引用(空指针)</li>
<li>在早期的 JavaScript 引擎中，为了性能优化，<code>变量类型信息</code>被存储在一个变量的低位字节中。这些类型标签被用来快速判断变量的类型。由于当时的设计决策，null 和某些对象类型<code>共享</code>了相同的低位字节表示，这导致了 typeof null 返回 &quot;object&quot;。而undefined的typeof就是undefined</li>
<li>在两等情况下，二者相等，三等情况下则不相等</li>
</ul>
<h4 id="判断数据类型的方法">判断数据类型的方法</h4>
<ul>
<li>typeof可判断基础类型，函数类型和其他引用类型都返回object，注意null的特殊性</li>
<li>instanceOf可以用来测试构造函数的prototype属性是否出现在对象的<code>原型链</code>中的<code>任何位置</code>，它可以对引用类型准确判断，但是不能判断基础类型</li>
<li>Object.prototype.toString [object xxx]</li>
<li>构造函数:存在风险，可以判断包括简单类型、引用类型的构造函数</li>
</ul>
<pre><code class="language-js">(<span class="hljs-number">2</span>).<span class="hljs-property">constructor</span>
<span class="hljs-comment">//ƒ Number() { [native code] }</span>
</code></pre>
<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">F1</span>(<span class="hljs-params"></span>){}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">F2</span>(<span class="hljs-params"></span>){}
<span class="hljs-variable constant_">F1</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_">F2</span>()
<span class="hljs-comment">// F1.prototype.constructor = F1</span>
<span class="hljs-keyword">const</span> f1 =<span class="hljs-keyword">new</span> <span class="hljs-title function_">F1</span>()

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(f1.<span class="hljs-property">constructor</span>) <span class="hljs-comment">//不注释的话为F1,注释的话为F2</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(f1 <span class="hljs-keyword">instanceof</span> <span class="hljs-variable constant_">F1</span>)<span class="hljs-comment">//true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(f1 <span class="hljs-keyword">instanceof</span> <span class="hljs-variable constant_">F2</span>)<span class="hljs-comment">//true</span>
</code></pre>
<h3 id="数据结构">数据结构</h3>
<p>数据结构是计算机存储和组织数据的方式，它研究的是数据的<code>逻辑结构和物理结构</code>以及它们之间的相互关系</p>
<p>数据结构有多种分类，包括<code>数组、栈、链表、队列、树、图、字典、堆和散列表（哈希表）</code>等。</p>
<h4 id="数组和链表的应用场景">数组和链表的应用场景</h4>
<p>在前端开发中，链表和数组都是常用的数据结构，但它们有各自的特点和适用场景</p>
<ol>
<li>数组（Array）</li>
</ol>
<p>特点：</p>
<ul>
<li>连续内存空间：数组的元素在内存中是<code>连续存储</code>的，这意味着访问数组中的任何元素都非常快（平均时间复杂度为<code>O(1)</code>）。</li>
<li>固定大小：一旦数组被创建，其大小<code>通常是固定的</code>。虽然JavaScript中的数组是动态的，可以添加和删除元素，但内部实现可能会涉及到元素的移动和内存分配。</li>
<li>随机访问：由于数组在内存中是连续存储的，所以可以通过索引直接访问任何元素。</li>
</ul>
<p>适用场景：</p>
<ul>
<li>当需要<code>快速访问和修改特定位置</code>的元素时。</li>
<li>当需要<code>保持元素的插入顺序</code>时。</li>
<li>当处理大量静态数据或进行批量操作时。</li>
</ul>
<ol start="2">
<li>链表（Linked List）</li>
</ol>
<p>特点：</p>
<ul>
<li>非连续内存空间：链表中的元素可以<code>分散</code>在内存中的任何位置，每个元素（节点）都包含数据和指向下一个元素的指针。</li>
<li>动态大小：链表的大小可以<code>动态</code>地增长和缩小，因为节点可以根据需要添加或删除。</li>
<li>顺序访问：访问链表中的元素通常需要从头节点开始，逐个遍历节点，直到找到所需的元素。这导致访问特定位置的元素的时间复杂度较高（平均时间复杂度为<code>O(n)</code>）。</li>
</ul>
<p>适用场景：</p>
<ul>
<li>当需要在<code>任意位置插入或删除元素时</code>，链表的效率更高，因为不需要移动其他元素。</li>
<li>当处理<code>大量动态数据</code>时，链表可以更有效地管理内存。</li>
<li>当需要实现特定功能的数据结构（如栈、队列等）时，链表可以作为基础结构。</li>
</ul>
<ol start="3">
<li>
<p>对比</p>
<ul>
<li>空间复杂度：数组在内存使用上通常更紧凑，因为它们使用连续的内存空间。而链表由于每个节点都需要存储<code>指针</code>，可能会占用更多的空间。</li>
<li>时间复杂度：访问数组中的特定元素通常更快，因为可以通过<code>索引</code>直接访问。而访问链表中的元素需要从头节点开始遍历，时间复杂度较高。但在<code>插入和删除操</code>作方面，链表通常比数组更高效。</li>
<li>灵活性：链表在<code>动态调整大小和插入/删除元素</code>方面更加灵活，而数组则更适合处理<code>静态数据或进行批量操作</code>。</li>
</ul>
</li>
<li>
<p>总结</p>
</li>
</ol>
<p>在选择使用数组还是链表时，需要根据具体的应用场景和需求来权衡。在大多数情况下，数组是前端开发中更常用的数据结构，因为它们提供了直观的访问方式和丰富的API。但在某些特定场景下，如需要频繁地插入或删除元素，或者实现特定的数据结构时，链表可能会是一个更好的选择。</p>
<h3 id="字符串常用的方法">字符串常用的方法</h3>
<ul>
<li>增：concat(拼接，不影响原字符串)</li>
<li>删：slice substr substring(都不影响原字符串)</li>
<li>改：trim repeat padStart(填充) toLowerCase</li>
<li>查：indexOf includes chartAt startWith</li>
<li>转换方法： split(转为数组),可以是正则或者字符串</li>
<li>正则方法：match search(可以是正则或者字符串,返回第一个匹配的内容下标) replace</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">let</span> colorText = <span class="hljs-string">&quot;red,blue,green,yellow&quot;</span>;
<span class="hljs-keyword">let</span> colors1 = colorText.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;,&quot;</span>);       <span class="hljs-comment">// [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;yellow&quot;]</span>
<span class="hljs-keyword">let</span> colors2 = colorText.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;,&quot;</span>, <span class="hljs-number">2</span>);    <span class="hljs-comment">// [&quot;red&quot;, &quot;blue&quot;]</span>
<span class="hljs-keyword">let</span> colors3 = colorText.<span class="hljs-title function_">split</span>(<span class="hljs-regexp">/[e]+/</span>);  <span class="hljs-comment">// [&#x27;r&#x27;, &#x27;d,blu&#x27;, &#x27;,gr&#x27;, &#x27;n,y&#x27;, &#x27;llow&#x27;]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(colors1)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(colors2)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(colors3)
</code></pre>
<pre><code class="language-js"><span class="hljs-keyword">var</span> str=<span class="hljs-string">&quot;Visit Runoob!&quot;</span>; 
<span class="hljs-keyword">var</span> n=str.<span class="hljs-title function_">search</span>(<span class="hljs-string">&quot;Runoob&quot;</span>);
<span class="hljs-comment">//6</span>

<span class="hljs-keyword">let</span> text = <span class="hljs-string">&quot;cat,bat,sat,fat&quot;</span>;
<span class="hljs-keyword">let</span> pos = text.<span class="hljs-title function_">search</span>(<span class="hljs-regexp">/at,f/</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(pos); <span class="hljs-comment">// 9</span>
</code></pre>
<pre><code class="language-js"><span class="hljs-keyword">var</span> str=<span class="hljs-string">&quot;Visit Microsoft! Visit Microsoft!&quot;</span>;
<span class="hljs-keyword">var</span> n=str.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&quot;Microsoft&quot;</span>,<span class="hljs-string">&quot;Runoob&quot;</span>);
<span class="hljs-comment">//&quot;Visit Runoob! Visit Microsoft!&quot;</span>
<span class="hljs-keyword">var</span> str2=<span class="hljs-string">&quot;Mr Blue has a blue house and a blue car&quot;</span>;
<span class="hljs-keyword">var</span> n2=str.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/blue/g</span>,<span class="hljs-string">&quot;red&quot;</span>);
<span class="hljs-comment">//&quot;Mr Blue has a red house and a red car&quot;</span>
</code></pre>
<pre><code class="language-js"><span class="hljs-comment">//replace第二个参数还可以是函数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">htmlEscape</span>(<span class="hljs-params">text</span>) {
  <span class="hljs-keyword">return</span> text.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/[&lt;&gt;&quot;&amp;]/g</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">match, pos, originalText</span>) {
    <span class="hljs-keyword">switch</span>(match) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;&lt;&quot;</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&amp;lt;&quot;</span>;
      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;&gt;&quot;</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&amp;gt;&quot;</span>;
      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;&amp;&quot;</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&amp;amp;&quot;</span>;
      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;\&quot;&quot;</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&amp;quot;&quot;</span>;
    }       
  });
}
         
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">htmlEscape</span>(<span class="hljs-string">&quot;&lt;p class=\&quot;greeting\&quot;&gt;Hello world!&lt;/p&gt;&quot;</span>)); 
<span class="hljs-comment">// &quot;&amp;lt;p class=&amp;quot;greeting&amp;quot;&amp;gt;Hello world!&amp;lt;/p&amp;gt;&quot;</span>
</code></pre>
<h4 id="match-matchall">match matchAll</h4>
<p>match() 查找找到一个或多个正则表达式的匹配。</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> str=<span class="hljs-string">&quot;The rain in SPAIN stays mainly in the plain&quot;</span>; 
<span class="hljs-keyword">var</span> n=str.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/ain/g</span>);
<span class="hljs-comment">//ain,ain,ain</span>
</code></pre>
<p>String.prototype.matchAll() 方法返回一个迭代器，它产生所有正则表达式匹配的结果，<code>包括捕获组</code>。</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;hello javascript hello css&#x27;</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(...str.<span class="hljs-title function_">matchAll</span>(<span class="hljs-regexp">/(hel)(lo)/g</span>))
<span class="hljs-comment">//[ &#x27;hello&#x27;, &#x27;hel&#x27;, &#x27;lo&#x27; ]  </span>
<span class="hljs-comment">//[ &#x27;hello&#x27;, &#x27;hel&#x27;, &#x27;lo&#x27; ]</span>
<span class="hljs-comment">//浏览器打印会出现index和input等信息 [&#x27;hello&#x27;, &#x27;hel&#x27;, &#x27;lo&#x27;, index: 0, input: &#x27;hello javascript hello css&#x27;, groups: undefined]</span>
</code></pre>
<p>正则表达式 /(hel)(lo)/g 会查找字符串 str 中所有 hel 后面紧跟着 lo 的位置，并且因为它有两个捕获组 (hel) 和 (lo)，所以每个匹配项都会包含这两个捕获组。</p>
<pre><code class="language-js">[  
  [完整匹配项, 捕获组<span class="hljs-number">1</span>, 捕获组<span class="hljs-number">2</span>, ...],  
  [完整匹配项, 捕获组<span class="hljs-number">1</span>, 捕获组<span class="hljs-number">2</span>, ...],  
  ...  
]
</code></pre>
<h4 id="substring-slice字符串处理区别">substring slice字符串处理区别</h4>
<ul>
<li>substring可以反向截取，既第二个参数可以比第一个参数小，而slcie不可以</li>
<li>slice支持负值，就是字符串末尾开始计算，而substring遇到负值自动归为0</li>
</ul>
<h3 id="数组常用的方法">数组常用的方法</h3>
<ul>
<li>增 push unshift splice concat(只有它不影响原数组)</li>
<li>删 pop shift splice slice(只有它不影响原数组)</li>
<li>改 splice</li>
<li>查 find(返回第一个匹配的选项) indexOf includes</li>
<li>排序 sort reverse(会修改原数组)</li>
<li>转换方法 join</li>
<li>迭代方法 some every map forEach reduce filter</li>
<li>其他 fill flat(函数扁平化) copyWithin arr.keys() arr.values() arr.entries()</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>]
<span class="hljs-keyword">let</span> a=arr.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">e</span>=&gt;</span>{
	<span class="hljs-keyword">return</span>(e&gt;<span class="hljs-number">5</span>)
})
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a)<span class="hljs-comment">//7</span>
</code></pre>
<h4 id="影响到原数组的方法">影响到原数组的方法</h4>
<ul>
<li>vue2中重写了 push pop unshift shift splice sort reverse</li>
<li>fill copyWithin</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];  
arr.<span class="hljs-title function_">fill</span>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// arr 现在是 [1, &#x27;a&#x27;, &#x27;a&#x27;, 4, 5]</span>
</code></pre>
<pre><code class="language-js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>]
arr.<span class="hljs-title function_">copyWithin</span>(-<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr)<span class="hljs-comment">//[1, 3, 5, 1, 3]</span>
</code></pre>
<h4 id="数组reduce方法应用场景">数组reduce方法应用场景</h4>
<p>求和</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>]
<span class="hljs-comment">// const res = arr.reduce((sum, curVal, index, arr) =&gt; {</span>
<span class="hljs-comment">//     // console.log(&#x27;reduce function ....&#x27;)</span>
<span class="hljs-comment">//     // console.log(&#x27;sum&#x27;, sum)</span>
<span class="hljs-comment">//     // console.log(&#x27;curVal&#x27;, curVal)</span>
<span class="hljs-comment">//     // console.log(&#x27;index&#x27;, index)</span>
<span class="hljs-comment">//     // console.log(&#x27;arr&#x27;, arr)</span>

<span class="hljs-comment">//     return sum + curVal // 返回值，会作为下一次执行时的第一个参数 sum 的值</span>
<span class="hljs-comment">// }, 0)</span>
<span class="hljs-keyword">const</span> res = arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">sum, curVal</span>) =&gt;</span> sum + curVal, <span class="hljs-number">0</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;res&#x27;</span>, res)
</code></pre>
<p>计数</p>
<pre><code class="language-js"> <span class="hljs-comment">// 计数</span>
<span class="hljs-keyword">const</span> arr = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">20</span>]
<span class="hljs-keyword">const</span> n = <span class="hljs-number">30</span>
<span class="hljs-keyword">const</span> count = arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">count, val</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> val === n ? count + <span class="hljs-number">1</span> : count
}, <span class="hljs-number">0</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;count&#x27;</span>, count)
</code></pre>
<p>输出字符串</p>
<pre><code class="language-js"><span class="hljs-comment">// 输出字符串</span>
<span class="hljs-keyword">const</span> arr = [
    { <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-string">&#x27;20&#x27;</span> },
    { <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;李四&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-string">&#x27;21&#x27;</span> },
    { <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;小明&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-string">&#x27;22&#x27;</span> },
]
<span class="hljs-keyword">const</span> str = arr.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">s, item</span>) =&gt;</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${s}</span><span class="hljs-subst">${item.name}</span> - <span class="hljs-subst">${item.age}</span>\n`</span>
}, <span class="hljs-string">&#x27;&#x27;</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str)
</code></pre>
<p>去重等等……</p>
<h3 id="函数缓存">函数缓存</h3>
<p>场景：[昂贵的函数调用执行复杂计算的函数][纯函数][重复输入的递归函数]</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> memoize = <span class="hljs-keyword">function</span> (<span class="hljs-params">func, content</span>) {
	 <span class="hljs-keyword">let</span> cache = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>)
	
	 content = content || <span class="hljs-variable language_">this</span>
	 <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...key</span>) =&gt;</span> {
		 <span class="hljs-keyword">if</span> (!cache[key]) {
		 cache[key] = func.<span class="hljs-title function_">apply</span>(content, key)
	 }
	 <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cache)<span class="hljs-comment">//{100,200: 300}</span>
	 <span class="hljs-keyword">return</span> cache[key]
	 }
	}
	<span class="hljs-keyword">var</span> add = <span class="hljs-keyword">function</span> (<span class="hljs-params">x,y</span>) {
	 <span class="hljs-keyword">return</span> x+y;
	}
	<span class="hljs-keyword">const</span> calc = <span class="hljs-title function_">memoize</span>(add);
	<span class="hljs-keyword">const</span> num1 = <span class="hljs-title function_">calc</span>(<span class="hljs-number">100</span>,<span class="hljs-number">200</span>)
	<span class="hljs-keyword">const</span> num2 = <span class="hljs-title function_">calc</span>(<span class="hljs-number">100</span>,<span class="hljs-number">200</span>) 
	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(num1,num2)
</code></pre>
<h3 id="event-loop">event loop</h3>
<p>js是单线程，同一时间只能做一件事，而避免阻塞的方法就是事件循环</p>
<ul>
<li>
<p>同步任务：都在主线程(这里的主线程就是JS引擎线程)上执行，会形成一个执行栈</p>
</li>
<li>
<p>异步任务：事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放一个事件回调</p>
</li>
<li>
<p>macro-task(宏任务)：包括整体代码script，setTimeout，setInterval，setImmediate ()-Node,requestAnimationFrame (存在争议,但是符合宏任务特征)-浏览器，I/O 操作、UI 渲染（浏览器）.</p>
</li>
<li>
<p>micro-task(微任务)：Promise，process.nextTick（Node.js）,Object.observe,MutationObserver,在ECMAScript中，microtask也被称为jobs</p>
</li>
</ul>
<p><img src="file:///e:\studying\book_files\30.jpg" alt="同步异步">
<img src="file:///e:\studying\book_files\29.jpg" alt="事件循环机制">
<img src="file:///e:\studying\book_files\31.jpg" alt="宏任务与微任务"></p>
<h4 id="event-loop-宏任务-微任务-和dom渲染的关联">event loop 宏任务 微任务 和dom渲染的关联</h4>
<p>每一次 call stack（当前轮询结束） 结束，都会触发 DOM 渲染（<strong>不一定非得渲染，就是给一次 DOM 渲染的机会！！！</strong>）然后再进行 event loop。</p>
<ul>
<li>宏任务：DOM 渲染后再触发，ES 语法没有，JS 引擎不处理，浏览器（或 nodejs）干预处理。</li>
<li>微任务：DOM 渲染前会触发，ES 语法标准之内，JS 引擎来统一处理。即，不用浏览器有任何关于，即可一次性处理完，更快更及时。</li>
</ul>
<p><img src="file:///e:\studying\book_files\27.jpg" alt="处理"></p>
<pre><code class="language-html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://libs.baidu.com/jquery/2.0.0/jquery.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span>
      
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">
<span class="hljs-comment">// 修改 DOM</span>
<span class="hljs-keyword">const</span> $p1 = $(<span class="hljs-string">&#x27;&lt;p&gt;一段文字&lt;/p&gt;&#x27;</span>)
<span class="hljs-keyword">const</span> $p2 = $(<span class="hljs-string">&#x27;&lt;p&gt;一段文字&lt;/p&gt;&#x27;</span>)
<span class="hljs-keyword">const</span> $p3 = $(<span class="hljs-string">&#x27;&lt;p&gt;一段文字&lt;/p&gt;&#x27;</span>)
$(<span class="hljs-string">&#x27;#container&#x27;</span>)
    .<span class="hljs-title function_">append</span>($p1)
    .<span class="hljs-title function_">append</span>($p2)
    .<span class="hljs-title function_">append</span>($p3)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>($(<span class="hljs-string">&#x27;#container p&#x27;</span>))
<span class="hljs-comment">// 微任务：渲染之前执行（DOM 结构已更新，未渲染在页面上）</span>
<span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> length = $(<span class="hljs-string">&#x27;#container&#x27;</span>).<span class="hljs-title function_">children</span>().<span class="hljs-property">length</span>
    <span class="hljs-title function_">alert</span>(<span class="hljs-string">`micro task <span class="hljs-subst">${length}</span>`</span>)
})

<span class="hljs-comment">// 宏任务：渲染之后执行（DOM 结构已更新）</span>
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> length = $(<span class="hljs-string">&#x27;#container&#x27;</span>).<span class="hljs-title function_">children</span>().<span class="hljs-property">length</span>
    <span class="hljs-title function_">alert</span>(<span class="hljs-string">`macro task <span class="hljs-subst">${length}</span>`</span>)
})
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p><img src="file:///e:\studying\book_files\28.jpg" alt="微任务执行"></p>
<h3 id="class和实例的关系以及原型链">Class和实例的关系以及原型链</h3>
<ol>
<li>每个class都有显示原型prototype【class还有constructor和__proto__】</li>
<li>每个实例都有隐式原型__proto__【实例无prototype，有constructor】</li>
<li>实例的__proto__指向对应class的prototype</li>
</ol>
<p>原型（prototype）主要指的是一个对象，它用于存储<code>共享属性和方法</code>。js每个函数都有一个prototype属性，这个属性是一个指针，指向一个对象，这个对象就是原型对象。可提高代码的复用性和效率。</p>
<p>原型链（prototype Chain）则是js实现继承的机制之一。每个对象都有一个<code>内部链接</code>指向另一个对象。这个链接被称为<code>对象的原型</code>。当试图访问一个对象的属性时，如果对象本身没有这个属性，那么js就会在这个对象的原型上寻找这个属性，这个原型对象自身也可能有原型，这样一层一层向上查找，就形成了一个链条，这就是原型链。</p>
<p>原型链不仅用于<code>实现继承</code>，还用于解决对象<code>属性查找</code>的问题。</p>
<p><img src="file:///e:\studying\book_files\33.jpg" alt="图1">
<img src="file:///e:\studying\book_files\32.jpg" alt="图2">
<img src="file:///e:\studying\book_files\34.jpg" alt="图3"></p>
<p>特殊之处：Function的构造函数是自己；Function的prototype和__proto__都指向<code>Function.prototype</code>，Function作为对象时，它的__proto__指向它构造函数的prototype。Object的构造函数也是Function,同时<code>一切对象又是Object创建</code>。</p>
<blockquote>
<p>一切函数对象（包括Object），都是继承Function对象</p>
</blockquote>
<h4 id="函数的特殊性">函数的特殊性</h4>
<ul>
<li>Person作为一个函数对象，它的隐式原型指向<code>Function.prototype</code></li>
<li>Person的prototype作为一个普通对象，它的隐式原型指向<code>Object.prototype</code></li>
<li>Function的<code>隐式原型和显示原型</code>则相等</li>
<li>Object作为一个函数对象，它的隐式原型指向Function.prototype</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>){}
<span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>()
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) <span class="hljs-comment">// true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)<span class="hljs-comment">// true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Function</span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)<span class="hljs-comment">// true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)<span class="hljs-comment">// true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)<span class="hljs-comment">// true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__proto__</span> === <span class="hljs-literal">null</span>)<span class="hljs-comment">// true</span>
</code></pre>
<h3 id="js如何实现继承">js如何实现继承</h3>
<p>它允许创建一个新的类（或对象），该类（或对象）可以继承另一个类（或对象）的属性和方法。</p>
<h4 id="继承的方案">继承的方案</h4>
<ul>
<li>原型链继承：复用prototype方法，缺点：1.对象类型的属性会被其他实例修改2.打印无法直接看到继承的属性3.原型创建时无法传参</li>
</ul>
<pre><code class="language-js"><span class="hljs-comment">// 无法定制化传参</span>
<span class="hljs-title class_">Cat</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>();
<span class="hljs-title class_">Cat</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Cat</span>;
</code></pre>
<ul>
<li>盗用构造函数继承：子类可传参，不会共用对象，但是父类prototype方法无法继承</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params"></span>){
	<span class="hljs-title class_">Parent</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, [test]); 
}
</code></pre>
<ul>
<li>
<p>组合继承：结合原型链+构造函数，两者优点有，缺点：调用两次父类，浪费性能，且继承的属性子类已经通过盗用构造函数存在了，父类对象又存在了一份无用的</p>
</li>
<li>
<p>原型式继承【用于字面量对象】,缺点：修改对象属性会改变其他对象的相关属性</p>
</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">var</span> obj = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;why&quot;</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,
  <span class="hljs-attr">arr</span>:[]
}
<span class="hljs-keyword">var</span> info = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(obj)<span class="hljs-comment">//浅拷贝</span>
info.<span class="hljs-property">name</span> =xxx 
info.<span class="hljs-property">arr</span>.<span class="hljs-title function_">push</span>(<span class="hljs-number">1</span>)
</code></pre>
<ul>
<li>寄生式继承【用于字面量对象】，核心：<code>使用原型式继承获得一个目标对象的浅复制，然后增强这个浅复制的能力。</code>缺点同上</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createAnother</span>(<span class="hljs-params">original</span>){
    <span class="hljs-keyword">var</span> clone = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(original);<span class="hljs-comment">//通过调用函数创建一个新对象</span>
	<span class="hljs-comment">// 增加了某些功能</span>
    clone.<span class="hljs-property">sayHi</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {<span class="hljs-comment">//以某种方式来增强这个对象</span>
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Hi&quot;</span>);
    };
    <span class="hljs-keyword">return</span> clone; <span class="hljs-comment">//返回这个对象</span>
}
</code></pre>
<ul>
<li>寄生组合式继承：比较完美的方案</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">clone</span> (parent, child) {
 <span class="hljs-comment">// Object.create</span>
 child.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(parent.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);
 child.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = child;
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent6</span>(<span class="hljs-params"></span>) {
 <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;parent6&#x27;</span>;
 <span class="hljs-variable language_">this</span>.<span class="hljs-property">play</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
}
<span class="hljs-title class_">Parent6</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
 <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Child6</span>(<span class="hljs-params"></span>) {
 <span class="hljs-title class_">Parent6</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);
 <span class="hljs-variable language_">this</span>.<span class="hljs-property">friends</span> = <span class="hljs-string">&#x27;child5&#x27;</span>;
}
<span class="hljs-title function_">clone</span>(<span class="hljs-title class_">Parent6</span>, <span class="hljs-title class_">Child6</span>);
<span class="hljs-title class_">Child6</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getFriends</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
 <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">friends</span>;
}
<span class="hljs-keyword">let</span> person6 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child6</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person6);
</code></pre>
<p><img src="file:///e:\studying\book_files\35.jpg" alt="整体思路"></p>
<h3 id="promise">Promise</h3>
<ul>
<li>三种状态 pending resolved rejected</li>
<li>then函数正常返回resolved，里面有报错返回rejected[如果有返回值，那么对应的then或者catch能拿到]</li>
<li>catch函数正常返回resolved，里面有报错返回rejected[同上]</li>
</ul>
<pre><code class="language-js"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">//1</span>
    }).<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>)
    }).<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>)
}).<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>)
    }).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(val)<span class="hljs-comment">//undefined</span>
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>)<span class="hljs-comment">//3</span>
})
</code></pre>
<pre><code class="language-js"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> { <span class="hljs-comment">// 返回 rejected 状态的 promise</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;erro1&#x27;</span>)
}).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> { <span class="hljs-comment">// 返回 resolved 状态的 promise</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e)  <span class="hljs-comment">//Error: erro1</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>) <span class="hljs-comment">// 2</span>
}).<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> { 
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>)
}).<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> { 
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>)
}).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>)<span class="hljs-comment">//3</span>
})
</code></pre>
<h4 id="应用场景">应用场景</h4>
<ul>
<li>图片加载</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">const</span> preloadImage = <span class="hljs-keyword">function</span> (<span class="hljs-params">path</span>) {
 <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) {
 <span class="hljs-keyword">const</span> image = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>();
 image.<span class="hljs-property">onload</span> = resolve;
 image.<span class="hljs-property">onerror</span> = reject;
 image.<span class="hljs-property">src</span> = path;
 });
};
</code></pre>
<h3 id="async-await">async await</h3>
<p>async 函数返回结果都是 <code>Promise 对象</code>（如果函数内没返回 Promise ，则自动封装一下）</p>
<pre><code class="language-js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn2</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">() =&gt;</span> {})
}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-title function_">fn2</span>() ) <span class="hljs-comment">//Promise {&lt;pending&gt;}</span>

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn1</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>
}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-title function_">fn1</span>() ) <span class="hljs-comment">// 相当于 Promise.resolve(100)</span>
</code></pre>
<p><strong>await相当于Promise的then.</strong></p>
<ul>
<li>await 后面跟 Promise 对象：会阻断后续代码，<code>等待状态变为 resolved</code> ，才获取结果并继续执行</li>
<li>await 后续跟非 Promise 对象：会直接返回该值，不过也是要等其他同步代码执行完后。如const f = await 400 ，内部相当于做了转换const f= await Promise.resolve(400)</li>
</ul>
<pre><code class="language-js">!(<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">() =&gt;</span> {})
    <span class="hljs-keyword">await</span> p1
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;p1&#x27;</span>) <span class="hljs-comment">// 不会执行</span>
})()

!(<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> p2 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">100</span>)
    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> p2
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res) <span class="hljs-comment">// 100</span>
})()

!(<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-number">100</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res) <span class="hljs-comment">// 100</span>
})()

!(<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> p3 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;some err&#x27;</span>)
    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> p3 
    <span class="hljs-comment">// new_file.html:34 Uncaught (in promise) some err</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res) <span class="hljs-comment">// 不会执行</span>
})()
使用<span class="hljs-keyword">try</span>…<span class="hljs-keyword">catch</span>捕获异常
(<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> p4 = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;some err&#x27;</span>)
    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> p4
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)
    } <span class="hljs-keyword">catch</span> (ex) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(ex)
    }
})()
</code></pre>
<h4 id="async-await异步本质">async await异步本质</h4>
<p>await是同步写法，但本质还是异步调用。即只要遇到了await ，<strong>后面的代码都相当于放在callback里。</strong></p>
<p>await虽然会异步调用，但是它后面的函数是立刻执行的。</p>
<pre><code class="language-js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">async1</span> () {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;async1 start&#x27;</span>)
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">async2</span>()
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;async1 end&#x27;</span>) <span class="hljs-comment">// 关键在这一步，它相当于放在 callback 中，最后执行</span>
}

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">async2</span> () {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;async2&#x27;</span>)
}

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script start&#x27;</span>)
<span class="hljs-title function_">async1</span>()
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script end&#x27;</span>)
</code></pre>
<h3 id="generator理解和应用">Generator理解和应用</h3>
<p>Generator通过yield标识位和next()方法调用，实现函数的分段执行。</p>
<p>function与函数名之间有一个星号 * ；函数体内部使用 yield 表达式，定义不同的内部状态。箭头函数不能用来定义生成器函数。</p>
<pre><code class="language-js"><span class="hljs-comment">//它内部有两个 yield表达式（hello和world），即该函数有三个状态：hello，world 和 return 语句（结束执行）。</span>
<span class="hljs-keyword">function</span>* <span class="hljs-title function_">helloWorldGenerator</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;hello&#x27;</span>;
  <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;world&#x27;</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;ending&#x27;</span>;
}
<span class="hljs-keyword">var</span> hw = <span class="hljs-title function_">helloWorldGenerator</span>();
</code></pre>
<pre><code class="language-js">hw.<span class="hljs-title function_">next</span>()
<span class="hljs-comment">// { value: &#x27;hello&#x27;, done: false } </span>
hw.<span class="hljs-title function_">next</span>()
<span class="hljs-comment">// { value: &#x27;world&#x27;, done: false }</span>
hw.<span class="hljs-title function_">next</span>()
<span class="hljs-comment">// { value: &#x27;ending&#x27;, done: true }</span>
hw.<span class="hljs-title function_">next</span>()
<span class="hljs-comment">// { value: undefined, done: true }</span>
</code></pre>
<p>生成器对象实现了Iterator接口，它默认的迭代器是自引用的。</p>
<pre><code class="language-js"><span class="hljs-keyword">function</span> *<span class="hljs-title function_">fun</span>(<span class="hljs-params"></span>){}
<span class="hljs-keyword">const</span> test =<span class="hljs-title function_">fun</span>()
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(test === test[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]())<span class="hljs-comment">//true</span>
</code></pre>
<pre><code class="language-js"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">helloWorldGenerator</span>(<span class="hljs-params">x,y</span>) {
  <span class="hljs-keyword">const</span> f1 = <span class="hljs-title function_">yield</span>(x+<span class="hljs-string">&#x27;hello&#x27;</span>);
  <span class="hljs-keyword">const</span> f2 = <span class="hljs-number">3</span> * (<span class="hljs-keyword">yield</span> (y+<span class="hljs-string">&#x27;world&#x27;</span>+f1));
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(f1,f2)<span class="hljs-comment">// 1 6</span>
  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;ending&#x27;</span>;
}
<span class="hljs-keyword">var</span> hw = <span class="hljs-title function_">helloWorldGenerator</span>(<span class="hljs-number">20</span>,<span class="hljs-number">50</span>);
<span class="hljs-keyword">const</span> v1= hw.<span class="hljs-title function_">next</span>() 
<span class="hljs-keyword">const</span> v2 = hw.<span class="hljs-title function_">next</span>(<span class="hljs-number">1</span>)
<span class="hljs-keyword">const</span> v3 = hw.<span class="hljs-title function_">next</span>(<span class="hljs-number">2</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(v1,v2,v3)
<span class="hljs-comment">// {value: &quot;20hello&quot;, done: false} {value: &quot;50world1&quot;, done: false} {value: &quot;ending&quot;, done: true}</span>
</code></pre>
<ol>
<li>初始化生成器:
<ul>
<li>调用 helloWorldGenerator(20,50) 来初始化生成器，并传入参数 20,50。</li>
<li>生成器函数内部的 x 被赋值为 20,y为50。</li>
</ul>
</li>
<li>第一次调用 hw.next():
<ul>
<li>生成器函数开始执行，直到遇到第一个 yield 表达式 yield(x+'hello')。</li>
<li>x 的值是 20，所以 yield 的值是 '20hello'。</li>
<li>生成器暂停执行，返回 { value: '20hello', done: false }。</li>
<li>v1 接收这个对象，所以 v1.value 是 '20hello'，v1.done 是 false。</li>
<li><code>此时 f1 还没有被赋值</code>。</li>
</ul>
</li>
<li>第二次调用 hw.next(1):
<ul>
<li>生成器恢复执行，并将 1 赋值给yield的右边(或者yield整体) const f1 = yield(x+'hello') 中的 <code>f1</code>。</li>
<li>接着，执行到 const f2 = 3 * (yield (y+'world'+f1))，生成器再次暂停执行。</li>
<li>yield 3 * (yield (y+'world'+f1)) 的值是 <code>50world1</code>。(y的50，f1的1)</li>
<li>生成器返回 { value: &quot;50world1&quot;, done: false }。</li>
<li>v2 接收这个对象。</li>
<li><strong>此时 f2 还没有被计算，因为它依赖于下一次 next() 方法的参数。</strong></li>
</ul>
</li>
<li>第三次调用 hw.next(2):
<ul>
<li>生成器恢复执行，并将 2 用于计算 const f2 =  3 * (yield (y+'world'+f1)) 中的 f2，即 f2 被赋值为 3 * 2 = 6。</li>
<li>然后执行 console.log(f1, f2)，输出 1 6。</li>
<li>生成器函数返回 'ending'，并结束执行。</li>
<li>生成器返回 { value: 'ending', done: true }。</li>
<li>v3 接收这个对象，所以 v3.value 是 'ending'，v3.done 是 true。</li>
</ul>
</li>
</ol>
<blockquote>
<p>for...of循环可以 自动遍历 Generator 函数运行时生成的Iterator对象，且此时不再需要调用next方法。</p>
</blockquote>
<h3 id="正则表达式">正则表达式</h3>
<p>正则表达式使用一种特殊的语法来定义模式，这些模式可以被用来搜索、匹配或替换文本。</p>
<pre><code class="language-js"><span class="hljs-comment">// 字面量方式</span>
<span class="hljs-keyword">let</span> regex = <span class="hljs-regexp">/pattern/</span>;
<span class="hljs-comment">// 构造函数方式</span>
<span class="hljs-keyword">let</span> regex1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&#x27;pattern&#x27;</span>);
</code></pre>
<p><img src="file:///e:\studying\book_files\52.jpg" alt="1">
<img src="file:///e:\studying\book_files\53.jpg" alt="2"></p>
<h4 id="正则的贪婪模式和懒惰模式">正则的贪婪模式和懒惰模式</h4>
<ul>
<li>在匹配的过程中，尝试可能的顺序是从多往少的方向去尝试，显示bbb，然后再看整个正则是否能匹配，不能匹配时，突出一个b，即在bb的基础上，再尝试，以此类推，如果多个贪婪量词挨着，则深度优先搜索。</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">const</span> reg = <span class="hljs-regexp">/ab{1,3}c/</span>
</code></pre>
<ul>
<li>在贪婪量词后加？就是惰性模式，尽可能少的匹配</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;sd2345s423987sd2342&#x27;</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\d{3,5}?/g</span>))
<span class="hljs-comment">// 因为增加了&quot;?&quot;符合，导致只要有符合3个连续数字的就返回。</span>
<span class="hljs-comment">// [&quot;234&quot;, &quot;423&quot;, &quot;987&quot;, &quot;234&quot;]</span>

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\d{3,5}/g</span>))
<span class="hljs-comment">// 去掉&quot;?&quot;后，变成了默认模式，就是贪婪匹配</span>
<span class="hljs-comment">// [&quot;2345&quot;, &quot;42398&quot;, &quot;2342&quot;]</span>
</code></pre>
<pre><code class="language-js"><span class="hljs-keyword">const</span> string = <span class="hljs-string">&quot;12345&quot;</span>;
<span class="hljs-keyword">const</span> regx = <span class="hljs-regexp">/\d{1,3}\d{1,3}/</span>;
<span class="hljs-keyword">const</span> reg1 = <span class="hljs-regexp">/(\d{1,3})\d{1,3}/</span>; <span class="hljs-comment">//括号表示分组</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( string.<span class="hljs-title function_">match</span>(regx) );<span class="hljs-comment">//[&#x27;12345&#x27;, index: 0, input: &#x27;12345&#x27;, groups: undefined]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( string.<span class="hljs-title function_">match</span>(reg1) );<span class="hljs-comment">//[&#x27;12345&#x27;, &#x27;123&#x27;, index: 0, input: &#x27;12345&#x27;, groups: undefined]</span>
</code></pre>
<h3 id="对象的一些方法">对象的一些方法</h3>
<ul>
<li><a href="http://Object.is">Object.is</a>():严格判断两个值是否相等，与严格比较===基本一致，除了+0和-0，NaN和NaN与之不一致</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">let</span> f1= {<span class="hljs-attr">k1</span>:<span class="hljs-number">1</span>}
<span class="hljs-keyword">let</span> f2 =f1
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(+<span class="hljs-number">0</span> === -<span class="hljs-number">0</span>) <span class="hljs-comment">//true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">NaN</span> === <span class="hljs-title class_">NaN</span> )<span class="hljs-comment">//false</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>(+<span class="hljs-number">0</span>, -<span class="hljs-number">0</span>) )<span class="hljs-comment">//false</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>(<span class="hljs-title class_">NaN</span>, <span class="hljs-title class_">NaN</span>) )<span class="hljs-comment">//true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>([], []) )<span class="hljs-comment">//false</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">is</span>(f1, f2) )<span class="hljs-comment">//true</span>
</code></pre>
<ul>
<li>Object.assign 用于合并对象将<code>源对象</code>(不包括原型)的所有<code>可枚举</code>属性复制到目标对象</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">const</span> target = { <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">1</span> };
<span class="hljs-keyword">const</span> source1 = { <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">2</span> };
<span class="hljs-keyword">const</span> source2 = { <span class="hljs-attr">c</span>: <span class="hljs-number">3</span> };
<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(target, source1, source2);
target <span class="hljs-comment">// {a:1, b:2, c:3}</span>
</code></pre>
<ul>
<li>Object.fromEntries 键值对数组转对象</li>
</ul>
<pre><code class="language-js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">fromEntries</span>([
 [<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>],
 [<span class="hljs-string">&#x27;baz&#x27;</span>, <span class="hljs-number">42</span>]
]))
</code></pre>
<h3 id="new-object和objectcretate以及objectassign区别">new Object()和Object.cretate()以及Object.assign()区别</h3>
<p>{}就是new Object的简单写法</p>
<p>Object.create() 静态方法以一个<strong>现有对象作为原型</strong>，创建一个新对象。</p>
<pre><code>Object.create(proto, propertiesObject)
</code></pre>
<p>Object.assign() 静态方法将一个或者多个源对象中所有<code>可枚举</code>的<code>自有属性</code>复制到目标对象，并返回修改后的目标对象。</p>
<pre><code>Object.assign(target, ...sources)
</code></pre>
<pre><code class="language-js"><span class="hljs-keyword">const</span> target = { <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> };
<span class="hljs-keyword">const</span> source = { <span class="hljs-attr">b</span>: <span class="hljs-number">4</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">5</span> };

<span class="hljs-keyword">const</span> returnedTarget = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(target, source);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target);
<span class="hljs-comment">// Expected output: Object { a: 1, b: 4, c: 5 }</span>

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(returnedTarget === target);
<span class="hljs-comment">// Expected output: true</span>
</code></pre>
<h3 id="关于对象的遍历方案">关于对象的遍历方案</h3>
<ol>
<li>for-in 循环循环自身和原型上的属性,不包括Symbol，<code>如果该属性设置了不可遍历</code>，则会忽略，可结合obj.hasOwnProperty(key)去规避原型上的属性</li>
</ol>
<pre><code class="language-js">	<span class="hljs-keyword">const</span> desc = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">&#x27;toString&#x27;</span>);  
	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(desc.<span class="hljs-property">enumerable</span>); <span class="hljs-comment">//  false</span>
	<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">addFun</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){
		
	}
	<span class="hljs-comment">// Object.getOwnPropertyDescriptor(obj,&#x27;x&#x27;),查出自身的属性的具体信息</span>
	<span class="hljs-keyword">const</span> addFun= <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">&#x27;addFun&#x27;</span>);
	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(addFun,addFun.<span class="hljs-property">enumerable</span>); <span class="hljs-comment">// true </span>

	<span class="hljs-keyword">function</span> <span class="hljs-title function_">Animal</span>(<span class="hljs-params">params</span>){
　　　　<span class="hljs-variable language_">this</span>.<span class="hljs-property">species</span> = <span class="hljs-string">&quot;动物&quot;</span>;
		<span class="hljs-variable language_">this</span>.<span class="hljs-property">animal</span>=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){
			<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;1000&#x27;</span>+params)
		};
		<span class="hljs-variable language_">this</span>.<span class="hljs-property">arr</span>=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>];
		
　　}
	<span class="hljs-title class_">Animal</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">dosomething</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){
		<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;do something&quot;</span>)
	}
　	<span class="hljs-keyword">function</span> <span class="hljs-title function_">Cat</span>(<span class="hljs-params">name,color</span>){
　　　　<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
　　　　<span class="hljs-variable language_">this</span>.<span class="hljs-property">color</span> = color;
　　}
	
	<span class="hljs-title class_">Cat</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>();
　　<span class="hljs-title class_">Cat</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Cat</span>;
　　<span class="hljs-keyword">var</span> cat1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-string">&quot;大毛&quot;</span>,<span class="hljs-string">&quot;黄色&quot;</span>);
	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(cat1)
	
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> item <span class="hljs-keyword">in</span> cat1){
		<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item)
	}
</code></pre>
<p><img src="file:///e:\studying\book_files\54.jpg" alt="参考"></p>
<ol start="2">
<li>Object.entries(obj)，Object.keys(obj)，Object.values(obj)只会给出对应的obj 自身的可遍历属性</li>
<li>Object.getOwnPropertyNames(obj) ：只获取对象自身的属性的key值，包括<strong>可遍历的和不可遍历的属性</strong></li>
<li>如果响应的属性key是Symbol设置的，那么是无法通过以上方法遍历的 ,可借助Object.getOwnPropertySymbols获取属性是symbol的</li>
</ol>
<pre><code class="language-js"><span class="hljs-keyword">let</span> obj = {}
<span class="hljs-keyword">let</span> age=<span class="hljs-title class_">Symbol</span>();
<span class="hljs-keyword">let</span> t1 =<span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;t1&#x27;</span>)
obj[age]=<span class="hljs-number">18</span>;
obj[t1]=<span class="hljs-string">&#x27;t111&#x27;</span>
<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertySymbols</span>(obj).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">el</span>=&gt;</span>{
	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj[el])
	<span class="hljs-comment">//18</span>
	<span class="hljs-comment">// t111</span>
})
</code></pre>
<ol start="5">
<li>
<p>for of也可以遍历有iterator接口的对象</p>
</li>
<li>
<p>Reflect.ownKeys 方法返回一个由目标对象自身的属性键组成的数组。它的返回值等同于 Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target))。</p>
</li>
</ol>
<h4 id="forof-对象适配">for...of 对象适配</h4>
<ul>
<li>借助generator</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">objectEntries</span>(<span class="hljs-params">obj</span>) {
  <span class="hljs-keyword">let</span> propKeys = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(obj);

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> propKey <span class="hljs-keyword">of</span> propKeys) {
    <span class="hljs-keyword">yield</span> [propKey, obj[propKey]];
  }
}

<span class="hljs-keyword">let</span> jane = { <span class="hljs-attr">first</span>: <span class="hljs-string">&#x27;Jane&#x27;</span>, <span class="hljs-attr">last</span>: <span class="hljs-string">&#x27;Doe&#x27;</span> };

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [key, value] <span class="hljs-keyword">of</span> <span class="hljs-title function_">objectEntries</span>(jane)) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${key}</span>: <span class="hljs-subst">${value}</span>`</span>);
}
<span class="hljs-comment">// first: Jane</span>
<span class="hljs-comment">// last: Doe</span>
</code></pre>
<h3 id="this指向">this指向</h3>
<p>this是一个关键字，它引用的是<code>当前执行上下文中</code>的对象。this的值取决于函数是如何被调用的，而不是函数被定义的位置。</p>
<p>第一种是函数调用模式，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。【在严格模式环境中，默认绑定的this指向undefined】</p>
<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">//window</span>
};

<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn1</span>(<span class="hljs-params"></span>) {
    <span class="hljs-string">&quot;use strict&quot;</span>;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">//undefined</span>
};

<span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;听风是风&#x27;</span>;

<span class="hljs-title function_">fn</span>(); 
<span class="hljs-title function_">fn1</span>();
</code></pre>
<pre><code class="language-js"><span class="hljs-comment">// 如果在严格模式下调用不在严格模式中的函数，并不会影响this指向</span>
<span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;听风是风&#x27;</span>;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">//window</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>); <span class="hljs-comment">//听风是风</span>
};

(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-string">&quot;use strict&quot;</span>;
    <span class="hljs-title function_">fn</span>();
}());
</code></pre>
<p>第二种是方法调用模式，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。</p>
<pre><code class="language-js"><span class="hljs-comment">//如果函数调用前存在多个对象，this指向距离调用自己最近的对象</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);
};
<span class="hljs-keyword">let</span> obj = {
    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;行星飞行&#x27;</span>,
    <span class="hljs-attr">func</span>: fn,
};
<span class="hljs-keyword">let</span> obj1 = {
    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;听风是风&#x27;</span>,
    <span class="hljs-attr">o</span>: obj
};
obj1.<span class="hljs-property">o</span>.<span class="hljs-title function_">func</span>() <span class="hljs-comment">//行星飞行</span>

<span class="hljs-comment">//obj对象虽然obj1的属性，但它两原型链并不相同，并不是父子关系，由于obj未提供name属性，所以是undefined。</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);
};
<span class="hljs-keyword">let</span> obj = {
    <span class="hljs-attr">func</span>: fn,
};
<span class="hljs-keyword">let</span> obj1 = {
    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;听风是风&#x27;</span>,
    <span class="hljs-attr">o</span>: obj
};
obj1.<span class="hljs-property">o</span>.<span class="hljs-title function_">func</span>() <span class="hljs-comment">//？？</span>
</code></pre>
<pre><code class="language-js"><span class="hljs-comment">// 虽然obj对象并没有name属性，但顺着原型链，找到了产生自己的构造函数Fn，由于Fn原型链存在name属性，所以输出时间跳跃了。</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Fn</span>(<span class="hljs-params"></span>) {};
<span class="hljs-title class_">Fn</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;时间跳跃&#x27;</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);
};

<span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fn</span>();
obj.<span class="hljs-property">func</span> = fn;

<span class="hljs-keyword">let</span> obj1 = {
    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;听风是风&#x27;</span>,
    <span class="hljs-attr">o</span>: obj
};
obj1.<span class="hljs-property">o</span>.<span class="hljs-title function_">func</span>() <span class="hljs-comment">//?</span>
</code></pre>
<p>第三种是构造器调用模式，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。</p>
<p>第四种是 apply 、 call 和 bind 调用模式，这三个方法都可以显示的指定调用函数的 this 指向。如果在使用call之类的方法改变this指向时，指向参数提供的是<code>null或者undefined</code>，那么 this 将指向全局对象。另外，在js API中部分方法也内置了显式绑定，以<strong>forEach</strong>为例：</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> obj1 = {
    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;听风是风&#x27;</span>
};
<span class="hljs-keyword">let</span> obj2 = {
    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;时间跳跃&#x27;</span>
};
<span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;行星飞行&#x27;</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);
};
fn.<span class="hljs-title function_">call</span>(<span class="hljs-literal">undefined</span>); <span class="hljs-comment">//行星飞行</span>
fn.<span class="hljs-title function_">apply</span>(<span class="hljs-literal">null</span>); <span class="hljs-comment">//行星飞行</span>
fn.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">undefined</span>)(); <span class="hljs-comment">//行星飞行</span>
<span class="hljs-keyword">let</span> obj = {
    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;听风是风&#x27;</span>
};

[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<span class="hljs-comment">//听风是风*3</span>
}, obj);
</code></pre>
<p>这四种方式，使用构造器调用模式的优先级最高，然后是 apply、call和 bind 调用模式，然后是方法调用模式，然后是函数调用模式。</p>
<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a</span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> = a;
}

<span class="hljs-keyword">const</span> obj1 = {};
<span class="hljs-keyword">var</span> bar = foo.<span class="hljs-title function_">bind</span>(obj1);
<span class="hljs-title function_">bar</span>(<span class="hljs-number">2</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj1.<span class="hljs-property">a</span>); <span class="hljs-comment">// 2</span>

<span class="hljs-keyword">var</span> baz = <span class="hljs-keyword">new</span> <span class="hljs-title function_">bar</span>(<span class="hljs-number">3</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(baz.<span class="hljs-property">a</span>) <span class="hljs-comment">// 3</span>

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj1)<span class="hljs-comment">//{a: 2}</span>

</code></pre>
<p>bar 函数本身是通过 bind 方法构造的函数，其内部已经对将 this 绑定为 obj1，它再作为构造函数，通过 new 调用时，返回的实例已经与 obj1 解绑。</p>
<h4 id="this隐式绑定丢失">this隐式绑定丢失</h4>
<p>隐式丢失最常见的就是作为<code>参数传递以及变量赋值</code> ,一个最常见的 this 绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，从而把 this 绑定到全局对象或者 undefined或者是新创建的隐式绑定的对象上，取决于是否是严格模式</p>
<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> );
}
<span class="hljs-keyword">var</span> obj = {
<span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,
<span class="hljs-attr">foo</span>: foo
};
<span class="hljs-keyword">var</span> bar = obj.<span class="hljs-property">foo</span>; <span class="hljs-comment">// 函数别名！</span>
<span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;oops, global&quot;</span>; <span class="hljs-comment">// a 是全局对象的属性</span>
<span class="hljs-comment">//bar作为一个独立的函数被调用，而不是作为 obj 的方法被调用</span>
<span class="hljs-title function_">bar</span>(); <span class="hljs-comment">// &quot;oops, global&quot;</span>
obj.<span class="hljs-title function_">foo</span>()<span class="hljs-comment">//2</span>
</code></pre>
<blockquote>
<p>这种情况还有在callback回调时也可能会发生（doFoo( obj.foo )）此时的obj.foo相当于fn = obj.foo</p>
</blockquote>
<p>注意，隐式绑定丢失并不是都会指向全局对象，比如下面的例子：</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;行星飞行&#x27;</span>;
<span class="hljs-keyword">let</span> obj = {
    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;听风是风&#x27;</span>,
    <span class="hljs-attr">fn</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);
    }
};
<span class="hljs-keyword">let</span> obj1 = {
    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;时间跳跃&#x27;</span>
}
obj1.<span class="hljs-property">fn</span> = obj.<span class="hljs-property">fn</span>;
obj1.<span class="hljs-title function_">fn</span>(); <span class="hljs-comment">//时间跳跃</span>
</code></pre>
<p>虽然丢失了 obj 的隐式绑定，但是在赋值的过程中，<strong>又建立了新的隐式绑定</strong>，这里this就指向了对象 obj1。</p>
<h4 id="call-appy-bind的用法和区别">call appy bind的用法和区别</h4>
<p>都是JavaScript中用于改变函数执行上下文（即this的指向）的方法</p>
<ol>
<li>call、apply只是临时的修改一次，即只在call或apply方法的那一次有效；当再次调用原函数的时候，它的指向还是原来的指向。而bind方法创建的新函数会<code>永久性地绑定this值</code>。</li>
<li>call和apply基本一致，除了传参有些不同</li>
<li>call和apply立刻执行，而bind则是返回一个函数，需要再次调用</li>
</ol>
<h3 id="new操作做了什么">new操作做了什么</h3>
<ol>
<li>创建一个新的<code>空对象</code></li>
<li>这个新对象内部的<code>[[prototype]]</code>特性被赋值为构造函数的<code>prototype</code>属性</li>
<li>构造函数内部的this被赋值为这个新对象(即this指向新对象)</li>
<li>执行构造函数内部的代码:给对象<code>添加属性和方法</code></li>
<li>如果构造函数返回 <code>一个对象</code> ，则返回<code>该对象</code>；否则返回<strong>刚创建的对象</strong>(如果return 1等数字/字符串/布尔值会被引擎忽略，然后返回刚创建的对象)</li>
</ol>
<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)
{
 <span class="hljs-variable language_">this</span>.<span class="hljs-property">user</span> = <span class="hljs-string">&#x27;xxx&#x27;</span>;
 <span class="hljs-keyword">return</span> {};
}
<span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title function_">fn</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-property">user</span>); <span class="hljs-comment">//undefined</span>
</code></pre>
<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)
	{
	 <span class="hljs-variable language_">this</span>.<span class="hljs-property">user</span> = <span class="hljs-string">&#x27;xxx&#x27;</span>;
	 <span class="hljs-comment">// return null;//null和其他基本类型返回的都是实例对象本身</span>
	 <span class="hljs-keyword">return</span><span class="hljs-string">&#x27;xxx1&#x27;</span>
	}
	<span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title function_">fn</span>();
	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-property">user</span>); <span class="hljs-comment">//xxx</span>
</code></pre>
<h3 id="js基本类型的装箱与拆箱">JS基本类型的装箱与拆箱</h3>
<p>装箱的概念：把基本类型转化为相应的对象。而装箱又分为<code>显式与隐式</code></p>
<p>在 JavaScript 中，基本类型是没有属性和方法的，但是为了便于操作基本类型的值，在调用基本类型的属性或方法时 JavaScript 会在<code>后台隐式</code>地将基本类型的值转换为对象</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> s1  = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;some text&quot;</span>);
<span class="hljs-keyword">var</span> s2 = s1.<span class="hljs-title function_">substring</span>(<span class="hljs-number">2</span>);
s1 = <span class="hljs-literal">null</span>;
</code></pre>
<p>JavaScript 也可以使用 <code>Object 函数</code>显式地将基本类型转换为包装类型：</p>
<pre><code class="language-js"><span class="hljs-title class_">Object</span>(<span class="hljs-number">1</span>)
</code></pre>
<p>拆箱：将引用类型对象转换为对应的值类型对象，它是通过引用类型的valueOf()或者toString()方法来实现的。</p>
<p>二者并存的情况下，在数值运算中，优先调用了valueOf，字符串运算中，优先调用了toString。</p>
<pre><code class="language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {
    <span class="hljs-title function_">valueOf</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>
    }
    <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;哈哈哈&#x27;</span>
    }
}
<span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title function_">A</span>()

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">String</span>(a))  <span class="hljs-comment">// &#x27;哈哈哈&#x27;   =&gt; (toString)</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Number</span>(a))  <span class="hljs-comment">// 2         =&gt; (valueOf)</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a + <span class="hljs-string">&#x27;22&#x27;</span>)   <span class="hljs-comment">// &#x27;222&#x27;     =&gt; (valueOf)</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a == <span class="hljs-number">2</span>)     <span class="hljs-comment">// true      =&gt; (valueOf)</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a === <span class="hljs-number">2</span>)    <span class="hljs-comment">// false     =&gt; (严格等于不会触发隐式转换)</span>
</code></pre>
<p><strong>Symbol.toPrimitive</strong> 是一个内置的 Symbol 值，它是作为对象的函数值属性存在的，当一个对象转换为对应的原始值时，会调用此函数。</p>
<p>作用：同valueOf()和toString()一样，但是<strong>优先级</strong>要高于这两者</p>
<h3 id="new-string-和string区别">new String 和String区别</h3>
<pre><code class="language-js"><span class="hljs-keyword">let</span> a1 =<span class="hljs-string">&#x27;a1&#x27;</span>
<span class="hljs-keyword">let</span> a2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&#x27;a2&#x27;</span>)
<span class="hljs-keyword">let</span> a3 = <span class="hljs-title class_">String</span>(<span class="hljs-string">&#x27;a3&#x27;</span>)
a1.<span class="hljs-property">name</span>=<span class="hljs-string">&#x27;zs&#x27;</span>
a2.<span class="hljs-property">name</span>=<span class="hljs-string">&#x27;ls&#x27;</span>
a3.<span class="hljs-property">name</span>=<span class="hljs-string">&#x27;ww&#x27;</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a1)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a2)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a3)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a1.<span class="hljs-property">name</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a2.<span class="hljs-property">name</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a3.<span class="hljs-property">name</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> a1)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> a2)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> a3)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a2+<span class="hljs-string">&#x27;333&#x27;</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a2.<span class="hljs-property">name</span>)
<span class="hljs-comment">// a1</span>
<span class="hljs-comment">// String {&#x27;a2&#x27;, name: &#x27;ls&#x27;}</span>
<span class="hljs-comment">// a3</span>
<span class="hljs-comment">// undefined</span>
<span class="hljs-comment">// ls</span>
<span class="hljs-comment">// undefined</span>
<span class="hljs-comment">// string</span>
<span class="hljs-comment">// object</span>
<span class="hljs-comment">// string</span>
<span class="hljs-comment">//a2333</span>
<span class="hljs-comment">//ls</span>
</code></pre>
<pre><code class="language-js"><span class="hljs-keyword">let</span> a4 = <span class="hljs-string">&#x27;a4&#x27;</span>
<span class="hljs-keyword">let</span> a5 = <span class="hljs-title class_">String</span>(<span class="hljs-string">&#x27;a4&#x27;</span>)
<span class="hljs-keyword">let</span> a6 =<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&#x27;a4&#x27;</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a4===a5)<span class="hljs-comment">//true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a4===a6)<span class="hljs-comment">//false</span>
</code></pre>
<h3 id="事件-事件流">事件 事件流</h3>
<p>事件：html文档或浏览器发生的一种交互操作，如加载/鼠标事件/自定义事件等。</p>
<p>事件流则是描述事件在DOM（文档对象模型）元素间的传播顺序。事件流包括三个阶段：<code>事件捕获阶段、目标阶段和事件冒泡阶段</code>。</p>
<p><img src="file:///e:\studying\book_files\43.jpg" alt="事件机制"></p>
<h4 id="事件模型">事件模型</h4>
<p>原始事件模型（DOM0级事件模型）和标准事件模型（DOM2级事件模型）在JavaScript中分别代表了不同的事件处理机制。</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;fun()&quot;</span>&gt;</span>
</code></pre>
<pre><code class="language-js"><span class="hljs-keyword">var</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;.btn&#x27;</span>);
btn.<span class="hljs-property">onclick</span> = fun;
</code></pre>
<p>原始事件模型可通过html或者js绑定，绑定速度快，同一事件只支持一次绑定，多次绑定后者覆盖前者。</p>
<p>标准事件模型（DOM2级事件模型）则提供了更为完整和灵活的事件处理机制。它引入了事件传播的概念，包括事件捕获和事件冒泡两个阶段。</p>
<p>还提供了更多的事件处理方法和属性，如addEventListener()用于添加事件监听器，removeEventListener()用于移除事件监听器。可同一个元素多次绑定同一类事件</p>
<pre><code class="language-js"><span class="hljs-title function_">addEventListener</span>(eventType, handler, useCapture) <span class="hljs-comment">//useCapture:默认false，非捕获阶段监听</span>
</code></pre>
<h5 id="eventeventphase">event.eventPhase</h5>
<ul>
<li>Event.NONE：值为0，表示事件不在任何阶段。</li>
<li>Event.CAPTURING_PHASE：值为1，表示事件当前正在捕获阶段。</li>
<li>Event.AT_TARGET：值为2，表示事件已经到达其目标元素。</li>
<li>Event.BUBBLING_PHASE：值为3，表示事件当前正在冒泡阶段。</li>
</ul>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div&quot;</span>&gt;</span>
	22222
	<span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;p&#x27;</span>&gt;</span>1111<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">
	<span class="hljs-keyword">var</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;div&#x27;</span>);
	<span class="hljs-keyword">var</span> p = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;p&#x27;</span>);
	<span class="hljs-keyword">function</span> <span class="hljs-title function_">onClickFn</span> (event) {
	 <span class="hljs-keyword">var</span> tagName = event.<span class="hljs-property">currentTarget</span>.<span class="hljs-property">tagName</span>;
	 <span class="hljs-keyword">var</span> phase = event.<span class="hljs-property">eventPhase</span>;
	 <span class="hljs-keyword">if</span>(phase == <span class="hljs-title class_">Event</span>.<span class="hljs-property">AT_TARGET</span>){
		 <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;11111&#x27;</span>)
	 }
	 <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(tagName, phase);
	}
	div.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, onClickFn, <span class="hljs-literal">false</span>);
	p.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, onClickFn, <span class="hljs-literal">false</span>);
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p>点击1111</p>
<p><img src="file:///e:\studying\book_files\44.jpg" alt="点击1111"></p>
<h4 id="ie事件模型">IE事件模型</h4>
<p>IE事件模型主要基于冒泡型事件传播机制。</p>
<pre><code class="language-js"><span class="hljs-title function_">attachEvent</span>(eventType, handler)
<span class="hljs-title function_">detachEvent</span>(eventType, handler)
</code></pre>
<h4 id="事件代理">事件代理</h4>
<p>事件代理（Event Delegation），也被称为事件委托，其核心原理是DOM元素的事件冒泡。当有大量子元素需要触发事件时，事件代理可以将事件监听器绑定在父元素上，而非直接绑定在子元素上，这样数百个事件监听器就可以减少为一个，从而显著提高网页性能。</p>
<p>事件代理的好处主要有以下几点：</p>
<ul>
<li>性能优化：通过减少事件监听器的数量，可以<code>节省内存</code>并提升性能。</li>
<li>方便添加子元素：当新增子对象时，无需再次对其绑定事件，因为父元素已经负责监听这些事件。</li>
<li>灵活性和可维护性：通过事件代理，可以更加灵活地处理事件，并且便于维护代码。</li>
</ul>
<blockquote>
<p>focus blur 不支持冒泡；mousemove mouseout 虽然支持，但是会影响性能不适合。</p>
</blockquote>
<h4 id="阻止事件冒泡和默认事件">阻止事件冒泡和默认事件</h4>
<ul>
<li>event.stopPropagation():仅阻止事件冒泡，不影响同一元素上其他相同类型的事件处理程序。</li>
<li>event.stopImmediatePropagation():阻止事件冒泡并且阻止该元素上同事件类型的监听器被触发 【除了停止事件继续捕捉或冒泡传递外，也阻止事件被传入同元素中注册的其它相同事件类型监听器。】</li>
<li>event.preventDefalut():阻止默认事件</li>
</ul>
<pre><code class="language-js"><span class="hljs-comment">// 假设有一个 div 元素和两个点击事件处理程序  </span>
<span class="hljs-keyword">const</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;myDiv&#x27;</span>);  
  
div.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) {  
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;处理程序 1&#x27;</span>);  
  event.<span class="hljs-title function_">stopPropagation</span>(); <span class="hljs-comment">// 仅阻止冒泡  </span>
});  
  
div.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) {  
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;处理程序 2&#x27;</span>);  
});  
  
<span class="hljs-comment">// 当 div 被点击时，控制台将输出 &quot;处理程序 1&quot;，因为 stopPropagation() 阻止了冒泡  </span>
<span class="hljs-comment">// 但 &quot;处理程序 2&quot; 仍然会执行，因为 stopPropagation() 不影响同一元素上的其他处理程序  </span>
  
<span class="hljs-comment">// 修改代码，使用 stopImmediatePropagation()  </span>
div.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) {  
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;处理程序 1&#x27;</span>);  
  event.<span class="hljs-title function_">stopImmediatePropagation</span>(); <span class="hljs-comment">// 阻止冒泡和其他处理程序  </span>
});  
  
<span class="hljs-comment">// 当 div 被点击时，控制台仅输出 &quot;处理程序 1&quot;，因为 stopImmediatePropagation() 阻止了冒泡和其他处理程序</span>
</code></pre>
<h3 id="eventtarget和eventcurrenttarget二者含义">event.target和event.currentTarget二者含义</h3>
<p>Event 接口的只读属性 currentTarget 表示的，标识是当事件沿着 DOM 触发时事件的<code>当前目标</code>。它总是指向事件绑定的元素，而 Event.target 则是<code>事件触发</code>的元素。</p>
<pre><code class="language-js">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;
<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;k1&#x27;</span>&gt;</span>22
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;b1&#x27;</span>&gt;</span>11111<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span>
<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript">
  <span class="hljs-keyword">let</span> b1 =<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;k1&#x27;</span>)
  b1.<span class="hljs-property">onclick</span> =<span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>){
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">target</span>)
    <span class="hljs-comment">// 当点击在22上指向k1，点击11111上指向b1</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(e.<span class="hljs-property">currentTarget</span>)
    <span class="hljs-comment">// 一直都执行id=k1的div</span>
  }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
</code></pre>
<h3 id="判断一个元素是否在可视区">判断一个元素是否在可视区</h3>
<p>对应的应用场景：【图片懒加载/列表的无限滚动/可点击链接的预加载】</p>
<ul>
<li>getBoundingClientRect</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isElementInView</span>(<span class="hljs-params">element</span>) {  
    <span class="hljs-keyword">var</span> rect = element.<span class="hljs-title function_">getBoundingClientRect</span>();  
    <span class="hljs-keyword">return</span> (  
        rect.<span class="hljs-property">top</span> &gt;= <span class="hljs-number">0</span> &amp;&amp;  
        rect.<span class="hljs-property">left</span> &gt;= <span class="hljs-number">0</span> &amp;&amp;  
        rect.<span class="hljs-property">bottom</span> &lt;= (<span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span> || <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">clientHeight</span>) &amp;&amp;  
        rect.<span class="hljs-property">right</span> &lt;= (<span class="hljs-variable language_">window</span>.<span class="hljs-property">innerWidth</span> || <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">clientWidth</span>)  
    );  
}  

<span class="hljs-keyword">var</span> myElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;my-element&#x27;</span>);  
<span class="hljs-keyword">if</span> (<span class="hljs-title function_">isElementInView</span>(myElement)) {  
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Element is in view.&#x27;</span>);  
} <span class="hljs-keyword">else</span> {  
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Element is not in view.&#x27;</span>);  
}
</code></pre>
<ul>
<li>IntersectionObserver:它可以在元素进入或离开视口时异步观察目标元素与其祖先元素或顶级文档视口的交叉状态。</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">observeElement</span>(<span class="hljs-params">element</span>) {  
    <span class="hljs-keyword">var</span> observer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntersectionObserver</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">entries, observer</span>) {  
        entries.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">entry</span>) {  
            <span class="hljs-keyword">if</span> (entry.<span class="hljs-property">isIntersecting</span>) {  
                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Element is in view.&#x27;</span>);  
            } <span class="hljs-keyword">else</span> {  
                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Element is not in view.&#x27;</span>);  
            }  
        });  
    });  
    observer.<span class="hljs-title function_">observe</span>(element);  
}  
  
<span class="hljs-keyword">var</span> myElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;my-element&#x27;</span>);  
<span class="hljs-title function_">observeElement</span>(myElement);
</code></pre>
<ul>
<li>滚动事件监听去判断 offsetTop scrollTop</li>
</ul>
<h3 id="监听一个div宽度变化">监听一个div宽度变化</h3>
<pre><code class="language-js"><span class="hljs-keyword">const</span> ro = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResizeObserver</span>(<span class="hljs-function">(<span class="hljs-params">entries, observer</span>) =&gt;</span> {  
	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(entries,observer)
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> entry <span class="hljs-keyword">of</span> entries) {  
		<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Element:&#x27;</span>, entry.<span class="hljs-property">target</span>);  
		<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Element size:&#x27;</span>, entry.<span class="hljs-property">contentRect</span>);  
	}  
});  
	
<span class="hljs-keyword">const</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#myDiv&#x27;</span>);  
ro.<span class="hljs-title function_">observe</span>(div);
</code></pre>
<h3 id="mutationobserver触发机制及应用场景">MutationObserver触发机制及应用场景</h3>
<ul>
<li>可以在<code>DOM修改</code>时<code>异步</code>执行回调</li>
<li>MutationObserver还可以用于监测元素的添加、删除、属性更改、文本内容变化等多种类型的DOM变化</li>
<li>自动保存表单数据：当用户在表单中输入或修改数据时，MutationObserver可以监测到DOM的变化，并自动调用回调函数进行保存操作，实现数据的实时保存。</li>
<li>动态内容加载：当页面中的内容是通过异步加载或动态生成时，MutationObserver可以用来监测内容的变化，并在变化发生后执行相应的操作，例如更新页面布局、添加事件监听器等。这在无限滚动加载的场景中尤为有用，当新的内容被加载到页面时，MutationObserver可以自动触发相应的处理逻辑。</li>
</ul>
<pre><code class="language-js">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset=&quot;utf-8&quot; /&gt;
		&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;
		&lt;title&gt;&lt;/title&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;div id=&quot;k&quot;&gt;&lt;/div&gt;
	&lt;/body&gt;
&lt;/html&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
	let observer = new MutationObserver(() =&gt; console.log(&#x27;&lt;body&gt; attributes changed&#x27;));
	
	observer.observe(document.body, { attributes: true });//页面初始化dom触发一次
	
	document.body.className = &#x27;foo&#x27;; //更改触发一次
	console.log(&#x27;Changed body class&#x27;);
	setTimeout(()=&gt;{
		document.getElementById(&quot;k&quot;).innerHTML=333//更改子元素或者非body的属性内容泽不会触发函数执行
		// document.body.className = &#x27;foo1&#x27;; //如果不注释，会执行两次&lt;body&gt; attributes changed
	})
	//Changed body class
	// &lt;body&gt; attributes changed
	//回调的console是后执行的，表明回调并非与实际的DOM变化同步执行
&lt;/script&gt;
</code></pre>
<h3 id="js单线程详解">Js单线程详解</h3>
<p>JavaScript和DOM渲染共用同一个线程。在浏览器中，有一个称为“主线程”的线程，它负责处理JavaScript代码的执行、布局和渲染。</p>
<p>当JavaScript代码执行时，它会阻塞主线程，这意味着浏览器无法同时执行其他任务，包括DOM渲染。因此，JavaScript代码的执行速度对网页的性能有很大的影响。为了避免这种情况，可以使用<code>Web Workers</code>在后台运行JavaScript代码，或者使用异步编程技术来避免阻塞主线程。</p>
<p>浏览器渲染进程是多线程的，它包括下面几个线程：</p>
<ul>
<li><strong>GUI 渲染线程</strong>:负责渲染浏览器界面，解析 HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等。
<ol>
<li>解析html代码(HTML代码本质是字符串)转化为浏览器认识的节点，生成DOM树，也就是DOM Tree</li>
<li>解析css，生成CSSOM(CSS规则树)</li>
<li>把DOM Tree 和CSSOM结合，生成Rendering Tree(渲染树)
当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行</li>
</ol>
</li>
</ul>
<p>GUI 渲染线程与 JS 引擎线程是互斥的，当 JS 引擎执行时 GUI 线程会被挂起（相当于被冻结了），GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行。</p>
<ul>
<li><strong>JS 引擎线程</strong>:称为 JS 内核，负责处理 Javascript 脚本程序。（例如 V8 引擎）
<ol>
<li>JS引擎线程负责解析Javascript脚本，运行代码。</li>
<li>JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个 Tab页（renderer进程）无论什么时候都只有一个JS线程在运行，JS程序同样注意，GUI渲染线程与JS引擎线程是互斥的，如果JS执行时间过长，会造成页面的渲染不连贯，页面渲染加载阻塞。</li>
</ol>
</li>
<li><strong>事件触发线程</strong>:归属于浏览器而不是 JS 引擎，用来控制事件循环（可以理解，JS 引擎自己都忙不过来，需浏览器另开线程协助）,用来控制事件循环，并且管理着一个事件队列(task queue)</li>
</ul>
<p>当js执行碰到事件绑定和一些异步操作(如setTimeOut，也可来自浏览器内核的其他线程，如鼠标点击、AJAX异步请求等)，会走事件触发线程将对应的事件添加到对应的线程中 (比如定时器操作，便把定时器事件添加到定时器线程)，等异步事件有了结果，便把他们的回调操作添加到事件队列，等待js引擎线程空闲时来处理。</p>
<p>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理</p>
<p>注意，由于 JS 的单线程关系，所以这些待处理队列中的事件都得排队等待 JS 引擎处理（当 JS 引擎空闲时才会去执行）</p>
<ul>
<li><strong>定时触发器线程</strong>:setInterval 与 setTimeout 所在线程</li>
</ul>
<p>浏览器定时计数器并不是由JS引擎计数的,（因为JS引擎是单线程的, 如果处于阻塞线程状态就会影响记计准确）。因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待 JS 引擎空闲后执行）</p>
<p>注意，W3C 在 HTML 标准中规定，规定要求 setTimeout 中低于 4ms 的时间间隔算为 4ms。</p>
<ul>
<li><strong>异步 http 请求线程</strong>:在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求
将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由 JavaScript 引擎执行。</li>
</ul>
<h3 id="本地存储和场景">本地存储和场景</h3>
<ul>
<li>Cookies：它是由服务器发送到浏览器，并保存在浏览器上的一小段数据。Cookies主要用于跟踪会话信息，但由于其大小限制（通常不超过<code>4KB</code>）和每次<code>请求</code>都会发送到服务器的特性，不适合<code>大量数据</code>的存储。【标记用户和跟踪用户行为】</li>
<li>Web Storage API：包括localStorage和sessionStorage。提供了更大的存储空间，并且数据只保存在客户端，不会发送到服务器。
<ul>
<li>localStorage：数据没有过期时间，会一直保存在浏览器中，直到用户手动清除或通过JavaScript代码清除。它非常适合存储那些不需要经常变动的数据，如[用户设置、主题偏好、登录令牌]等。</li>
<li>sessionStorage：数据在页面会话结束时过期，即当页面关闭时数据会被清除。[敏感账号一次性登录]</li>
</ul>
</li>
<li>IndexedDB：IndexedDB是一个事务型的数据库系统，用于客户端存储大量结构化数据（包括文件/二进制数据）。它使用索引来实现高性能搜索[在线文档编辑历史]</li>
<li>WebSQL：WebSQL是一个基于SQL的数据库API，允许在浏览器中存储、查询和管理数据。[停止维护]</li>
<li>File API 和 FileSystem API：这些API允许Web应用程序在用户的本地文件系统中读取和写入文件。然而，出于安全和隐私的考虑，这些API的使用受到严格限制，并且需要用户的明确许可。</li>
</ul>
<h4 id="cookie的修改注意">cookie的修改注意</h4>
<p>cookie必须domain和path一致才是修改的同一个，否则就是新增的另外一个cookie</p>
<pre><code class="language-js"><span class="hljs-title class_">Set</span>-<span class="hljs-title class_">Cookie</span>:name=aa; domain=aa.<span class="hljs-property">net</span>; path=/ #
<span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span> =name=bb; domain=aa.<span class="hljs-property">net</span>; path=/ #
</code></pre>
<h4 id="localstorange本地过期时间">localstorange本地过期时间</h4>
<pre><code class="language-js"><span class="hljs-comment">// 设置带有过期时间的数据  </span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">setWithExpiration</span>(<span class="hljs-params">key, value, expirationTime</span>) {  
    <span class="hljs-keyword">const</span> now = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>();  
    <span class="hljs-keyword">const</span> item = {  
        <span class="hljs-attr">value</span>: value,  
        <span class="hljs-attr">expiration</span>: now + expirationTime  
    };  
    <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(key, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(item));  
}  
  
<span class="hljs-comment">// 获取带有过期时间的数据  </span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">getWithExpiration</span>(<span class="hljs-params">key</span>) {  
    <span class="hljs-keyword">const</span> itemStr = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(key);  
    <span class="hljs-keyword">if</span> (!itemStr) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  
  
    <span class="hljs-keyword">const</span> item = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(itemStr);  
    <span class="hljs-keyword">const</span> now = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getTime</span>();  
    <span class="hljs-keyword">if</span> (now &gt; item.<span class="hljs-property">expiration</span>) {  
        <span class="hljs-comment">// 数据已过期，删除它  </span>
        <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(key);  
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  
    }  
    <span class="hljs-keyword">return</span> item.<span class="hljs-property">value</span>;  
} 
</code></pre>
<h4 id="cookie查看范围和跨域携带">cookie查看范围和跨域携带</h4>
<ol>
<li>一般来说，子域名可以读取上级域名的Cookie，但不能读取到下级域名的Cookie。这是因为Cookie的Domain属性指定了可以访问该Cookie的Web站点或域</li>
<li>跨域请求携带Cookie的方法主要涉及到前后端的配置。</li>
</ol>
<pre><code class="language-js"><span class="hljs-comment">// 全局配置</span>
axios.<span class="hljs-property">defaults</span>.<span class="hljs-property">withCredentials</span> = <span class="hljs-literal">true</span>;<span class="hljs-comment">//指示浏览器包含凭证信息  </span>
</code></pre>
<pre><code class="language-js"><span class="hljs-comment">//单个接口配置</span>
axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;http://example.com/api/data&#x27;</span>, { <span class="hljs-attr">withCredentials</span>: <span class="hljs-literal">true</span> })  
  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> {  
    <span class="hljs-comment">// 处理响应...  </span>
  })  
  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {  
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);  
  });
</code></pre>
<p>后端配置</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);  
<span class="hljs-keyword">const</span> cors = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;cors&#x27;</span>);  
<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();  
  
app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">cors</span>({  
  <span class="hljs-attr">origin</span>: <span class="hljs-string">&#x27;http://frontend.example.com&#x27;</span>, <span class="hljs-comment">// 允许跨域的域名  </span>
  <span class="hljs-attr">credentials</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 允许携带Credentials  </span>
}));  
  
<span class="hljs-comment">// ... 其他中间件和路由 ...  </span>
  
app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> {  
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Server running on port 3000&#x27;</span>);  
});
</code></pre>
<h3 id="单点登录">单点登录</h3>
<p>单点登录（Single Sign-On，简称SSO）是一种在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统的技术。</p>
<ul>
<li>同域名：cookie父子域名实现单点登录，父域名的cookie子域名能查看到，但子域名的cookie父域名默认是不能查看到的。</li>
<li>不同域名：
<ul>
<li>临时token拼接在url传给子系统（相对复杂，支持跨域，可扩展）</li>
<li>主要前端去实现：使用Window.postMessage和iframe，给别的域传入信息</li>
</ul>
</li>
</ul>
<pre><code class="language-js"><span class="hljs-comment">// token</span>
<span class="hljs-keyword">var</span> token = result.<span class="hljs-property">data</span>.<span class="hljs-property">token</span>;
<span class="hljs-comment">// iframe iframe HTML</span>
<span class="hljs-keyword">var</span> iframe = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;iframe&quot;</span>);
iframe.<span class="hljs-property">src</span> = <span class="hljs-string">&quot;http://app1.com/localstorage.html&quot;</span>;
<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">append</span>(iframe);
<span class="hljs-comment">// postMessage() token iframe</span>
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
 iframe.<span class="hljs-property">contentWindow</span>.<span class="hljs-title function_">postMessage</span>(token, <span class="hljs-string">&quot;http://app1.com&quot;</span>);
}, <span class="hljs-number">4000</span>);
<span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
 iframe.<span class="hljs-title function_">remove</span>();
}, <span class="hljs-number">6000</span>);
<span class="hljs-comment">// iframe HTML token</span>
<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) {
 <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;token&#x27;</span>, event.<span class="hljs-property">data</span>)
}, <span class="hljs-literal">false</span>);
</code></pre>
<h3 id="跨域">跨域</h3>
<p>跨域本质是浏览器基于同源策略的一种安全手段,端口域名协议一个不相同即为跨域.</p>
<p>一定要注意跨域是浏览器的限制，用抓包工具抓取接口数据，是可以看到接口已经把数据返回回来了，只是浏览器的限制，我们获取不到数据。</p>
<h4 id="解决方案">解决方案</h4>
<ul>
<li>jsonp</li>
<li>websocket</li>
<li>跨域资源共享</li>
<li>nginx反向代理(Proxy方案1)</li>
<li>本地服务器代理-webpack/vite(Proxy方案2)</li>
<li>服务端代理转发(Proxy方案3)</li>
<li>postMessage+iframe(不灵活，适合做些单点登录，传递信息之类的小技巧之类的)</li>
<li>document.domain + iframe跨域（只适合有共有的主域名情况）</li>
</ul>
<pre><code class="language-js"><span class="hljs-comment">// Access-Control-Allow-Origin</span>
app.<span class="hljs-title function_">use</span>(<span class="hljs-keyword">async</span> (ctx, next)=&gt; {
  ctx.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>);
  ctx.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="hljs-string">&#x27;Content-Type, Content-Length, Authorization, Accept, X-Requested-With , yourHeaderFeild&#x27;</span>);
  ctx.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Methods&#x27;</span>, <span class="hljs-string">&#x27;PUT, POST, GET, DELETE, OPTIONS&#x27;</span>);
  <span class="hljs-keyword">if</span> (ctx.<span class="hljs-property">method</span> == <span class="hljs-string">&#x27;OPTIONS&#x27;</span>) {
    ctx.<span class="hljs-property">body</span> = <span class="hljs-number">200</span>; 
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>();
  }
})
</code></pre>
<p>代理（Proxy）也称网络代理，是一种特殊的网络服务，允许一个（一般为客户端）通过这个服务与另一个网络终端（一般为服务器）进行非直接的连接。一些网关、路由器等网络设备具备网络代理功能。一般认为代理服务有利于保障网络终端的隐私或安全，防止攻击</p>
<pre><code class="language-js"><span class="hljs-comment">// 服务端代理转发</span>
<span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);
<span class="hljs-keyword">const</span> proxy = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http-proxy-middleware&#x27;</span>)
<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>()
app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">static</span>(__dirname + <span class="hljs-string">&#x27;/&#x27;</span>))
app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/api&#x27;</span>, <span class="hljs-title function_">proxy</span>({ <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://localhost:4000&#x27;</span>, <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">false</span>
                      }));
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = app
</code></pre>
<p>postMessage实现AB跨域页面通信，但是不推荐使用window.open，浏览器可能存在拦截等行为，使用iframe+postMessage</p>
<pre><code class="language-bash">otherWindow.postMessage(message, targetOrigin, [transfer]);
</code></pre>
<pre><code class="language-html"><span class="hljs-comment">&lt;!-- A页面 --&gt;</span>
<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span> /&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;openHtml()&quot;</span>&gt;</span>打开B页面<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;send()&quot;</span>&gt;</span>发送消息<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">
		<span class="hljs-keyword">var</span> win1,win2 ;
	    <span class="hljs-keyword">function</span> <span class="hljs-title function_">send</span>(<span class="hljs-params"></span>){
			<span class="hljs-comment">// 可以配置具体允许哪个端口去获取信息</span>
			<span class="hljs-comment">// 如http://127.0.0.1:5501</span>
	    	<span class="hljs-comment">// win1.postMessage(&quot;hide&quot;,&#x27;*&#x27;);</span>
			win2.<span class="hljs-title function_">postMessage</span>(<span class="hljs-string">&quot;hide&quot;</span>,<span class="hljs-string">&#x27;*&#x27;</span>);
	    }
		
		<span class="hljs-keyword">function</span> <span class="hljs-title function_">openHtml</span>(<span class="hljs-params"></span>){
			<span class="hljs-comment">// 可以跨域场景，也可以同源页面</span>
			<span class="hljs-comment">// win1 = window.open(&quot;http://127.0.0.1:8848/code/index.html&quot;)</span>
			win2 = <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;http://127.0.0.1:7000/index.html&quot;</span>)
		}
	</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<pre><code class="language-html"><span class="hljs-comment">&lt;!-- B页面 --&gt;</span>
<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
		
	<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">
		<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>){
		    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">data</span>);
		},<span class="hljs-literal">false</span>);
	</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>

</code></pre>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>父页面<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
<span class="hljs-comment">&lt;!-- &lt;iframe id=&quot;iframe&quot; src=&quot;http://127.0.0.1:8848/word/demo1/index2.html&quot;&gt;&lt;/iframe&gt; --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;iframe&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./index2.html&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">
	<span class="hljs-keyword">const</span> iFrame = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;iframe&#x27;</span>)
	<span class="hljs-comment">//需要等到iframe中的子页面加载完成后才发送消息，否则子页面接收不到消息</span>
	iFrame.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){
	  <span class="hljs-comment">// &lt;!-- iFrame.contentWindow获取到iframe的window对象 --&gt;</span>
	  iFrame.<span class="hljs-property">contentWindow</span>.<span class="hljs-title function_">postMessage</span>(<span class="hljs-string">&#x27;父页面发送的消息&#x27;</span>,<span class="hljs-string">&#x27;*&#x27;</span>);
	  <span class="hljs-comment">// 这里可做限制，限制范围</span>
	}
	
	
	<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>,<span class="hljs-function"><span class="hljs-params">e</span>=&gt;</span>{
	    <span class="hljs-comment">//&lt;!-- 对消息来源origin做一下过滤，避免接收到非法域名的消息导致的xss攻击 --&gt;</span>
	    <span class="hljs-comment">// if(e.origin===&#x27;&#x27;){</span>
			<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(e)
	        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">origin</span>) <span class="hljs-comment">//子页面URL，这里是http://b.index.com</span>
	        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">source</span>) <span class="hljs-comment">// 子页面window对象，全等于iframe.contentWindow</span>
	        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">data</span>) <span class="hljs-comment">//子页面发送的消息</span>
	    <span class="hljs-comment">// }</span>
	},<span class="hljs-literal">false</span>)
	
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;child&#x27;</span>&gt;</span>child<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">
	<span class="hljs-comment">// 有发送就有接收，与postMessage配套使用的就是message事件</span>
	<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>,<span class="hljs-function"><span class="hljs-params">e</span>=&gt;</span>{
	    <span class="hljs-comment">//&lt;!-- 对消息来源origin做一下过滤，避免接收到非法域名的消息导致的xss攻击 --&gt;</span>
	    <span class="hljs-comment">// if(e.origin===&#x27;http://a.index.com&#x27;){</span>
	        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">origin</span>) <span class="hljs-comment">//父页面URL，这里是http://a.index.com</span>
	        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">source</span>) <span class="hljs-comment">// 父页面window对象，全等于window.parent/window.top</span>
	        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">data</span>)  <span class="hljs-comment">//父页面发送的消息</span>
	    <span class="hljs-comment">// }</span>
	},<span class="hljs-literal">false</span>)
	
	<span class="hljs-keyword">const</span> child =<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;child&#x27;</span>)
	child.<span class="hljs-property">onclick</span> =<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){
		<span class="hljs-variable language_">window</span>.<span class="hljs-property">parent</span>.<span class="hljs-title function_">postMessage</span>(<span class="hljs-string">&#x27;子页面发送的消息&#x27;</span>,<span class="hljs-string">&#x27;*&#x27;</span>)
	}
	
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p><img src="file:///e:\studying\book_files\50.jpg" alt="postMessage"></p>
<h3 id="web端常见的攻击方式">web端常见的攻击方式</h3>
<ul>
<li>跨站脚本攻击（XSS攻击），攻击者利用Web应用未对用户提交的数据进行过滤或转义的漏洞，向网页中注入恶意脚本代码。（xss两大要素：攻击者输入恶意代码，浏览器执行恶意代码）前端校验只能解决输入的，如果绕开前端请求，直接构造请求就需要额外处理了。
<ul>
<li>存储型：存储在数据库【论坛 私信】</li>
<li>反射型：存在url中【网站跳转 搜索】</li>
<li>DOM型：有浏览器端完成</li>
</ul>
</li>
<li>跨站请求伪造（CSRF攻击），<code>攻击者诱导受害者进入第三方网站，该网站向被攻击网站发送跨站请求。</code>由于请求携带了受害者的合法cookie，因此验证通过，攻击得以完成。</li>
<li>SQL注入攻击</li>
</ul>
<pre><code>XSRF流程
受害者登录一个受信任的网站A，并在本地生成Cookie。
在不登出网站A的情况下，受害者访问一个危险的网站B。
攻击者在网站B上设置一些恶意的代码或链接，诱导受害者点击或执行。
当受害者执行这些恶意操作时，他们的浏览器会携带网站A的Cookie向网站A发送请求。
网站A接收到请求后，由于Cookie是有效的，因此会误以为是用户自己发送的请求，并执行相应的操作。
</code></pre>
<p>为了防范CSRF攻击，可以采取以下措施：</p>
<ul>
<li>验证请求的来源：服务器在接收到请求时，可以检查请求的来源是否合法，即是否来自受信任的域名。</li>
<li>使用验证码：对于关键操作，可以要求用户输入验证码，以确保操作是由用户本人执行的。</li>
<li>设置Token：服务器在用户登录后生成一个随机的Token，并将其保存在用户的Session中。在后续请求中，要求客户端携带这个Token。由于Token是随机的，攻击者很难伪造。</li>
<li>避免在URL中传递敏感信息：敏感信息应该通过POST请求传递，而不是通过URL的查询参数。</li>
<li>实施安全的Cookie策略：设置HttpOnly属性，防止JavaScript访问Cookie；设置Secure属性，确保Cookie只能通过HTTPS传输。</li>
</ul>
<h3 id="如何捕获js异常">如何捕获js异常</h3>
<p>重点代码try…catch…</p>
<p>全局还可以使用window.onerror进行检测，压缩后的代码需要配合sourceMap找出对应的行列（对第三方库的定位不会太准确）</p>
<h3 id="js计算精度丢失问题">js计算精度丢失问题</h3>
<pre><code class="language-js"><span class="hljs-number">0.1</span>+<span class="hljs-number">0.2</span>=== <span class="hljs-number">0.3</span> <span class="hljs-literal">false</span> 
</code></pre>
<pre><code class="language-js"><span class="hljs-number">1</span>/<span class="hljs-number">3</span>=<span class="hljs-number">0.3333</span>...
</code></pre>
<p>可以有无限个3，但是计算机要存储，所以最后只能取<code>近似值</code>，当计算机存储后再取出就存在错误的可能。</p>
<p>对于整数，很容易转换成十进制或者二进制，而浮点数则不知道小数位数多少位，采取的是科学计数法。因为存储时有位数限制，某些十进制转二进制存在无限循环，二进制会采取舍入操作。</p>
<p>解决思路：转成整数</p>
<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">num1, num2</span>) {
 <span class="hljs-keyword">const</span> num1Digits = (num1.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;.&#x27;</span>)[<span class="hljs-number">1</span>] || <span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-property">length</span>;
 <span class="hljs-keyword">const</span> num2Digits = (num2.<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;.&#x27;</span>)[<span class="hljs-number">1</span>] || <span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-property">length</span>;
 <span class="hljs-keyword">const</span> baseNum = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-number">10</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(num1Digits, num2Digits));
 <span class="hljs-keyword">return</span> (num1 * baseNum + num2 * baseNum) / baseNum;
}

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">0.1</span>,<span class="hljs-number">0.2</span>))
</code></pre>
<blockquote>
<p>Math.js BigDecimal.js</p>
</blockquote>
<h3 id="前端防护xss和xsrf攻击">前端防护xss和xsrf攻击</h3>
<p>【Cross Site Script】跨站脚本攻击 恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。可以直接安装xss对应插件。</p>
<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">escape</span>(<span class="hljs-params">str</span>) {
  str = str.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/&amp;/g</span>, <span class="hljs-string">&#x27;&amp;amp;&#x27;</span>)<span class="hljs-comment">// h5之后可以不做转义，且&amp;符号转义要放在第一个否则对其他的有干扰</span>
  str = str.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/&lt;/g</span>, <span class="hljs-string">&#x27;&amp;lt;&#x27;</span>)
  str = str.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/&gt;/g</span>, <span class="hljs-string">&#x27;&amp;gt;&#x27;</span>)
  str = str.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/&quot;/g</span>, <span class="hljs-string">&#x27;&amp;quto;&#x27;</span>)
  str = str.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/&#x27;/g</span>, <span class="hljs-string">&#x27;&amp;#39;&#x27;</span>)
  str = str.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/`/g</span>, <span class="hljs-string">&#x27;&amp;#96;&#x27;</span>)
  str = str.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\//g</span>, <span class="hljs-string">&#x27;&amp;#x2F;&#x27;</span>)
  str = str.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/ /g</span>, <span class="hljs-string">&#x27;&amp;#39;&#x27;</span>)
  <span class="hljs-keyword">return</span> str
}
<span class="hljs-built_in">escape</span>(<span class="hljs-string">&#x27;&lt;script&gt;alert(1)&lt;/script&gt;&#x27;</span>)
<span class="hljs-comment">//&amp;lt;script&amp;gt;alert(1)&amp;lt;&amp;#x2F;script&amp;gt;</span>
</code></pre>
<p>当 5 &lt; 7 作为 HTML 拼接页面时，可以正常显示：</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;comment&quot;</span>&gt;</span>5 <span class="hljs-symbol">&amp;lt;</span> 7<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p>当 5 &lt; 7 通过 Ajax 返回，然后赋值给 JavaScript 的变量时，前端得到的字符串就是转义后的字符。这个内容不能直接用于 Vue 等模板的展示，也不能直接用于内容长度计算。不能用于标题、alert 等
可以看到，过滤并非可靠的，下面就要通过防止浏览器执行恶意代码：</p>
<p>在使用 .innerHTML、.outerHTML、document.write() 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 .textContent、.setAttribute() 等</p>
<p>如果用 Vue/React 技术栈，并且不使用 v-html/dangerouslySetInnerHTML 功能，就在前端 render 阶段避免 innerHTML、outerHTML 的 XSS 隐患在使用 .innerHTML、.outerHTML、document.write() 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 .textContent、.setAttribute() 等</p>
<p>CSP: Content-Security-Policy 内容安全策略(白名单制度)</p>
<ul>
<li>设置 HTTP 的 Content-Security-Policy 头部字段</li>
<li>设置网页的<code>&lt;meta&gt;</code>标签。</li>
<li>form-action用来控制表单之类的，default-src用来控制其他的，如果需要放开某些白名单，需要写入在列表里</li>
<li>default-src会影响到img，要么也把img也配置上，要么如果只限制js的话可以吧<strong>default-src改为script-src</strong></li>
</ul>
<pre><code class="language-js">&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot;&gt;
        &lt;title&gt;&lt;/title&gt;
        &lt;!-- 前端页面上设置，加了jquery就访问不了了--&gt;
        &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;form-action &#x27;self&#x27;;default-src &#x27;self&#x27;;&quot;&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;script src=&quot;http://ajax.aspnetcdn.com/ajax/jQuery/jquery-2.1.1.min.js&quot;&gt;&lt;/script&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;
            console.log($)
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><img src="file:///e:\studying\book_files\66.jpg" alt="csp"></p>
<pre><code class="language-html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- 前端页面上设置，加了jquery就访问不了了--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Content-Security-Policy&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;form-action &#x27;self&#x27;;default-src &#x27;self&#x27; http://ajax.aspnetcdn.com/ajax/jQuery/jquery-2.1.1.min.js https://unpkg.com/vue@3/dist/vue.global.js;&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://ajax.aspnetcdn.com/ajax/jQuery/jquery-2.1.1.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript">
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>($)
        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<p><img src="file:///e:\studying\book_files\67.jpg" alt="加载成功"></p>
<p>XSRF攻击：【Cross Site Request Forgery】跨站点伪造请求</p>
<p>通过在访问用户被认为已经通过身份验证的Web应用程序的页面中包含恶意代码或链接来工作。</p>
<ol>
<li><strong>在请求地址中添加 token+(验证码) 并验证：限制从别的网址登录的可能</strong></li>
<li>在HTTP 头中自定义属性并验证</li>
<li>验证 HTTP Referer 字段 ( req.headers.referer )(不推荐，存在篡改和浏览器默认阻止)</li>
<li>Get 请求不对数据进行修改</li>
<li>不让第三方网站访问到用户 Cookie =&gt;后台cookie配置设置 same-site 属性进行控制</li>
<li>CORS是否必要[JSONP]，是否兼容老浏览器</li>
</ol>
<h2 id="es6">ES6</h2>
<h3 id="扩展运算符-剩余运算符">扩展运算符 剩余运算符</h3>
<ul>
<li>扩展运算符用三个点（...）表示，它可以用于将一个数组或对象的所有元素/属性<strong>展开</strong>到新的数组或对象中。<code>可实现浅拷贝</code></li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">const</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];  
<span class="hljs-keyword">const</span> arr2 = [...arr1, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]; <span class="hljs-comment">// [1, 2, 3, 4, 5]</span>
</code></pre>
<ul>
<li>剩余运算符也用三个点（...）表示，但它用于将数组或对象的剩余元素/属性收集到一个新的变量中。</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">a, b, ...rest</span>) {  
  <span class="hljs-keyword">let</span> total = a + b;  
  rest.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> total += num);  
  <span class="hljs-keyword">return</span> total;  
}  
  
<span class="hljs-title function_">sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">// 返回 15</span>
</code></pre>
<h3 id="数组的静态方法">数组的静态方法</h3>
<ul>
<li>Array.isArray(obj):检测是否是数组</li>
<li>Array.from(arrayLike[, mapFunction[, thisArg]])
<ul>
<li>从一个<code>类数组</code>或<code>可迭代</code>的对象创建一个新的数组实例</li>
<li>可以提供一个映射函数作为第二个参数来转换每个元素</li>
</ul>
</li>
<li>Array.of(...items):创建一个具有可变数量参数的新数组实例，不论参数数量或类型。</li>
<li>Array.prototype.slice():可以静态地通过 Array.prototype.slice.call(arrayLike) 的形式使用，将<code>类数组对象</code>或可迭代对象转换为真正的数组。</li>
</ul>
<h4 id="创建数组的方法">创建数组的方法</h4>
<ol>
<li>Array.of</li>
<li>new Array</li>
<li>arr=[]确定length</li>
</ol>
<pre><code class="language-js"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">of</span>(<span class="hljs-number">7</span>)) <span class="hljs-comment">//[7]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">of</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>))<span class="hljs-comment">//[1,2,3]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Array</span>(<span class="hljs-number">7</span>))<span class="hljs-comment">//[,,,,,,,]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>))[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]

<span class="hljs-keyword">let</span> arr = []
arr.<span class="hljs-property">length</span> =<span class="hljs-number">10</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr) <span class="hljs-comment">//[empty*10]</span>
</code></pre>
<h3 id="set和map的应用">Set和Map的应用</h3>
<p>Set是一种叫做集合的数据结构，而Map是一种叫做字典的数据结构。</p>
<ul>
<li>
<p>集合：一堆无需相关联，且不重复的内存结构组成的组合</p>
</li>
<li>
<p>字典：一些元素的集合，每个元素有一个称做key的域，不同元素的key各不相同</p>
</li>
<li>
<p>Set的方法</p>
<ul>
<li>add</li>
<li>delete：返回布尔值</li>
<li>has</li>
<li>clear</li>
<li>keys() values() entries()</li>
<li>forEach</li>
</ul>
</li>
<li>
<p>set的应用场景</p>
</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);
<span class="hljs-keyword">let</span> b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>]);
<span class="hljs-comment">// 并集</span>
<span class="hljs-keyword">let</span> union = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([...a, ...b]);
<span class="hljs-comment">// Set {1, 2, 3, 4}</span>
<span class="hljs-comment">// 交集</span>
<span class="hljs-keyword">let</span> intersect = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([...a].<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> b.<span class="hljs-title function_">has</span>(x)));
<span class="hljs-comment">// set {2, 3}</span>
<span class="hljs-comment">// a相对于b的差集</span>
<span class="hljs-keyword">let</span> difference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([...a].<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> !b.<span class="hljs-title function_">has</span>(x)));
<span class="hljs-comment">// Set {1}</span>
</code></pre>
<ul>
<li>Map的方法
<ul>
<li>size</li>
<li>set</li>
<li>get</li>
<li>has</li>
<li>delete：返回布尔值</li>
<li>clear</li>
</ul>
</li>
</ul>
<h4 id="weakset-weakmap">weakSet weakMap</h4>
<ul>
<li>weakSet的成员只能使用引用对象</li>
<li>weakMap的key也只能是引用对象，二者都没size属性和forEach，无法遍历</li>
<li>外面的引用消失，二者里面的引用也会自动消失</li>
</ul>
<pre><code class="language-js"><span class="hljs-comment">// 非引用变量</span>
<span class="hljs-keyword">let</span> ws=<span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakSet</span>();
<span class="hljs-keyword">let</span> weakSet=<span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakSet</span>([<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(weakSet) <span class="hljs-comment">// error</span>

<span class="hljs-comment">// 成员为引用变量</span>
<span class="hljs-keyword">let</span> obj1={<span class="hljs-attr">name</span>:<span class="hljs-number">1</span>}
<span class="hljs-keyword">let</span> obj2={<span class="hljs-attr">name</span>:<span class="hljs-number">1</span>}
<span class="hljs-keyword">let</span> ws=<span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakSet</span>([obj1,obj2]);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ws) <span class="hljs-comment">//WeakSet {{…}, {…}}</span>
</code></pre>
<p>应用场景：处理dom</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> wm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();
<span class="hljs-keyword">const</span> element = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;example&#x27;</span>);
wm.<span class="hljs-title function_">set</span>(element, <span class="hljs-string">&#x27;some information&#x27;</span>);
wm.<span class="hljs-title function_">get</span>(element) <span class="hljs-comment">// &quot;some information&quot;</span>
</code></pre>
<h3 id="decorator应用场景">Decorator应用场景</h3>
<p>装饰器，其本质就是一个普通的函数，用于扩展类属性和类方法。（装饰器模式）</p>
<ul>
<li>代码可读性更强，装饰器命名相当于一个注释</li>
<li>在不改变原有代码情况下，对原有的功能进行扩展</li>
<li>可以添加在类上，也可以添加在类的属性方法上</li>
<li>decorator 就是一个普通函数，只不过它接收 3 个参数，与 Object.defineProperty 一致。</li>
<li>作用在方法上的 decorator 接收的第一个参数（ target ）是<strong>类的 prototype</strong>；如果把一个 decorator 作用到类上，则它的第一个参数 target 是<strong>类本身</strong></li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> {
  @readonly
  bark () {
    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;wang!wang!&#x27;</span>
  }
}

<span class="hljs-keyword">let</span> dog = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>()
dog.<span class="hljs-property">bark</span> = <span class="hljs-string">&#x27;bark!bark!&#x27;</span>
<span class="hljs-comment">// Cannot assign to read only property &#x27;bark&#x27; of [object Object]</span>
<span class="hljs-comment">// &lt;=====&gt;</span>
<span class="hljs-comment">// 步骤 1</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Dog</span> () {}

<span class="hljs-comment">// 步骤 2</span>
<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-title class_">Dog</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">&#x27;bark&#x27;</span>, {
  <span class="hljs-attr">value</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) { <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;wang!wang!&#x27;</span> },
  <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span>,
  <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>
})
</code></pre>
<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doge</span> (isDoge) {
  <span class="hljs-comment">// 不传参</span>
  <span class="hljs-comment">// target.isDoge = true</span>
  
  <span class="hljs-comment">//传参</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">target</span>) {
    target.<span class="hljs-property">isDoge</span> = isDoge
  }
}

@<span class="hljs-title function_">doge</span>(<span class="hljs-literal">true</span>)
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> {}

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Dog</span>.<span class="hljs-property">isDoge</span>)
<span class="hljs-comment">// true</span>
</code></pre>
<p>作用在类属性方法上亦可以这样</p>
<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">enumerable</span> (isEnumerable) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">target, key, descriptor</span>) {
    descriptor.<span class="hljs-property">enumerable</span> = isEnumerable
  }
}

<span class="hljs-comment">// 属性方法上不建议直接改target，因为是类的原型，影响所有的</span>
<span class="hljs-comment">// function enumerable (target, key, descriptor){</span>
<span class="hljs-comment">// 	descriptor.enumerable  =true</span>
<span class="hljs-comment">// }</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> {
  @<span class="hljs-title function_">enumerable</span>(<span class="hljs-literal">false</span>)
  eat () { }
}

</code></pre>
<p>多个装饰器时，类似洋葱圈模式，先从外到内，再有内到外</p>
<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">dec</span>(<span class="hljs-params">id</span>){
 <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;evaluated&#x27;</span>, id);
 <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">target, property, descriptor</span>) =&gt;</span><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;executed&#x27;</span>, id);
}
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> {
 @<span class="hljs-title function_">dec</span>(<span class="hljs-number">1</span>)
 @<span class="hljs-title function_">dec</span>(<span class="hljs-number">2</span>)
 <span class="hljs-title function_">method</span>(<span class="hljs-params"></span>){}
}
<span class="hljs-comment">// evaluated 1</span>
<span class="hljs-comment">// evaluated 2</span>
<span class="hljs-comment">// executed 2</span>
<span class="hljs-comment">// executed 1</span>
</code></pre>
<blockquote>
<p>应用场景：react-redux的connect，类的混入某些新属性或者修改属性</p>
</blockquote>
<h3 id="proxy的应用场景">Proxy的应用场景</h3>
<pre><code class="language-js"><span class="hljs-keyword">var</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler)
</code></pre>
<pre><code class="language-js"><span class="hljs-keyword">var</span> person = {
 <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;aaa&quot;</span>
};
<span class="hljs-keyword">var</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(person, {
 <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">target, propKey</span>) {
 <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target,propKey)
 }
});
<span class="hljs-comment">// proxy.name </span>
</code></pre>
<p>取消代理</p>
<pre><code class="language-js"><span class="hljs-title class_">Proxy</span>.<span class="hljs-title function_">revocable</span>(target, handler);
</code></pre>
<p>应用场景</p>
<ul>
<li>拦截，监视外部对象访问</li>
<li>降低函数或类的复杂度</li>
<li>在复杂操作前对操作进行校验和所需资源进行管理</li>
<li>观察者模式</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">const</span> queuedObservers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();
<span class="hljs-keyword">const</span> <span class="hljs-title function_">observe</span> = fn =&gt; queuedObservers.<span class="hljs-title function_">add</span>(fn);
<span class="hljs-keyword">const</span> <span class="hljs-title function_">observable</span> = obj =&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, {set});
<span class="hljs-keyword">function</span> <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, value, receiver</span>) {
 <span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, key, value, receiver);
 queuedObservers.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">observer</span> =&gt;</span> <span class="hljs-title function_">observer</span>());
 <span class="hljs-keyword">return</span> result;
}
</code></pre>
<h3 id="es6中的module">ES6中的Module</h3>
<p>模块，是能够单独命名独立完成一定功能的程序语句的集合。</p>
<p>作用：代码抽象，封装，复用，依赖管理。</p>
<p>没有模块化，方法和变量不易维护，容易污染全局作用域。加载资源方式使用script从上往下，后期不容易维护。</p>
<ul>
<li>AMD(Asynchronous ModuleDefinition),异步模块定义，采用异步方式加载模块。所有依赖模块的语句，都定义在一个回调函数中，等到模块加载完之后，这个回调函数才会运行</li>
</ul>
<pre><code class="language-js"><span class="hljs-comment">// 以reqiure.js为例</span>
<span class="hljs-comment">/** main.js / **/</span>
<span class="hljs-comment">// config()</span>
<span class="hljs-built_in">require</span>.<span class="hljs-title function_">config</span>({
 <span class="hljs-attr">baseUrl</span>: <span class="hljs-string">&quot;js/lib&quot;</span>,
 <span class="hljs-attr">paths</span>: {
 <span class="hljs-string">&quot;jquery&quot;</span>: <span class="hljs-string">&quot;jquery.min&quot;</span>, <span class="hljs-comment">// js/lib/jquery.min.js</span>
 <span class="hljs-string">&quot;underscore&quot;</span>: <span class="hljs-string">&quot;underscore.min&quot;</span>,
 }
});
<span class="hljs-comment">//</span>
<span class="hljs-built_in">require</span>([<span class="hljs-string">&quot;jquery&quot;</span>,<span class="hljs-string">&quot;underscore&quot;</span>],<span class="hljs-keyword">function</span>(<span class="hljs-params">$,_</span>){
 <span class="hljs-comment">// some code here</span>
});
</code></pre>
<ul>
<li>ES Module设计思想静态化，使得<code>编译</code>时就能确定依赖关系，以及输入输出的变量，而commonjs和amd只有在运行时才能确定</li>
</ul>
<pre><code class="language-js"><span class="hljs-comment">// 只加载三个方法，其他方法不加载</span>
<span class="hljs-keyword">import</span> { stat, exists, readFile } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;fs&#x27;</span>;
</code></pre>
<pre><code class="language-js"><span class="hljs-comment">// CommonJS</span>
<span class="hljs-keyword">let</span> { stat, exists, readfile } = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);
<span class="hljs-comment">//</span>
<span class="hljs-keyword">let</span> _fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);
<span class="hljs-keyword">let</span> stat = _fs.<span class="hljs-property">stat</span>;
<span class="hljs-keyword">let</span> exists = _fs.<span class="hljs-property">exists</span>;
<span class="hljs-keyword">let</span> readfile = _fs.<span class="hljs-property">readfile</span>;
</code></pre>
<h3 id="map与object和-set与array的区别">Map与Object和 Set与Array的区别</h3>
<p>相对于对象，Map的key不仅是字符串，也可以使其他的，Map数据结构是有序的且Map的查询速度也是非常快的。</p>
<p>Set是无序的，且不能重复，如果不考虑顺序的场景，可以优选替代Array。</p>
<p>unshift速度很慢，需要调整位置</p>
<pre><code class="language-js"><span class="hljs-comment">// arr 有多慢？</span>
<span class="hljs-keyword">const</span> arr = []
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i  = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span> * <span class="hljs-number">10000</span>; i++) {
    arr.<span class="hljs-title function_">push</span>(i)
}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">&#x27;arr unshift&#x27;</span>)
arr.<span class="hljs-title function_">unshift</span>(<span class="hljs-string">&#x27;a&#x27;</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">&#x27;arr unshift&#x27;</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">&#x27;arr push&#x27;</span>)
arr.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;b&#x27;</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">&#x27;arr push&#x27;</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">&#x27;arr find&#x27;</span>)
arr.<span class="hljs-title function_">includes</span>(<span class="hljs-number">500000</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">&#x27;arr find&#x27;</span>)

<span class="hljs-comment">// set 有多快？</span>
<span class="hljs-keyword">const</span> set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i  = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span> * <span class="hljs-number">10000</span>; i++) {
    set.<span class="hljs-title function_">add</span>(i)
}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">&#x27;set add&#x27;</span>)
set.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;a&#x27;</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">&#x27;set add&#x27;</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">&#x27;set find&#x27;</span>)
set.<span class="hljs-title function_">has</span>(<span class="hljs-number">500000</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">&#x27;set find&#x27;</span>)
</code></pre>
<p><img src="file:///e:\studying\book_files\71.jpg" alt="arr"></p>
<h2 id="vue2">Vue2</h2>
<h3 id="vue-生命周期">Vue 生命周期</h3>
<p>Vue生命周期是指Vue实例对象从创建开始到销毁的过程。</p>
<p><img src="file:///e:\studying\book_files\58.jpg" alt="生命周期"></p>
<h4 id="mounted-created-请求数据">mounted created 请求数据</h4>
<ul>
<li>如果不涉及到操作dom，created时机更早更好</li>
<li>如果mounted有对dom处理，那需放在mounted处理</li>
</ul>
<h3 id="数据双向绑定">数据双向绑定</h3>
<p>模型Model的变动会改变视图View,View变动会影响Model</p>
<p><img src="file:///e:\studying\book_files\60.jpg" alt="1">
<img src="file:///e:\studying\book_files\61.jpg" alt="2"></p>
<h3 id="vue双向绑定的原理">Vue双向绑定的原理</h3>
<p><img src="file:///e:\studying\book_files\59.jpg" alt="数据双向绑定"></p>
<ul>
<li>Model  代表数据模型，数据和业务逻辑都在Model层中定义；</li>
<li>View 视图层 代表UI视图，负责数据的展示；</li>
<li>ViewModel  负责监听 Model 中数据的改变并且控制视图的更新，处理用户交互操作； Model 和 View 并无直接关联，而是通过 ViewModel 来进行联系的，Model 和 ViewModel 之间有着双向数据绑定的联系。因此当 Model 中的数据改变时会触发 View 层的刷新，View 中由于用户交互操作而改变的数据也会在 Model 中同步。</li>
</ul>
<p><img src="file:///e:\studying\book_files\62.jpg" alt="vue基本实现方式">
<img src="file:///e:\studying\book_files\63.jpg" alt="对应关系"></p>
<h3 id="vue组件通信方式">Vue组件通信方式</h3>
<ol>
<li>props 和 $emit</li>
<li>ref</li>
<li>EventBus</li>
<li>parent root children</li>
<li>attrs 和listeners</li>
<li>Provide 和 Inject</li>
<li>Vuex</li>
</ol>
<p>$root</p>
<pre><code class="language-js"><span class="hljs-comment">// 根组件</span>
<span class="hljs-comment">// this等于this$root </span>

<span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({
  <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">App</span>),
  <span class="hljs-attr">methods</span>: {  
    <span class="hljs-attr">showAlert</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {  
      <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Message from root method!&#x27;</span>);  
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">$root</span>.$emit(<span class="hljs-string">&#x27;myname&#x27;</span>)
    }  
  }  
}).$mount(<span class="hljs-string">&#x27;#app&#x27;</span>)
</code></pre>
<pre><code class="language-html">// 后代组件可以触发根组件的方法
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;$root.showAlert()&quot;</span>&gt;</span>Call root method<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>  
</code></pre>
<pre><code class="language-js"><span class="hljs-comment">// 也可以监听或者派发事件，在其他的组件中可以监听接受到派发事件</span>
  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
    <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>){
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$root</span>)
     
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">$root</span>.$on(<span class="hljs-string">&#x27;myname&#x27;</span>,<span class="hljs-function">()=&gt;</span>{
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;后代组件监听&#x27;</span>)
      })
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">$root</span>.$on(<span class="hljs-string">&#x27;app&#x27;</span>,<span class="hljs-function">()=&gt;</span>{
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;apppp&#x27;</span>)
      })
    },
    <span class="hljs-attr">methods</span>:{
        <span class="hljs-title function_">childFun</span>(<span class="hljs-params"></span>){
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$root</span>)
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">$root</span>.$emit(<span class="hljs-string">&#x27;kkk&#x27;</span>,<span class="hljs-number">1000</span>)
        }
    }
  }
</code></pre>
<p>provide 和inject</p>
<pre><code class="language-js">  <span class="hljs-title function_">provide</span>(<span class="hljs-params"></span>) {   
    <span class="hljs-keyword">return</span>{
      <span class="hljs-attr">for1</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">k</span>,
      <span class="hljs-attr">arr</span>:<span class="hljs-variable language_">this</span>.<span class="hljs-property">arr</span>,
      <span class="hljs-attr">test</span>:<span class="hljs-variable language_">this</span>.<span class="hljs-property">test</span>
    }   <span class="hljs-comment">//重要一步，在父组件中注入一个变量</span>
  },
  <span class="hljs-attr">methods</span>:{
    <span class="hljs-title function_">changeF</span>(<span class="hljs-params"></span>){
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">k</span> =<span class="hljs-number">1000</span> <span class="hljs-comment">//简单类型后代组件不会随之改变</span>
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">arr</span>=[<span class="hljs-number">2</span>] <span class="hljs-comment">// 直接重新给值不会</span>
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">test</span>.<span class="hljs-property">f</span>=<span class="hljs-number">30</span> <span class="hljs-comment">//只修改对应属性后代组件可以改变</span>
    }
  }
</code></pre>
<pre><code class="language-js"><span class="hljs-comment">//</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Bus</span> {
 <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
	<span class="hljs-variable language_">this</span>.<span class="hljs-property">callbacks</span> = {}; <span class="hljs-comment">//</span>
 }
 $on(name, fn) {
	<span class="hljs-variable language_">this</span>.<span class="hljs-property">callbacks</span>[name] = <span class="hljs-variable language_">this</span>.<span class="hljs-property">callbacks</span>[name] || [];
	<span class="hljs-variable language_">this</span>.<span class="hljs-property">callbacks</span>[name].<span class="hljs-title function_">push</span>(fn);
 }
 $emit(name, args) {
	<span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">callbacks</span>[name]) {
	<span class="hljs-variable language_">this</span>.<span class="hljs-property">callbacks</span>[name].<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">cb</span>) =&gt;</span> <span class="hljs-title function_">cb</span>(args));
 }
 }
}

<span class="hljs-comment">// main.js</span>
<span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$bus</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bus</span>() <span class="hljs-comment">//方案1 自己写bus</span>
<span class="hljs-comment">//</span>
<span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$bus</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>() <span class="hljs-comment">//方案2 Vue2自身支持</span>
</code></pre>
<pre><code class="language-html">// child props foo
<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{$attrs.foo}}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

// parent
<span class="hljs-tag">&lt;<span class="hljs-name">HelloWorld</span> <span class="hljs-attr">foo</span>=<span class="hljs-string">&quot;foo&quot;</span>/&gt;</span>
</code></pre>
<p>组件通过 Child2 间接地与 Grandson 组件通信，传递属性和监听事件，而 Child2 组件仅作为属性和事件的“中继站”。这种模式在构建大型 Vue.js 应用程序时非常有用，因为它允许你构建可重用的组件，同时保持组件之间的解耦。</p>
<pre><code class="language-html">// Grandson communication/index.vue 祖辈
<span class="hljs-tag">&lt;<span class="hljs-name">Child2</span> <span class="hljs-attr">msg</span>=<span class="hljs-string">&quot;lalala&quot;</span> @<span class="hljs-attr">some-event</span>=<span class="hljs-string">&quot;onSomeEvent&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Child2</span>&gt;</span>

// Child2 父辈
<span class="hljs-tag">&lt;<span class="hljs-name">Grandson</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">&quot;$attrs&quot;</span> <span class="hljs-attr">v-on</span>=<span class="hljs-string">&quot;$listeners&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Grandson</span>&gt;</span>

v-bind=&quot;$attrs&quot;：这个指令将父组件传递给 Child2 的所有`未被 Child2 组件显式声明的属性`（props）`向下传递`给 Grandson 组件。在这个例子中，msg 属性就是这样被传递的。

v-on=&quot;$listeners&quot;：这个指令将父组件（即 Grandson communication/index.vue）监听的所有事件监听器传递给 `Grandson 组件`。这意味着 some-event 事件监听器也会被传递给 Grandson 组件。


// Grandson
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;$emit(&#x27;some-event&#x27;, &#x27;msg from grandson&#x27;)&quot;</span>&gt;</span>
	{{msg}}
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<pre><code class="language-js"><span class="hljs-comment">// 一个组件监听</span>
<span class="hljs-variable language_">this</span>.<span class="hljs-property">$parent</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;add&#x27;</span>,<span class="hljs-variable language_">this</span>.<span class="hljs-property">add</span>)
<span class="hljs-comment">// 另一个组件发出自定义事件</span>
<span class="hljs-variable language_">this</span>.<span class="hljs-property">$parent</span>.<span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;add&#x27;</span>)
</code></pre>
<h3 id="data的写法是函数不是对象的原因">data的写法是函数不是对象的原因</h3>
<ul>
<li>如果根实例对象，data可以使函数也可以是对象</li>
<li>如果是组件实例对象，则必须是函数，目的是为了防止公用data会造成数据污染，使用函数返回一个全新的data对象</li>
</ul>
<h3 id="vue直接给对象添加属性的问题">vue直接给对象添加属性的问题</h3>
<p>vue2的响应式依赖Object.defineProperty去添加依赖收集触发，但是这个操作是在编译模板时已经触发了，现在手动添加，无法感知到，所以vue2提供了Vue.set()方法，去再次触发收集依赖。</p>
<h3 id="v-if和v-for的优先级">v-if和v-for的优先级</h3>
<p>vue2中通过编译后发现，v-for的优先级高于v-if，vue3中v-if高于v-for，但是不建议v-if和v-for放在一个层级.</p>
<p>如果是items这个数据内部某些值不展示，则可以考虑借助computed去过滤掉</p>
<pre><code class="language-js">&lt;template v-<span class="hljs-keyword">if</span>=<span class="hljs-string">&quot;isShow&quot;</span>&gt;
 <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in items&quot;</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>
</code></pre>
<pre><code class="language-js"><span class="hljs-attr">computed</span>: {
 <span class="hljs-attr">items</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
	 <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) {
		<span class="hljs-keyword">return</span> item.<span class="hljs-property">isShow</span>
	})
 }
}
</code></pre>
<h3 id="计算属性computed和methods的区别">计算属性computed和methods的区别</h3>
<p><img src="file:///e:\studying\book_files\82.jpg" alt="1">
计算属性会基于它们的依赖关系进行<strong>缓存</strong>，提高性能；只有依赖的数据发生变化，计算属性才会重新进行计算。</p>
<h3 id="v-show-v-if的应用场景">v-show v-if的应用场景</h3>
<ol>
<li>都是从页面移除元素，v-show的原理是display:none，成为游离页面还可再用，v-if则是直接删除。</li>
<li>频繁切换用v-show</li>
<li>v-show的切换只是css的变化，v-if切换会触发生命周期(true:beforeCreated=&gt;...=&gt;mounted,false:beforeDestory=&gt;destoryed),事件监听器和子组件也会适当的销毁和重建</li>
</ol>
<h3 id="vue中key的原理">vue中key的原理</h3>
<p>key是每一个vnode的唯一id，是diff的一种优化侧率，根据key，可以更准确更快找到对应的vnode节点</p>
<p><img src="file:///e:\studying\book_files\64.jpg" alt="key1">
<img src="file:///e:\studying\book_files\65.jpg" alt="key2"></p>
<h3 id="vueextend-和-vuecomponent">Vue.extend 和 Vue.component</h3>
<p>Vue.extend() 是 Vue.js 中的一个全局 API，它用于创建一个“子类”或“扩展”的 Vue 构造器。这个扩展的构造器可以用来创建可复用的组件构造器，这些构造器可以用来创建新的 Vue 组件实例。</p>
<p>在某些情况下，可能需要动态地创建组件实例，或者需要一种更底层的、编程式的方式来创建组件，这时 Vue.extend() 就非常有用。</p>
<pre><code class="language-js"><span class="hljs-comment">// 创建一个扩展的 Vue 构造器  </span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">MyComponent</span> = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">extend</span>({  
  <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;div&gt;这是一个通过 Vue.extend 创建的组件&lt;/div&gt;&#x27;</span>  
});  
  
<span class="hljs-comment">// 使用这个扩展的构造器来创建组件实例  </span>
<span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyComponent</span>().$mount();  
  
<span class="hljs-comment">// 假设你有一个 DOM 元素，你可以将组件挂载到这个元素上  </span>
<span class="hljs-comment">// document.body.appendChild(instance.$el);  </span>
  
<span class="hljs-comment">// 在实际开发中，你通常不会直接这样做，而是将这个扩展的构造器注册为全局或局部组件  </span>
<span class="hljs-comment">// 并在模板中使用它</span>
</code></pre>
<p>Vue.component：在内部，它实际上也调用了 Vue.extend 来创建一个构造器，但随后它还进行了组件的注册和命名等额外操作。因此，你可以将 Vue.component 看作是 Vue.extend 和组件注册的结合体。</p>
<h3 id="vue中mixin的理解和应用场景">vue中mixin的理解和应用场景</h3>
<p>Mixin是面向对象程序设计语言中的类，提供了方法实现。其他类可以访问mixin类的方法而不必成为其子类。</p>
<p>Mixin类通常作为功能模块使用，在需要该功能时“混入”，有利于代码复用有避免多继承的复杂。</p>
<p>Vue的mixin本质就是一个js对象，包括data，components，methods，created等</p>
<pre><code class="language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">initMixin</span> (<span class="hljs-title class_">Vue</span>: <span class="hljs-title class_">GlobalAPI</span>) {
 <span class="hljs-title class_">Vue</span>.<span class="hljs-property">mixin</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">mixin: <span class="hljs-built_in">Object</span></span>) {
 <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span> = <span class="hljs-title function_">mergeOptions</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>, mixin)
 <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>
 }
}
</code></pre>
<pre><code class="language-js"><span class="hljs-keyword">var</span> myMixin = {
 <span class="hljs-attr">created</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
	<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">hello</span>()
 },
 <span class="hljs-attr">methods</span>: {
	<span class="hljs-attr">hello</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
		<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello from mixin!&#x27;</span>)
	}
 }
}
<span class="hljs-comment">// 局部混入</span>
<span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;componentA&#x27;</span>,{
 <span class="hljs-attr">mixins</span>: [myMixin]
})
</code></pre>
<blockquote>
<p>全局混入可能对第三方插件也有影响，一般用于插件的编写</p>
</blockquote>
<pre><code class="language-js"><span class="hljs-comment">//全局混入</span>
<span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">mixin</span>({
 <span class="hljs-attr">created</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot; &quot;</span>)
 }
})
</code></pre>
<h4 id="mixin注意事项">mixin注意事项</h4>
<ul>
<li>组件 data, methods，computed等 优先级高于 mixin data, methods,computed... 优先级(存在相同的组件覆盖混入)</li>
<li>生命周期函数，先执行 mixin 里面的，再执行组件里面的(数组形式，都会执行)</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">const</span> toggle = {
    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) {
		<span class="hljs-keyword">return</span> {
		 <span class="hljs-attr">isShowing</span>: <span class="hljs-literal">false</span>,
		 <span class="hljs-attr">test</span>:{
			<span class="hljs-attr">go</span>:<span class="hljs-string">&#x27;20&#x27;</span>,
			<span class="hljs-attr">f</span>:<span class="hljs-number">10000</span>
		 }
		}
    }
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> toggle
</code></pre>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>
   {{test}}
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">
<span class="hljs-keyword">import</span> toggle <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./view-01/mixin.js&#x27;</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;App&#x27;</span>,
  <span class="hljs-attr">mixins</span>:[toggle],
  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>){
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">test</span>:{
        <span class="hljs-attr">f</span>:<span class="hljs-number">120</span>
      }
    }
  }
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p>Mixins 在 Vue.js 中的实现原理主要基于 <code>JavaScript 的对象合并和原型链机制。</code></p>
<ul>
<li>替换型:props inject methods computed 重复的会被替换</li>
<li>合并型:data 类似Object.assign(mixins.data,this.data)</li>
<li>队列型:watch 生命周期 =&gt;合并成一个数组，依次执行</li>
</ul>
<h4 id="mixins-和-composition-api的优缺点">mixins 和 composition api的优缺点</h4>
<ol>
<li>Mixins的优缺点</li>
</ol>
<ul>
<li>优点：
<ul>
<li>代码复用：如方法、计算属性、生命周期钩子等。</li>
<li>逻辑共享：通过混入多个mixin对象，可以将不同的功能组合在一起，为组件提供更多的能力，使得组件更加灵活和可扩展。</li>
<li>解耦逻辑：将与UI无关的逻辑（如数据处理、网络请求等）抽取为mixin，有助于将组件的关注点更集中在UI层面，提高代码的可读性和可维护性。</li>
</ul>
</li>
<li>缺点：
<ul>
<li>命名冲突</li>
<li>难以追踪</li>
<li>维护困难</li>
</ul>
</li>
</ul>
<ol start="2">
<li>Composition API的优缺点</li>
</ol>
<ul>
<li>优点：
<ul>
<li>更灵活的代码组织：Composition API支持将逻辑代码以函数或一组相关联的函数形式封装为可复用的组合式函数，使得代码组织更加直观和模块化。</li>
<li>逻辑复用和组合：通过组合式函数，可以更轻松地在组件之间复用和共享逻辑代码，减少代码的冗余。</li>
</ul>
</li>
<li>缺点：
<ul>
<li>与Options API的兼容性：在迁移或混合使用两种API时可能会遇到一些挑战</li>
<li>可能过度使用：虽然组合式函数提供了灵活的代码组织方式，但过度使用可能会导致代码结构变得复杂和难以理解。</li>
</ul>
</li>
</ul>
<h3 id="vue中的修饰符">vue中的修饰符</h3>
<p>修饰符处理更多的dom细节，专注做逻辑方面操作</p>
<ol>
<li>表单 v-model.lazy v-model.trim v-model.number(如果输入值无法被parseFloat解析则返回原值)</li>
<li>事件 @click.stop(等于event.stopPropagation) @submit.prevent(等于event.preventDefalut) @click.self(对当前元素自身触发函数) @click.capture(捕获方式) @scroll.passvie(lazy模式，减少触发频率) @click.native(让组件像html一样可以监听根元素的原生事件,加在原生标签不生效)</li>
<li>鼠标键盘：@keyup.keyCode @click.middle...</li>
<li>v-bind修饰符：async props camel</li>
</ol>
<pre><code class="language-html">//
<span class="hljs-tag">&lt;<span class="hljs-name">comp</span> <span class="hljs-attr">:myMessage.sync</span>=<span class="hljs-string">&quot;bar&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">comp</span>&gt;</span>
//
this.$emit(&#x27;update:myMessage&#x27;,params);
</code></pre>
<p>相当于下面的简写</p>
<pre><code class="language-html">//
<span class="hljs-tag">&lt;<span class="hljs-name">comp</span> <span class="hljs-attr">:myMessage</span>=<span class="hljs-string">&quot;bar&quot;</span> @<span class="hljs-attr">update:myMessage</span>=<span class="hljs-string">&quot;func&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">comp</span>&gt;</span>
func(e){
	this.bar = e;
}
// js
func2(){
 this.$emit(&#x27;update:myMessage&#x27;,params);
}
</code></pre>
<h4 id="注意修饰符顺序">注意修饰符顺序</h4>
<ul>
<li>@click.prevent.self(阻止所有点击)</li>
<li>@click.self.prevent(阻止当前元素的点击)</li>
</ul>
<h3 id="vue中的nexttick">vue中的$nextTick</h3>
<p>在下次DOM更新循环结束之后执行延迟回调，在修改数据之后立即使用这个方法，可以获取更新后的DOM</p>
<h4 id="为什么要有nexttick">为什么要有$nextTick</h4>
<pre><code class="language-js">{{num}}
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">100000</span>; i++){
 num = i
}
</code></pre>
<p>如果没有nextTick，那么每次num变动，都会更新视图。有了nextTick，只需要更新一次，本质是一种性能优化策略。</p>
<blockquote>
<p>实现回调的机制分别可能是Promise.then&gt;MutationObserver&gt;setImmediate&gt;setTimeout(降级操作)</p>
</blockquote>
<pre><code class="language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> isUsingMicroTask = <span class="hljs-literal">false</span>
<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Promise</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="hljs-title function_">isNative</span>(<span class="hljs-title class_">Promise</span>)) {
  <span class="hljs-comment">//判断1：是否原生支持Promise</span>
  <span class="hljs-keyword">const</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>()
  timerFunc = <span class="hljs-function">() =&gt;</span> {
    p.<span class="hljs-title function_">then</span>(flushCallbacks)
    <span class="hljs-keyword">if</span> (isIOS) <span class="hljs-built_in">setTimeout</span>(noop)
  }
  isUsingMicroTask = <span class="hljs-literal">true</span>
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!isIE &amp;&amp; <span class="hljs-keyword">typeof</span> <span class="hljs-title class_">MutationObserver</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span> &amp;&amp; (
  <span class="hljs-title function_">isNative</span>(<span class="hljs-title class_">MutationObserver</span>) ||
  <span class="hljs-title class_">MutationObserver</span>.<span class="hljs-title function_">toString</span>() === <span class="hljs-string">&#x27;[object MutationObserverConstructor]&#x27;</span>
)) {
  <span class="hljs-comment">//判断2：是否原生支持MutationObserver</span>
  <span class="hljs-keyword">let</span> counter = <span class="hljs-number">1</span>
  <span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MutationObserver</span>(flushCallbacks)
  <span class="hljs-keyword">const</span> textNode = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createTextNode</span>(<span class="hljs-title class_">String</span>(counter))
  observer.<span class="hljs-title function_">observe</span>(textNode, {
    <span class="hljs-attr">characterData</span>: <span class="hljs-literal">true</span>
  })
  timerFunc = <span class="hljs-function">() =&gt;</span> {
    counter = (counter + <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>
    textNode.<span class="hljs-property">data</span> = <span class="hljs-title class_">String</span>(counter)
  }
  isUsingMicroTask = <span class="hljs-literal">true</span>
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> setImmediate !== <span class="hljs-string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="hljs-title function_">isNative</span>(setImmediate)) {
  <span class="hljs-comment">//判断3：是否原生支持setImmediate</span>
  timerFunc = <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-title function_">setImmediate</span>(flushCallbacks)
  }
} <span class="hljs-keyword">else</span> {
  <span class="hljs-comment">//判断4：上面都不行，直接用setTimeout</span>
  timerFunc = <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-built_in">setTimeout</span>(flushCallbacks, <span class="hljs-number">0</span>)
  }
}
</code></pre>
<h4 id="使用场景">使用场景</h4>
<ul>
<li>想要获取最新的dom结构</li>
</ul>
<pre><code class="language-js"><span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span> = <span class="hljs-string">&#x27;修改值&#x27;</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$el</span>.<span class="hljs-property">textContent</span>) <span class="hljs-comment">// =&gt; &#x27;原始值&#x27;</span>
<span class="hljs-variable language_">this</span>.$nextTick(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
 <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$el</span>.<span class="hljs-property">textContent</span>) <span class="hljs-comment">// =&gt; &#x27;最新值&#x27;</span>
})
</code></pre>
<ul>
<li>回调：$nextTick返回一个promise对象，可以用async await完成相同的事</li>
</ul>
<pre><code class="language-js"><span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span> = <span class="hljs-string">&#x27;修改值&#x27;</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$el</span>.<span class="hljs-property">textContent</span>) <span class="hljs-comment">// =&gt; &#x27;原始值&#x27;</span>
<span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.$nextTick()
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$el</span>.<span class="hljs-property">textContent</span>) <span class="hljs-comment">// =&gt; &#x27;最新值&#x27;</span>
</code></pre>
<h3 id="v-model自定义组件实现">v-model自定义组件实现</h3>
<ol>
<li>v-model是语法糖，可以用在自定义组件中，会被解析为value和@input事件</li>
<li>如果子组件中完全没用到input，select，textarea，checkbox也是可以用v-model，如例myinput.vue</li>
<li>默认子组件接受value，触发事件input，但是可以通过子组件中的model修改props中的名字和事件触发的名字，如myinput2.vue</li>
<li>(如果不是用model，那么参数仍然是value，触发条件仍然是input事件)</li>
<li>注意checkbox修改的值是e.target.checked,不是e.target.value</li>
</ol>
<p>使用 v-model好处是无需记特定的 prop 字段名，即可绑定到组件中的值，降低组件的使用成本。其次，应该尽量将「重复的逻辑处理」放在子组件中，这样子才会让组件的封装更有意义。</p>
<p>应用场景：<strong>子组件想要使用父组件的值,又想去改父组件的值</strong></p>
<h4 id="v-bindsync">v-bind:sync</h4>
<p>vue3已废弃，vue3可以同时给一个组件加多个v-model，不需要再用sync</p>
<pre><code class="language-html"><span class="hljs-comment">&lt;!--语法糖.sync--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">my-component</span> <span class="hljs-attr">:value.sync</span>=<span class="hljs-string">&quot;value&quot;</span> /&gt;</span>
<span class="hljs-comment">&lt;!--编译后的写法--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">my-component</span> 
  <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;msg&quot;</span> 
  @<span class="hljs-attr">update:value</span>=<span class="hljs-string">&quot;(val) =&gt; value = val&quot;</span>
</span></code></pre>
<p>与v-model 编译不同之处</p>
<pre><code class="language-html"><span class="hljs-comment">&lt;!--v-model写法--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">my-component</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;value&quot;</span>&gt;</span>
<span class="hljs-comment">&lt;!--编译后的写法--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">my-component</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>
  <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;value&quot;</span>
  @<span class="hljs-attr">input</span>=<span class="hljs-string">&quot;value = $event.target.value&quot;</span>
&gt;</span>
</code></pre>
<h4 id="vue3中的v-model不同之处">Vue3中的v-model不同之处</h4>
<p><img src="file:///e:\studying\book_files\83.jpg" alt="v-model"></p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> <span class="hljs-attr">v-model:title</span>=<span class="hljs-string">&quot;pageTitle&quot;</span> <span class="hljs-attr">v-model:content</span>=<span class="hljs-string">&quot;pageContent&quot;</span> /&gt;</span>

<span class="hljs-comment">&lt;!-- 是以下的简写： --&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span>
  <span class="hljs-attr">:title</span>=<span class="hljs-string">&quot;pageTitle&quot;</span>
  @<span class="hljs-attr">update:title</span>=<span class="hljs-string">&quot;pageTitle = $event&quot;</span>
  <span class="hljs-attr">:content</span>=<span class="hljs-string">&quot;pageContent&quot;</span>
  @<span class="hljs-attr">update:content</span>=<span class="hljs-string">&quot;pageContent = $event&quot;</span>/&gt;</span>

</code></pre>
<h3 id="diff算法">diff算法</h3>
<p>diff 算法是一种通过同层的树节点进行比较的高效算法</p>
<p>其有两个特点：</p>
<ul>
<li>比较只会在同层级进行, 不会跨层级比较(<code>深度优先，同层比较</code>)</li>
<li>在diff比较的过程中，循环从两边向中间比较</li>
</ul>
<p>diff 算法在很多场景下都有应用，在 vue 中，作用于虚拟 dom 渲染成真实 dom 的新旧 VNode 节点比较</p>
<h4 id="vue中diff算法怎样降低时间复杂度">Vue中diff算法怎样降低时间复杂度</h4>
<p>当页面进行渲染后，会生成一个虚拟DOM保存在内存中，节点发生变化时又生成新的虚拟DOM，传统的Diff算法是通过遍历循环对比新的虚拟DOM与之前保存的旧的虚拟DOM之间的变化（两层嵌套时间复杂度为O（n^2） ），如果每个节点都有变化则需要更新的操作，所以传统的Diff算法的时间复杂度是O(n ^3)。如果DOM的节点非常多，显然这个代价也是非常高的。
优化后的diff算法O(n)：</p>
<ol>
<li>只同级比较，不跨级比较</li>
<li>tag不同，直接删除重建，不再深度比较</li>
<li>tag和key两者新旧相同，则认为是相同节点，不再深度比较</li>
</ol>
<p><img src="file:///e:\studying\book_files\94.jpg" alt="key"></p>
<p>如同Snabbdom中，调用patch(elem,vnode)和patch(vnode,newVnode);</p>
<p>在updateChildren中，可以快速利用key和tag去判断是否是同一个元素。如果是，借助patchVode进行对比，判断到底该怎么去操作它的新旧值，是removeVnodes还是addVnodes内容，是children还是text等。</p>
<h3 id="vue中组件和插件有什么区别">Vue中组件和插件有什么区别</h3>
<p>组件就是把图形、非图形的各种逻辑均抽象为一个统一的概念（组件）来实现开发的模式，在Vue中每一个.vue文件都可以视为一个组件.插件通常用来为 Vue 添加全局功能。</p>
<ol>
<li>编写形式:组件可以.vue，可以看利用Vue.component编写，而插件需要调用install，注册使用use</li>
</ol>
<pre><code class="language-js"><span class="hljs-title class_">MyPlugin</span>.<span class="hljs-property">install</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">Vue, options</span>) {
  <span class="hljs-comment">// 1. 添加全局方法或 property</span>
  <span class="hljs-title class_">Vue</span>.<span class="hljs-property">myGlobalMethod</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-comment">// 逻辑...</span>
  }
   <span class="hljs-comment">// 2. 添加全局资源</span>
    <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">directive</span>(<span class="hljs-string">&#x27;my-directive&#x27;</span>, {
      bind (el, binding, vnode, oldVnode) {
        <span class="hljs-comment">// 逻辑...</span>
      }
      ...
    })
  
    <span class="hljs-comment">// 3. 注入组件选项</span>
    <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">mixin</span>({
      <span class="hljs-attr">created</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
        <span class="hljs-comment">// 逻辑...</span>
      }
      ...
    })
  
    <span class="hljs-comment">// 4. 添加实例方法</span>
    <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$myMethod</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">methodOptions</span>) {
      <span class="hljs-comment">// 逻辑...</span>
    }
}
<span class="hljs-comment">//安装</span>
<span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(插件名字,{ <span class="hljs-comment">/* ... */</span>} )
</code></pre>
<ol start="2">
<li>应用场景
<ul>
<li>组件 (Component) 是用来构成你的 App 的业务模块，它的目标是 App.vue</li>
<li>插件 (Plugin) 是用来增强你的技术栈的功能模块，它的目标是 Vue 本身，简单来说，插件就是指对Vue的功能的增强或补充</li>
</ul>
</li>
</ol>
<h3 id="自定义指令的应用场景">自定义指令的应用场景</h3>
<ol>
<li>按钮权限控制：通过后台返回的权限控制表，对需要控制的按钮进行匹配，v-xxx控制显示或者隐藏</li>
<li>v-throttle： 防止重复表单提交</li>
</ol>
<pre><code class="language-js"><span class="hljs-comment">// 1.设置v-throttle自定义指令</span>
<span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">directive</span>(<span class="hljs-string">&#x27;throttle&#x27;</span>, {
  <span class="hljs-attr">bind</span>: <span class="hljs-function">(<span class="hljs-params">el, binding</span>) =&gt;</span> {
    <span class="hljs-keyword">let</span> throttleTime = binding.<span class="hljs-property">value</span>; <span class="hljs-comment">// 节流时间</span>
    <span class="hljs-keyword">if</span> (!throttleTime) { <span class="hljs-comment">// 用户若不设置节流时间，则默认2s</span>
      throttleTime = <span class="hljs-number">2000</span>;
    }
    <span class="hljs-keyword">let</span> cbFun;
    el.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {
      <span class="hljs-keyword">if</span> (!cbFun) { <span class="hljs-comment">// 第一次执行</span>
        cbFun = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
          cbFun = <span class="hljs-literal">null</span>;
        }, throttleTime);
      } <span class="hljs-keyword">else</span> {
        event &amp;&amp; event.<span class="hljs-title function_">stopImmediatePropagation</span>();
      }
    }, <span class="hljs-literal">true</span>);
  },
});
<span class="hljs-comment">// 2.为button标签设置v-throttle自定义指令</span>
<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;sayHello&quot;</span> <span class="hljs-attr">v-throttle</span>&gt;</span>提交<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
</code></pre>
<h3 id="vue过滤器">vue过滤器</h3>
<p>vue3已废弃</p>
<pre><code class="language-js"><span class="hljs-attr">filters</span>: {
  <span class="hljs-attr">capitalize</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) {
    <span class="hljs-keyword">if</span> (!value) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>
    value = value.<span class="hljs-title function_">toString</span>()
    <span class="hljs-keyword">return</span> value.<span class="hljs-title function_">charAt</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">toUpperCase</span>() + value.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>)
  }
}
</code></pre>
<p>注意：当全局过滤器和局部过滤器重名时，会采用局部过滤器</p>
<p>过滤器可串联，可传参。filterA 被定义为接收单个参数的过滤器函数，表达式 message 的值将作为参数传入到函数中。然后继续调用同样被定义为接收单个参数的过滤器函数 filterB，将 filterA 的结果传递到 filterB 中。</p>
<pre><code class="language-html">{{ message | filterA | filterB }}
{{ message | filterA(&#x27;arg1&#x27;, arg2) }}
</code></pre>
<h3 id="vue插槽slot">vue插槽slot</h3>
<p>通过插槽可以让用户可以拓展组件，去更好地复用组件和对其做定制化处理</p>
<ul>
<li>默认插槽</li>
</ul>
<pre><code class="language-html"><span class="hljs-comment">&lt;!-- 子组件 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>插槽后备的内容<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
</code></pre>
<pre><code class="language-html"><span class="hljs-comment">&lt;!-- 父组件 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">Child</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>默认插槽<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  
<span class="hljs-tag">&lt;/<span class="hljs-name">Child</span>&gt;</span>
</code></pre>
<ul>
<li>具名插槽:子组件用name属性来表示插槽的名字，不传为默认插槽</li>
</ul>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span>插槽后备的内容<span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span>插槽后备的内容<span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
</code></pre>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">child</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:default</span>&gt;</span>具名插槽<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- 具名插槽 插槽名做参数 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:content</span>&gt;</span>内容...<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span>
</code></pre>
<p><img src="file:///e:\studying\book_files\90.jpg" alt="插槽"></p>
<ul>
<li>作用域插槽：子组件在<strong>作用域上绑定属性</strong>来将子组件的信息传给父组件使用，这些属性会被挂在<strong>父组件v-slot</strong>接受的对象上</li>
</ul>
<p>父组件中在使用时通过v-slot:（简写：#）获取子组件的信息，在内容中使用</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span> 
  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;footer&quot;</span> <span class="hljs-attr">testProps</span>=<span class="hljs-string">&quot;子组件的值&quot;</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>没传footer插槽<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
</code></pre>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">child</span>&gt;</span> 
    <span class="hljs-comment">&lt;!-- 把v-slot的值指定为作用域上下文对象 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:default</span>=<span class="hljs-string">&quot;slotProps&quot;</span>&gt;</span>
      来自子组件数据：{{slotProps.testProps}}
    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">default</span>=<span class="hljs-string">&quot;slotProps&quot;</span>&gt;</span>
      来自子组件数据：{{slotProps.testProps}}
    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span>
</code></pre>
<h3 id="vue虚拟dom">vue虚拟dom</h3>
<p>真实dom的一个映射，在Javascript对象中，虚拟DOM 表现为一个 Object对象。并且最少包含标签名 (tag)、属性 (attrs) 和子元素对象 (children) 三个属性，不同框架对这三个属性的名命可能会有差别。</p>
<p>作用：可描述dom，同时适用于<strong>跨平台开发</strong>，vue可以对这颗抽象树进行创建节点,删除节点以及修改节点的操作， 经过<code>diff算法</code>得出一些需要修改的<code>最小单位</code>,再更新视图，减少了dom操作，提高了性能.</p>
<p>用传统的原生api或jQuery去操作DOM时，浏览器会从构建DOM树开始从头到尾执行一遍流程</p>
<p>当你在一次操作时，需要更新10个DOM节点，浏览器没这么智能，收到第一个更新DOM请求后，并不知道后续还有9次更新操作，因此会马上执行流程，最终执行10次流程</p>
<p>而通过VNode，同样更新10个DOM节点，虚拟DOM不会立即操作DOM，而是将这10次更新的diff内容保存到本地的一个js对象中，最终将这个js对象一次性attach到DOM树上，避免大量的无谓计算.</p>
<h3 id="vueobservable">Vue.observable</h3>
<p>Vue.observable 是 Vue 2.x 中的一个方法，它返回一个可以响应 Vue 组件中变化的对象。这个对象类似于 Vue 组件的 data 对象，但不是 Vue 实例的一部分。这可以用于在多个组件或实例之间共享状态。</p>
<pre><code class="language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;  
  
<span class="hljs-keyword">const</span> state = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">observable</span>({  
  <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>  
});
<span class="hljs-keyword">function</span> <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) {  
  state.<span class="hljs-property">count</span>++;  
}
</code></pre>
<p>在vue文件中使用</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>  
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Count: {{ count }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>  
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;incrementCount&quot;</span>&gt;</span>Increment<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>  
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>  
  
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">  
<span class="hljs-keyword">import</span> { state, increment } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./wherever-you-stored-them&#x27;</span>;  
  
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {  
  <span class="hljs-attr">computed</span>: { 
	<span class="hljs-comment">// 用computed接收数据</span>
    <span class="hljs-title function_">count</span>(<span class="hljs-params"></span>) {  
      <span class="hljs-keyword">return</span> state.<span class="hljs-property">count</span>;  
    }  
  },  
  <span class="hljs-attr">methods</span>: {  
    <span class="hljs-title function_">incrementCount</span>(<span class="hljs-params"></span>) {  
      <span class="hljs-title function_">increment</span>();  
    }  
	<span class="hljs-comment">// 可以这样写incrementCount:increment</span>
  }  
}  
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p>应用场景：在非父子组件通信时，可以使用通常的bus或者使用vuex，但是实现的功能不是太复杂，而使用上面两个又有点繁琐。</p>
<blockquote>
<p>vue3中就不继续推荐了</p>
</blockquote>
<h3 id="vue处理错误">vue处理错误</h3>
<p>在Vue 中，则是定义了一套对应的错误处理规则给到使用者，且在源代码级别，对部分必要的过程做了一定的错误处理。</p>
<ul>
<li>后端接口返回错误</li>
<li>代码自身编写问题</li>
</ul>
<pre><code class="language-js"><span class="hljs-comment">//axios拦截器</span>
apiClient.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(
  <span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> {
    <span class="hljs-keyword">return</span> response;
  },
  <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
    <span class="hljs-keyword">if</span> (error.<span class="hljs-property">response</span>.<span class="hljs-property">status</span> == <span class="hljs-number">401</span>) {
      router.<span class="hljs-title function_">push</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Login&quot;</span> });
    } <span class="hljs-keyword">else</span> {
      message.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;出错了&quot;</span>);
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);
    }
  }
);
</code></pre>
<h4 id="vue前端代码错误处理">vue前端代码错误处理</h4>
<pre><code class="language-js"><span class="hljs-comment">//全局设置错误处理</span>
<span class="hljs-title class_">Vue</span>.<span class="hljs-property">config</span>.<span class="hljs-property">errorHandler</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">err, vm, info</span>) {
  <span class="hljs-comment">// handle error</span>
  <span class="hljs-comment">// `info` 是 Vue 特定的错误信息，比如错误所在的生命周期钩子</span>
  <span class="hljs-comment">// 只在 2.2.0+ 可用</span>
}
</code></pre>
<pre><code class="language-js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;cat&#x27;</span>, {
    <span class="hljs-attr">template</span>:<span class="hljs-string">`
        &lt;div&gt;
			&lt;h1&gt;Cat: &lt;/h1&gt;
        	&lt;slot&gt;&lt;/slot&gt;
        &lt;/div&gt;`</span>,
    <span class="hljs-attr">props</span>:{
        <span class="hljs-attr">name</span>:{
            <span class="hljs-attr">required</span>:<span class="hljs-literal">true</span>,
            <span class="hljs-attr">type</span>:<span class="hljs-title class_">String</span>
        }
    },
    <span class="hljs-title function_">errorCaptured</span>(<span class="hljs-params">err,vm,info</span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`cat EC: <span class="hljs-subst">${err.toString()}</span>\ninfo: <span class="hljs-subst">${info}</span>`</span>); 
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

});

<span class="hljs-comment">//子组件 dontexist不存在时</span>
<span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;kitten&#x27;</span>, {
    <span class="hljs-attr">template</span>:<span class="hljs-string">&#x27;&lt;div&gt;&lt;h1&gt;Kitten: {{ dontexist() }}&lt;/h1&gt;&lt;/div&gt;&#x27;</span>,
    <span class="hljs-attr">props</span>:{
        <span class="hljs-attr">name</span>:{
            <span class="hljs-attr">required</span>:<span class="hljs-literal">true</span>,
            <span class="hljs-attr">type</span>:<span class="hljs-title class_">String</span>
        }
    }
});

<span class="hljs-comment">// cat EC: TypeError: dontexist is not a function</span>
<span class="hljs-comment">// info: render</span>
</code></pre>
<h3 id="vue-keep-alvie">vue keep-alvie</h3>
<p>keep-alive是vue中的内置组件，能在组件切换过程中将状态保留在内存中，防止重复渲染DOM</p>
<p>keep-alive 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span> <span class="hljs-attr">include</span>=<span class="hljs-string">&quot;a,b&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;view&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 正则表达式 (使用 `v-bind`) --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span> <span class="hljs-attr">:include</span>=<span class="hljs-string">&quot;/a|b/&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;view&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 数组 (使用 `v-bind`) --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span> <span class="hljs-attr">:include</span>=<span class="hljs-string">&quot;[&#x27;a&#x27;, &#x27;b&#x27;]&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;view&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span>
</code></pre>
<p>设置了 keep-alive 缓存的组件，会多出两个生命周期钩子（activated与deactivated）：</p>
<p>首次进入组件时：beforeRouteEnter &gt; beforeCreate &gt; created&gt; mounted &gt; <code>activated</code> &gt; ... ... &gt; beforeRouteLeave &gt; <code>deactivated</code></p>
<p>再次进入组件时：beforeRouteEnter &gt;<code>activated</code> &gt; ... ... &gt; beforeRouteLeave &gt; <code>deactivated</code></p>
<p>keep-alive是vue中内置的一个组件,可以看到该组件没有template，而是用了render，在组件渲染的时候会自动执行render函数</p>
<pre><code class="language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;keep-alive&#x27;</span>,
  <span class="hljs-attr">abstract</span>: <span class="hljs-literal">true</span>,

  <span class="hljs-attr">props</span>: {
    <span class="hljs-attr">include</span>: [<span class="hljs-title class_">String</span>, <span class="hljs-title class_">RegExp</span>, <span class="hljs-title class_">Array</span>],
    <span class="hljs-attr">exclude</span>: [<span class="hljs-title class_">String</span>, <span class="hljs-title class_">RegExp</span>, <span class="hljs-title class_">Array</span>],
    <span class="hljs-attr">max</span>: [<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Number</span>]
  },

  created () {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>)
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">keys</span> = []
  },

  destroyed () {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>) {
      <span class="hljs-title function_">pruneCacheEntry</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>, key, <span class="hljs-variable language_">this</span>.<span class="hljs-property">keys</span>)
    }
  },

  mounted () {
    <span class="hljs-variable language_">this</span>.$watch(<span class="hljs-string">&#x27;include&#x27;</span>, <span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> {
      <span class="hljs-title function_">pruneCache</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-function"><span class="hljs-params">name</span> =&gt;</span> <span class="hljs-title function_">matches</span>(val, name))
    })
    <span class="hljs-variable language_">this</span>.$watch(<span class="hljs-string">&#x27;exclude&#x27;</span>, <span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> {
      <span class="hljs-title function_">pruneCache</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-function"><span class="hljs-params">name</span> =&gt;</span> !<span class="hljs-title function_">matches</span>(val, name))
    })
  },

  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">/* 获取默认插槽中的第一个组件节点 */</span>
    <span class="hljs-keyword">const</span> slot = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$slots</span>.<span class="hljs-property">default</span>
    <span class="hljs-keyword">const</span> vnode = <span class="hljs-title function_">getFirstComponentChild</span>(slot)
    <span class="hljs-comment">/* 获取该组件节点的componentOptions */</span>
    <span class="hljs-keyword">const</span> componentOptions = vnode &amp;&amp; vnode.<span class="hljs-property">componentOptions</span>

    <span class="hljs-keyword">if</span> (componentOptions) {
      <span class="hljs-comment">/* 获取该组件节点的名称，优先获取组件的name字段，如果name不存在则获取组件的tag */</span>
      <span class="hljs-keyword">const</span> name = <span class="hljs-title function_">getComponentName</span>(componentOptions)

      <span class="hljs-keyword">const</span> { include, exclude } = <span class="hljs-variable language_">this</span>
      <span class="hljs-comment">/* 如果name不在inlcude中或者存在于exlude中则表示不缓存，直接返回vnode */</span>
      <span class="hljs-keyword">if</span> (
        (include &amp;&amp; (!name || !<span class="hljs-title function_">matches</span>(include, name))) ||
        <span class="hljs-comment">// excluded</span>
        (exclude &amp;&amp; name &amp;&amp; <span class="hljs-title function_">matches</span>(exclude, name))
      ) {
        <span class="hljs-keyword">return</span> vnode
      }

      <span class="hljs-keyword">const</span> { cache, keys } = <span class="hljs-variable language_">this</span>
      <span class="hljs-comment">/* 获取组件的key值 */</span>
      <span class="hljs-keyword">const</span> key = vnode.<span class="hljs-property">key</span> == <span class="hljs-literal">null</span>
        <span class="hljs-comment">// same constructor may get registered as different local components</span>
        <span class="hljs-comment">// so cid alone is not enough (#3269)</span>
        ? componentOptions.<span class="hljs-property">Ctor</span>.<span class="hljs-property">cid</span> + (componentOptions.<span class="hljs-property">tag</span> ? <span class="hljs-string">`::<span class="hljs-subst">${componentOptions.tag}</span>`</span> : <span class="hljs-string">&#x27;&#x27;</span>)
        : vnode.<span class="hljs-property">key</span>
     <span class="hljs-comment">/*  拿到key值后去this.cache对象中去寻找是否有该值，如果有则表示该组件有缓存，即命中缓存 */</span>
      <span class="hljs-keyword">if</span> (cache[key]) {
        vnode.<span class="hljs-property">componentInstance</span> = cache[key].<span class="hljs-property">componentInstance</span>
        <span class="hljs-comment">// make current key freshest 移除这个组件当前位置，添加到最后位置</span>
        <span class="hljs-title function_">remove</span>(keys, key)
        keys.<span class="hljs-title function_">push</span>(key)
      }
        <span class="hljs-comment">/* 如果没有命中缓存，则将其设置进缓存 */</span>
        <span class="hljs-keyword">else</span> {
        cache[key] = vnode
        keys.<span class="hljs-title function_">push</span>(key)
        <span class="hljs-comment">// prune oldest entry</span>
        <span class="hljs-comment">/* 如果配置了max并且缓存的长度超过了this.max，则从缓存中删除第一个 */</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">max</span> &amp;&amp; keys.<span class="hljs-property">length</span> &gt; <span class="hljs-built_in">parseInt</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">max</span>)) {
          <span class="hljs-title function_">pruneCacheEntry</span>(cache, keys[<span class="hljs-number">0</span>], keys, <span class="hljs-variable language_">this</span>.<span class="hljs-property">_vnode</span>)
        }
      }

      vnode.<span class="hljs-property">data</span>.<span class="hljs-property">keepAlive</span> = <span class="hljs-literal">true</span>
    }
    <span class="hljs-keyword">return</span> vnode || (slot &amp;&amp; slot[<span class="hljs-number">0</span>])
  }
}
</code></pre>
<pre><code class="language-js"><span class="hljs-comment">// 组件销毁时函数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">pruneCacheEntry</span> (
  <span class="hljs-attr">cache</span>: <span class="hljs-title class_">VNodeCache</span>,
  <span class="hljs-attr">key</span>: string,
  <span class="hljs-attr">keys</span>: <span class="hljs-title class_">Array</span>&lt;string&gt;,
  current?: <span class="hljs-title class_">VNode</span>
) {
  <span class="hljs-keyword">const</span> cached = cache[key]
  <span class="hljs-comment">/* 判断当前没有处于被渲染状态的组件，将其销毁*/</span>
  <span class="hljs-keyword">if</span> (cached &amp;&amp; (!current || cached.<span class="hljs-property">tag</span> !== current.<span class="hljs-property">tag</span>)) {
    cached.<span class="hljs-property">componentInstance</span>.$destroy()
  }
  cache[key] = <span class="hljs-literal">null</span>
  <span class="hljs-title function_">remove</span>(keys, key)
}
</code></pre>
<h4 id="缓存后如何获取数据">缓存后如何获取数据</h4>
<ol>
<li>每次组件渲染的时候，都会执行beforeRouteEnter</li>
</ol>
<pre><code class="language-js"><span class="hljs-title function_">beforeRouteEnter</span>(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>){
    <span class="hljs-title function_">next</span>(<span class="hljs-function"><span class="hljs-params">vm</span>=&gt;</span>{
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(vm)
        <span class="hljs-comment">// 每次进入路由执行</span>
        vm.<span class="hljs-title function_">getData</span>()  <span class="hljs-comment">// 获取数据</span>
    })
}
</code></pre>
<ol start="2">
<li>在keep-alive缓存的组件被激活的时候，都会执行actived钩子(服务端渲染期间不会被调用)</li>
</ol>
<pre><code class="language-js"><span class="hljs-title function_">activated</span>(<span class="hljs-params"></span>){
   <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getData</span>() <span class="hljs-comment">// 获取数据</span>
},
</code></pre>
<h3 id="keep-alive和v-if一起使用情况">Keep-alive和v-if一起使用情况</h3>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">myCom</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;keyVal&quot;</span> /&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">otherCom</span> <span class="hljs-attr">v-else</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span>
</code></pre>
<p>在切换keyVal的值为false和true时，当第一次切换到两个组件的时候，myCom 与 otherCom 的mounted、activated生命周期都会被触发（先mounted后activated），等再次切换回来的时候，只会触发activated，注意此处也可以用component is的代替，代码规范上也更合适一些。</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;keyVal?&#x27;myCom&#x27;:&#x27;otherCom &#x27;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span>
</code></pre>
<p>注意点：正常理解v-if会删除dom重新创建，但是组件外套keep-alive之后，虽然确实会移除dom（可以打开控制台发现dom确实被移除了），但是dom结构会保存在缓存中，当被v-if为true时候直接搬回来，并不会再重新绘制dom，就<strong>不会激发mounted生命周期</strong>。</p>
<h3 id="vue动态组件和异步组件">Vue动态组件和异步组件</h3>
<pre><code class="language-html"><span class="hljs-comment">&lt;!-- 使用场景：tab切换，常配合keep-alive使用
使用关键：内置组件 + is属性 --&gt;</span>
 
<span class="hljs-comment">&lt;!-- 内置组件： &lt;component&gt;&lt;/component&gt;
is属性：绑定一个变量，其值为组件名称字符串，eg:     --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;com&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Left</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./LeftComponent.vue&#x27;</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Right</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./RightComponent.vue&#x27;</span>
<span class="hljs-title function_">data</span>(<span class="hljs-params"></span>){
    <span class="hljs-attr">com</span>: <span class="hljs-string">&#x27;Left&#x27;</span>
}
</span></code></pre>
<p>Vue.js中的异步组件可以通过使用import()方法来实现。import()方法是ES2015中的一个语法，用于动态地加载JavaScript模块。在Vue.js中，可以使用import()方法来动态地加载和渲染组件。</p>
<h3 id="vuex的使用">Vuex的使用</h3>
<p>Mutations：处理原子操作</p>
<p>Actions：可以处理多个Mutations和异步操作
<img src="file:///e:\studying\book_files\91.jpg" alt="vuex"></p>
<h3 id="介绍vue的模板编译">介绍Vue的模板编译</h3>
<p>模版指的就是template属性。vue内部会将template字符串转化成render函数进行渲染。render函数返回虚拟节点，再将虚拟节点转化成真实DOM。（模版=&gt;方法=&gt;节点）
而编译过程就是template转换render函数的过程。</p>
<p>如何将template转换成render函数？</p>
<ol>
<li>通过正则匹配字符串，将template模版转换成AST语法树 - parserHTML</li>
<li>对静态语法做静态标记 - markUP</li>
<li>重新生成代码 - codeGen</li>
</ol>
<p>⚠️注意：开发时尽量不要使用template</p>
<p>因为将template转化成render方法需要在运行时进行编译操作，会有性能损耗。同时引用带有compiler包的vue体积也会变大。默认.vue文件中的template处理是通过vue-loader来进行处理的，并不是通过运行时的编译。（默认vue项目中引入的vue.js是不带有compiler模块的。）</p>
<p>有些场景，可直接使用render代替template写法，template是静态的，不灵活。</p>
<pre><code class="language-js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>({
  router,
  store,
  <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">App</span>)
}).$mount(<span class="hljs-string">&#x27;#app&#x27;</span>)
</code></pre>
<p><img src="file:///e:\studying\book_files\96.jpg" alt="vue"></p>
<h3 id="spa">SPA</h3>
<p>单页应用，它通过动态重写当前页面来与用户交互，这种方法避免了页面之间切换打断用户体验在单页应用中</p>
<p><img src="file:///e:\studying\book_files\85.jpg" alt="SPA"></p>
<h4 id="原理和seo优化">原理和SEO优化</h4>
<p><img src="file:///e:\studying\book_files\86.jpg" alt="原理"></p>
<ol>
<li>服务端渲染 nuxt.js</li>
<li>静态化
<ul>
<li>通过程序将动态页面抓取成静态页面</li>
<li>WEB服务的 URL Rewrite</li>
</ul>
</li>
<li>使用phantom.js针对爬虫处理</li>
</ol>
<p><img src="file:///e:\studying\book_files\84.jpg" alt="爬虫"></p>
<h4 id="spa首屏加载优化">SPA首屏加载优化</h4>
<p>首屏时间（First Contentful Paint），指的是浏览器从响应用户输入网址地址，到首屏内容渲染完成的时间，此时整个网页不一定要全部渲染完成，但需要展示当前视窗需要的内容</p>
<pre><code class="language-js"><span class="hljs-comment">// 方案一：</span>
<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;DOMContentLoaded&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;first contentful painting&#x27;</span>);
});
<span class="hljs-comment">// 方案二：</span>
performance.<span class="hljs-title function_">getEntriesByName</span>(<span class="hljs-string">&quot;first-contentful-paint&quot;</span>)[<span class="hljs-number">0</span>].<span class="hljs-property">startTime</span>

<span class="hljs-comment">// performance.getEntriesByName(&quot;first-contentful-paint&quot;)[0]</span>
<span class="hljs-comment">// 会返回一个 PerformancePaintTiming的实例，结构如下：</span>
{
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;first-contentful-paint&quot;</span>,
  <span class="hljs-attr">entryType</span>: <span class="hljs-string">&quot;paint&quot;</span>,
  <span class="hljs-attr">startTime</span>: <span class="hljs-number">507.80000002123415</span>,
  <span class="hljs-attr">duration</span>: <span class="hljs-number">0</span>,
};
</code></pre>
<ol>
<li>
<p>加载慢可能的原因</p>
<ul>
<li>网络延时问题</li>
<li>资源文件体积是否过大</li>
<li>资源是否重复发送请求去加载了</li>
<li>加载脚本的时候，渲染内容堵塞了</li>
</ul>
</li>
<li>
<p>解决方案</p>
<ul>
<li>减小入口文件积：懒加载 分包</li>
<li>静态资源本地缓存：浏览器缓存 service-worker localstorage</li>
<li>UI框架按需加载</li>
<li>图片资源的压缩</li>
<li>组件重复打包:假设A.js文件是一个常用的库，现在有多个路由使用了A.js文件，这就造成了重复下载,需要构建工具提取，如在webpack的config文件中，修改CommonsChunkPlugin的配置，minChunks为3表示会把使用3次及以上的包抽离出来，放进公共依赖文件，避免了重复加载组件(在 Webpack 4 及以上版本中,CommonsChunkPlugin 已经被废弃，取而代之的是 optimization.splitChunks 配置。splitChunks 配置允许你更加灵活和细致地控制代码拆分和公共依赖的提取。)[CommonsChunkPlugin 的主要作用就是将公共的代码模块提取出来，生成一个新的 chunk 文件，这样浏览器在加载页面时就可以缓存这个公共的 chunk 文件，后续加载其他页面时就可以复用已经缓存的公共代码，避免重复下载。]</li>
<li>开启GZip压缩</li>
<li>使用SSR</li>
</ul>
</li>
</ol>
<h4 id="hisotory路由404">hisotory路由404</h4>
<p>nginx需要额外配置：只需要配置将任意页面都重定向到 index.html，把路由交由前端处理</p>
<pre><code class="language-bash">server {
  listen  80;
  server_name  www.xxx.com;

  location / {
    index  /data/dist/index.html;
    try_files <span class="hljs-variable">$uri</span> <span class="hljs-variable">$uri</span>/ /index.html;
  }
}
</code></pre>
<blockquote>
<p>hash 模式下，仅 hash 符号之前的内容会被包含在请求中，如 <a href="http://website.com/#/login">website.com/#/login</a> 只有 <a href="http://website.com">website.com</a> 会被包含在请求中 ，因此对于服务端来说，即使没有配置location，也不会返回404错误</p>
</blockquote>
<h2 id="vue3">Vue3</h2>
<p>vue3 整个源码是通过 monorepo的方式维护的，根据功能将不同的模块拆分到packages目录下面不同的子目录中</p>
<p><img src="file:///e:\studying\book_files\68.jpg" alt="vue3"></p>
<p>monorepo（单体仓库）<code>是一种将多个项目或包存储在同一个代码仓库中的管理方式</code>。在 monorepo 中，所有的项目或包共享相同的依赖和配置，这使得跨项目或跨包的代码共享、重构和测试变得更加容易。</p>
<p>Monorepo 的主要优势包括：</p>
<ul>
<li>代码共享：不同项目之间可以更容易地共享代码，减少重复劳动和代码冗余。</li>
<li>依赖管理：所有项目或包使用相同的依赖版本，减少了版本冲突和兼容性问题。</li>
<li>统一构建和测试：可以对整个 monorepo 进行统一的构建和测试，提高开发效率。</li>
</ul>
<h3 id="与vue2的不同">与Vue2的不同</h3>
<ol>
<li>速度更快
<ul>
<li>重写了虚拟Dom实现</li>
<li>编译模板的优化</li>
<li>更高效的组件初始化</li>
<li>update性能提高1.3~2倍</li>
<li>SSR速度提高了2~3倍</li>
</ul>
</li>
<li>体积更小
<ul>
<li>通过webpack的tree-shaking功能，可以将无用模块“剪辑”，仅打包需要的</li>
</ul>
</li>
<li>更易维护：compositon Api + options Api</li>
<li>更好的Typescript支持</li>
<li>编译器重写</li>
</ol>
<h4 id="功能改变">功能改变</h4>
<ul>
<li>fragments： 支持多根节点</li>
<li>Teleport：传送门</li>
<li>composition Api</li>
<li>createRenderer:能够构建自定义渲染器，能够将 vue 的开发模型扩展到其他平台</li>
</ul>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;showToast&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn&quot;</span>&gt;</span>打开 toast<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-comment">&lt;!-- to 属性就是目标位置 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">teleport</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;#teleport-target&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;visible&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;toast-wrap&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;toast-msg&quot;</span>&gt;</span>我是一个 Toast 文案<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">teleport</span>&gt;</span>
</code></pre>
<ul>
<li>组件上 v-model 用法已更改</li>
<li><code>&lt;template v-for&gt;</code>和 非 v-for节点上key用法已更改</li>
<li>在同一元素上使用的 v-if 和 v-for 优先级已更改</li>
<li>v-bind=&quot;object&quot; 现在排序敏感</li>
<li>v-for 中的 ref 不再注册 ref 数组</li>
<li>自定义指令 API 已更改为与组件生命周期一致</li>
<li>data 应始终声明为函数</li>
<li>来自 mixin 的 data 选项现在可简单地合并</li>
<li>attribute 强制策略已更改</li>
<li>移除$on，$off和$once 实例方法</li>
<li>移除过滤filter</li>
<li>移除内联模板 attribute</li>
<li>移除$destroy 实例方法。用户不应再手动管理单个Vue 组件的生命周期。在 Vue 3 中，$destroy 方法已经被完全移除，进一步强调了开发者应该依赖 Vue 的自动生命周期管理，而不是手动去销毁组件或实例。</li>
</ul>
<h3 id="vue3的composition-api的好处">vue3的Composition Api的好处</h3>
<ol>
<li>不需要像options API一个功能代码跳转很多地方</li>
<li>当混入时，不会像mixins存在数据来源不清晰，和多个混入容易冲突的情况</li>
</ol>
<pre><code class="language-js"><span class="hljs-keyword">import</span> { onMounted, onUnmounted, reactive } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useMove</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> position = <span class="hljs-title function_">reactive</span>({
    <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>,
    <span class="hljs-attr">y</span>: <span class="hljs-number">0</span>,
  });

  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleKeyup</span> = (<span class="hljs-params">e</span>) =&gt; {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">code</span>);
    <span class="hljs-comment">// 上下左右 x y</span>
    <span class="hljs-keyword">switch</span> (e.<span class="hljs-property">code</span>) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;ArrowUp&quot;</span>:
        <span class="hljs-comment">// y.value--;</span>
        position.<span class="hljs-property">y</span>--;
        <span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;ArrowDown&quot;</span>:
        <span class="hljs-comment">// y.value++;</span>
        position.<span class="hljs-property">y</span>++;
        <span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;ArrowLeft&quot;</span>:
        <span class="hljs-comment">// x.value--;</span>
        position.<span class="hljs-property">x</span>--;
        <span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;ArrowRight&quot;</span>:
        <span class="hljs-comment">// x.value++;</span>
        position.<span class="hljs-property">x</span>++;
        <span class="hljs-keyword">break</span>;
    }
  };

  <span class="hljs-title function_">onMounted</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;keyup&quot;</span>, handleKeyup);
  });

  <span class="hljs-title function_">onUnmounted</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&quot;keyup&quot;</span>, handleKeyup);
  });

  <span class="hljs-keyword">return</span> { position };
}
</code></pre>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    Mouse position: x {{ x }} / y {{ y }}
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">
<span class="hljs-keyword">import</span> { useMove } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./useMove&quot;</span>;
<span class="hljs-keyword">import</span> { toRefs } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> { position } = <span class="hljs-title function_">useMove</span>();
    <span class="hljs-keyword">const</span> { x, y } = <span class="hljs-title function_">toRefs</span>(position);
    <span class="hljs-keyword">return</span> {
      x,
      y,
    };

  },
};
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p>可以看到，整个数据来源清晰了，即使去编写更多的 hook 函数，也不会出现命名冲突的问题</p>
<h3 id="vue3性能提升主要体现在哪几个方面">vue3性能提升主要体现在哪几个方面</h3>
<p>回顾Vue2，每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把用到的数据property记录为依赖，当依赖发生改变，触发setter，则会通知watcher，从而使关联的组件重新渲染</p>
<p><img src="file:///e:\studying\book_files\69.jpg" alt="vue2"></p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span>静态文本<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span>静态文本<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span>{{ message }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span>静态文本<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
        ...
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span>静态文本<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
</code></pre>
<p>可以看到，组件内部只有一个动态节点，剩余一堆都是静态节点，所以这里很多 <code>diff 和遍历</code>其实都是不需要的，造成<code>性能浪费</code></p>
<p>因此，Vue3在编译阶段，做了进一步优化。主要有如下：</p>
<ul>
<li>diff算法优化:vue3在diff算法中相比vue2增加了静态标记,已经标记静态节点的p标签在diff过程中则不会比较，把性能进一步提高</li>
</ul>
<p><img src="file:///e:\studying\book_files\70.jpg" alt="静态节点"></p>
<ul>
<li>静态提升：对不参与更新的元素，会做静态提升，只会被创建一次，在渲染时直接复用</li>
</ul>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>你好<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{{ message }}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<pre><code class="language-js"><span class="hljs-comment">// 没做静态提升</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params">_ctx, _cache, $props, $setup, $data, $options</span>) {
  <span class="hljs-keyword">return</span> (<span class="hljs-title function_">_openBlock</span>(), <span class="hljs-title function_">_createBlock</span>(_Fragment, <span class="hljs-literal">null</span>, [
    <span class="hljs-title function_">_createVNode</span>(<span class="hljs-string">&quot;span&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;你好&quot;</span>),
    <span class="hljs-title function_">_createVNode</span>(<span class="hljs-string">&quot;div&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-title function_">_toDisplayString</span>(_ctx.<span class="hljs-property">message</span>), <span class="hljs-number">1</span> <span class="hljs-comment">/* TEXT */</span>)
  ], <span class="hljs-number">64</span> <span class="hljs-comment">/* STABLE_FRAGMENT */</span>))
}
</code></pre>
<pre><code class="language-js"><span class="hljs-comment">// 做了静态提升</span>
<span class="hljs-keyword">const</span> _hoisted_1 = <span class="hljs-comment">/*#__PURE__*/</span><span class="hljs-title function_">_createVNode</span>(<span class="hljs-string">&quot;span&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;你好&quot;</span>, -<span class="hljs-number">1</span> <span class="hljs-comment">/* HOISTED */</span>)

<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params">_ctx, _cache, $props, $setup, $data, $options</span>) {
  <span class="hljs-keyword">return</span> (<span class="hljs-title function_">_openBlock</span>(), <span class="hljs-title function_">_createBlock</span>(_Fragment, <span class="hljs-literal">null</span>, [
    _hoisted_1,
    <span class="hljs-title function_">_createVNode</span>(<span class="hljs-string">&quot;div&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-title function_">_toDisplayString</span>(_ctx.<span class="hljs-property">message</span>), <span class="hljs-number">1</span> <span class="hljs-comment">/* TEXT */</span>)
  ], <span class="hljs-number">64</span> <span class="hljs-comment">/* STABLE_FRAGMENT */</span>))
}

</code></pre>
<p>静态内容_hoisted_1被放置在render 函数外，每次渲染的时候只要取 _hoisted_1 即可</p>
<p>同时 _hoisted_1 被打上了 PatchFlag ，静态标记值为 -1 ，特殊标志是负整数表示永远不会用于 Diff</p>
<ul>
<li>事件监听缓存</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> render = <span class="hljs-comment">/*#__PURE__*/</span><span class="hljs-title function_">_withId</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params">_ctx, _cache, $props, $setup, $data, $options</span>) {
  <span class="hljs-keyword">return</span> (<span class="hljs-title function_">_openBlock</span>(), <span class="hljs-title function_">_createBlock</span>(<span class="hljs-string">&quot;div&quot;</span>, <span class="hljs-literal">null</span>, [
    <span class="hljs-title function_">_createVNode</span>(<span class="hljs-string">&quot;button&quot;</span>, { <span class="hljs-attr">onClick</span>: _ctx.<span class="hljs-property">onClick</span> }, <span class="hljs-string">&quot;点我&quot;</span>, <span class="hljs-number">8</span> <span class="hljs-comment">/* PROPS */</span>, [<span class="hljs-string">&quot;onClick&quot;</span>])
                                             <span class="hljs-comment">// PROPS=1&lt;&lt;3,// 8 //动态属性，但不包含类名和样式</span>
  ]))
})
</code></pre>
<pre><code class="language-js"><span class="hljs-comment">// 开启了缓存后，没有了静态标记。也就是说下次diff算法的时候直接使用</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params">_ctx, _cache, $props, $setup, $data, $options</span>) {
  <span class="hljs-keyword">return</span> (<span class="hljs-title function_">_openBlock</span>(), <span class="hljs-title function_">_createBlock</span>(<span class="hljs-string">&quot;div&quot;</span>, <span class="hljs-literal">null</span>, [
    <span class="hljs-title function_">_createVNode</span>(<span class="hljs-string">&quot;button&quot;</span>, {
      <span class="hljs-attr">onClick</span>: _cache[<span class="hljs-number">1</span>] || (_cache[<span class="hljs-number">1</span>] = <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> (_ctx.<span class="hljs-title function_">onClick</span>(...args)))
    }, <span class="hljs-string">&quot;点我&quot;</span>)
  ]))
}
</code></pre>
<ul>
<li>
<p>SSR优化:当静态内容大到一定量级时候，会用createStaticVNode方法在客户端去生成一个static node，这些静态node，会被直接innerHtml，就不需要创建对象，然后根据对象渲染</p>
</li>
<li>
<p>源码体积：相比Vue2，Vue3整体体积变小了，除了移出一些不常用的API，再重要的是Tree shanking。任何一个函数，如ref、reavtived、computed等，仅仅在用到的时候才打包，没用到的模块都被摇掉，打包的整体体积变小</p>
</li>
<li>
<p>响应式系统：vue3采用proxy重写了响应式系统，因为proxy可以对整个对象进行监听，所以不需要深度遍历。</p>
</li>
</ul>
<h3 id="vue3proxy取代defineproperty-api原因">vue3proxy取代defineProperty API原因</h3>
<ul>
<li>
<p>检测不到对象属性的添加和删除</p>
</li>
<li>
<p>数组API方法无法监听到</p>
</li>
<li>
<p>需要对每个属性进行遍历监听，如果<code>嵌套对象</code>，需要<code>深层监听</code>，造成性能问题</p>
</li>
<li>
<p>Object.defineProperty只能遍历对象属性进行劫持</p>
</li>
<li>
<p>Proxy直接可以劫持整个对象，并返回一个新对象，我们可以只操作新的对象达到响应式目的</p>
</li>
<li>
<p>Proxy可以直接监听数组的变化（push、shift、splice）</p>
</li>
<li>
<p>Proxy有多达13种拦截方法,不限于apply、ownKeys、deleteProperty、has等等，这是Object.defineProperty不具备的</p>
</li>
<li>
<p><strong>Proxy 不兼容IE，也没有 polyfill</strong></p>
</li>
</ul>
<h3 id="如何理解ref-reactive-toref-torefs">如何理解ref reactive toRef toRefs</h3>
<h4 id="ref">ref</h4>
<ol>
<li>生成 <strong>值类型</strong> 的 <strong>响应式</strong> 数据</li>
<li>可用于模板和reactive</li>
<li>通过.value修改值</li>
<li>可获取dom元素</li>
</ol>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>ref demo {{ageRef}} {{state.name}}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">
<span class="hljs-keyword">import</span> { ref, reactive } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Ref&#x27;</span>,
    <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">const</span> ageRef = <span class="hljs-title function_">ref</span>(<span class="hljs-number">20</span>) <span class="hljs-comment">// 值类型 响应式</span>
        <span class="hljs-keyword">const</span> nameRef = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;双越&#x27;</span>)
		  <span class="hljs-comment">// ref可以直接用在reactive里</span>
        <span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>({
            <span class="hljs-attr">name</span>: nameRef
        })

        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;ageRef&#x27;</span>, ageRef.<span class="hljs-property">value</span>)

            ageRef.<span class="hljs-property">value</span> = <span class="hljs-number">25</span> <span class="hljs-comment">// .value 修改值</span>
            nameRef.<span class="hljs-property">value</span> = <span class="hljs-string">&#x27;双越A&#x27;</span>
        }, <span class="hljs-number">1500</span>);

        <span class="hljs-keyword">return</span> {
            ageRef,
            state
        }
    }
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;elemRef&quot;</span>&gt;</span>我是一行文字<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">
<span class="hljs-keyword">import</span> { ref, onMounted } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;RefTemplate&#x27;</span>,
	<span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
	 <span class="hljs-comment">// 和模板里的ref同名</span>
        <span class="hljs-keyword">const</span> elemRef = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>)
	<span class="hljs-comment">//在mounted之后才可以获取dom元素</span>
        <span class="hljs-title function_">onMounted</span>(<span class="hljs-function">() =&gt;</span> {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;ref template&#x27;</span>, elemRef.<span class="hljs-property">value</span>.<span class="hljs-property">innerHTML</span>, elemRef.<span class="hljs-property">value</span>)
        })
        <span class="hljs-keyword">return</span> {
            elemRef
        }
    }
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<h4 id="reactive">reactive</h4>
<p>reactive一般用来定义响应式对象。不可直接解构，会丢失响应式的效果，想要属性具有响应式可借助toRef或者toRefs</p>
<h4 id="toref">toRef</h4>
<ol>
<li>针对一个响应式对象（reactive封装）的prop</li>
<li>创建一个ref，具有响应式</li>
<li>两者保持引用关系</li>
</ol>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>toRef demo - {{ageRef}} - {{state.name}} {{state.age}}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">
<span class="hljs-keyword">import</span> { ref, toRef, reactive } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;ToRef&#x27;</span>,
    <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>({
            <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>,
            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;双越&#x27;</span>
        })

        <span class="hljs-keyword">const</span> age1 = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> {
            <span class="hljs-keyword">return</span> state.<span class="hljs-property">age</span> + <span class="hljs-number">1</span>
        })

        <span class="hljs-comment">// // toRef 如果用于普通对象（非响应式对象）,</span>
        <span class="hljs-comment">//产出的结果不具备响应式,可在界面上显示</span>
        <span class="hljs-comment">// const state = {</span>
        <span class="hljs-comment">//     age: 20,</span>
        <span class="hljs-comment">//     name: &#x27;双越&#x27;</span>
        <span class="hljs-comment">// }</span>

        <span class="hljs-keyword">const</span> ageRef = <span class="hljs-title function_">toRef</span>(state, <span class="hljs-string">&#x27;age&#x27;</span>)
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
            state.<span class="hljs-property">age</span> = <span class="hljs-number">25</span>
        }, <span class="hljs-number">1500</span>)
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
            ageRef.<span class="hljs-property">value</span> = <span class="hljs-number">30</span> <span class="hljs-comment">// .value 修改值</span>
        }, <span class="hljs-number">3000</span>)

        <span class="hljs-keyword">return</span> {
            state,
            ageRef
        }
    }
}
</span></code></pre>
<h4 id="torefs">toRefs</h4>
<ol>
<li>将一个响应式对象（reactive封装）转为普通对象</li>
<li>普通对象的每个属性都是ref，具有响应式</li>
<li>两者保持引用关系</li>
</ol>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>toRefs demo {{age}} {{name}}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">
<span class="hljs-keyword">import</span> { ref, toRef, toRefs, reactive } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;ToRefs&#x27;</span>,
    <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>({
            <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>,
            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;双越&#x27;</span>
        })
        <span class="hljs-keyword">const</span> stateAsRefs = <span class="hljs-title function_">toRefs</span>(state) <span class="hljs-comment">// 将响应式对象，变成普通对象</span>
        <span class="hljs-comment">// const { age: ageRef, name: nameRef } = stateAsRefs // 每个属性，都是 ref 对象</span>
        <span class="hljs-comment">// return {</span>
        <span class="hljs-comment">//     ageRef,</span>
        <span class="hljs-comment">//     nameRef</span>
        <span class="hljs-comment">// }</span>
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
            state.<span class="hljs-property">age</span> = <span class="hljs-number">25</span>
        }, <span class="hljs-number">1500</span>)

       <span class="hljs-keyword">return</span> stateAsRefs
       <span class="hljs-comment">// return toRefs(state) √√√√</span>
       <span class="hljs-comment">// return {...stateAsRefs} //当如果有其他属性时适用 √√√√</span>
       <span class="hljs-comment">// return {...state}//xxxx错误 不再具有响应式</span>
       <span class="hljs-comment">// return {state} √√√√ 但是模板中{{state.age}} {{state.name}} 不方便</span>
    }
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p>使用toRefs，合成函数返回响应式对象，可方便解构</p>
<p><img src="file:///e:\studying\book_files\109.jpg" alt="ref"></p>
<h2 id="react">React</h2>
<p>React，用于构建用户界面的 JavaScript 库。遵循组件设计模式、声明式编程范式和函数式编程概念，以使前端应用程序更高效</p>
<p>使用虚拟 DOM 来有效地操作 DOM，遵循从高阶组件到低阶组件的<code>单向数据流</code></p>
<h3 id="说说react特性">说说React特性</h3>
<ul>
<li>JSX 语法</li>
<li>单向数据绑定:单向数据流比双向绑定更安全，速度更快</li>
<li>虚拟 DOM</li>
<li>声明式编程:声明式编程是一种编程范式，它关注的是你要做什么，而不是如何做</li>
<li>Component：可组合可复用可重用</li>
</ul>
<h3 id="state-和-props-区别">state 和 props 区别</h3>
<ol>
<li>state</li>
</ol>
<p>一个组件的显示形态可以由<code>数据状态和外部参数</code>所决定，而数据状态就是 state，一般在 constructor 中<strong>初始化</strong></p>
<p>当需要修改里面的值的状态需要通过调用 setState 来改变，从而达到更新组件内部数据的作用，并且重新调用组件 render 方法：</p>
<pre><code class="language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Button</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">super</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = {
      <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,
    };
  }

  <span class="hljs-title function_">updateCount</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<span class="hljs-function">(<span class="hljs-params">prevState, props</span>) =&gt;</span> {
      <span class="hljs-keyword">return</span> { <span class="hljs-attr">count</span>: prevState.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> };
    });
  }

  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> (
      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> this.updateCount()}&gt;
        Clicked {this.state.count} times
      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
    );
  }
}
</code></pre>
<p>setState 还可以接受第二个参数，它是一个函数，会在 setState 调用完成并且组件开始重新渲染时被调用，可以用来监听渲染是否完成</p>
<pre><code class="language-js"><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(
  {
    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;JS每日一题&quot;</span>,
  },
  <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;setState finished&quot;</span>)
);
</code></pre>
<ol start="2">
<li>props</li>
</ol>
<p>组件从概念上看就是一个函数，可以接受一个参数作为输入值，这个参数就是 props，所以可以把 props 理解为<code>从外部传入组件内部的数据</code></p>
<p>react 具有单向数据流的特性，所以他的主要作用是从父组件向子组件中传递数据</p>
<p>props 除了可以传字符串，数字，还可以传递<strong>对象，数组甚至是回调函数</strong></p>
<pre><code class="language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Welcome</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> {
  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello {this.props.name}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;
  }
}

<span class="hljs-keyword">const</span> element = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Welcome</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Sara&quot;</span> <span class="hljs-attr">onNameChanged</span>=<span class="hljs-string">{this.handleName}</span> /&gt;</span></span>;
</code></pre>
<p>上述 name 属性与 onNameChanged 方法都能在子组件的 props 变量中访问</p>
<p>在子组件中，props 在内部不可变的，如果想要改变它看，只能通过外部组件传入新的 props 来重新渲染子组件，否则子组件的 props 和展示形式不会改变</p>
<h3 id="super-和-superprops-区别">super() 和 super(props) 区别</h3>
<p>在 React 中，类组件基于 ES6，所以在 constructor 中必须使用 super</p>
<p>在调用 super 过程，无论是否传入 props，React 内部都会将 porps 赋值给组件实例 porps 属性中</p>
<p>如果只调用了 super()，那么 <strong>this.props</strong> 在 super() 和构造函数结束之间仍是 undefined</p>
<h3 id="类组件和函数组件的区别">类组件和函数组件的区别</h3>
<ol>
<li>两者最明显的区别在于编写形式的不同，同一种功能的实现可以分别对应类组件和函数组件的编写形式</li>
</ol>
<pre><code class="language-js"><span class="hljs-comment">// 函数组件</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Welcome</span>(<span class="hljs-params">props</span>) {
  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, {props.name}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;
}

<span class="hljs-comment">//类组件</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Welcome</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) {
    <span class="hljs-variable language_">super</span>(props)
  }
  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, {this.props.name}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>
  }
}
</code></pre>
<ol start="2">
<li>状态管理：在hooks出来之前，函数组件就是无状态组件，不能保管组件的状态，不像类组件中调用setState，如果想要管理state状态，可以使用useState</li>
</ol>
<pre><code class="language-js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">FunctionalComponent</span> = (<span class="hljs-params"></span>) =&gt; {
    <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">return</span> (
        <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>count: {count}&lt;/p &gt;
            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setCount(count + 1)}&gt;Click<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    );
};
</span></code></pre>
<ol start="3">
<li>生命周期：函数组件无生命周期，不过 useEffect Hook 看做 componentDidMount ， componentDidUpdate 和 componentWillUnmount 这三个函数的组合</li>
</ol>
<pre><code class="language-js"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
	 <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>) <span class="hljs-comment">//useEffect第二个参数设为空数组，那么就没有依赖，就只改变一次，否则会一直重复设置timer</span>
	 <span class="hljs-comment">// 而实际上timer只要自己执行一次，后面就每隔一秒自动setDate就好了，如果没有设置好依赖项，</span>
	 <span class="hljs-comment">//每隔一秒都会执行一次console.log(2)，然后再执行生成一个timer，这是完全没有必要的</span>
	 <span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
	 <span class="hljs-title function_">setDate</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());
	 }, <span class="hljs-number">1000</span>);
	 <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearInterval</span>(timer);<span class="hljs-comment">//组件卸载的时候执行，这个return函数相当于 componentWillUnmount</span>
	 }, []);<span class="hljs-comment">// 第二个参数是依赖更新项，相当于 componentDidUpdate</span>
</code></pre>
<h4 id="类组件的this绑定">类组件的this绑定</h4>
<pre><code class="language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">IndexPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span>{
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) {
    <span class="hljs-variable language_">super</span>(props)

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">event1</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">event1</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-number">1</span>);
  }

  <span class="hljs-title function_">event1</span>(<span class="hljs-params">a, e</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;event1&#x27;</span>, a, e);    <span class="hljs-comment">// 1 {}</span>
  }
  <span class="hljs-title function_">event2</span>(<span class="hljs-params">a, e</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;event2&#x27;</span>, a, e);    <span class="hljs-comment">// 2 {}</span>
  }
  <span class="hljs-title function_">event3</span>(<span class="hljs-params">a, e</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;event3&#x27;</span>, a, e);    <span class="hljs-comment">// 3 {}</span>
  }
  event4 = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;event4&#x27;</span>, e);       <span class="hljs-comment">// {}</span>
  }
  <span class="hljs-comment">// fun = this.event1 =&gt; fun() =&gt; this隐式丢失指向window</span>
  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> (
      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{</span> <span class="hljs-attr">this.event1</span> }&gt;</span>event1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{</span> (<span class="hljs-attr">e</span>) =&gt;</span> { this.event2(2, e) } }&gt;event2<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{</span> <span class="hljs-attr">this.event3.bind</span>(<span class="hljs-attr">this</span>, <span class="hljs-attr">3</span>) }&gt;</span>event3<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{</span> <span class="hljs-attr">this.event4</span> }&gt;</span>event4<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    );
  }
}
</code></pre>
<h3 id="react受控组件和非受控组件">react受控组件和非受控组件</h3>
<ul>
<li>受控组件，简单来讲，就是受控制的组件，组件的状态<strong>全程响应外部数据</strong></li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> {
  <span class="hljs-title function_">constructor</span> (props) {
    <span class="hljs-variable language_">super</span>(props);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = { <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;lindaidai&#x27;</span> };
  }
  render () {
    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{this.state.username}</span> /&gt;</span></span>
  }
}
</code></pre>
<p>在输入框输入内容的时候，会发现输入的内容并无法显示出来，也就是input标签是一个可读的状态</p>
<p>这是因为value被<code>this.state.username</code>所控制住。当用户输入新的内容时，this.state.username并不会自动更新，这样的话input内的内容也就不会变了</p>
<p>如果想要解除被控制，可以为input标签设置<code>onChange</code>事件，输入的时候触发事件函数，在函数内部实现state的更新，从而导致input框的内容页发现改变</p>
<p>因此，受控组件一般需要<strong>初始状态</strong>和一个<strong>状态更新事件</strong>函数</p>
<ul>
<li>非受控组件，简单来讲，就是不受我们控制的组件，一般情况是在初始化的时候接受<code>外部数据</code>，然后自己在<code>内部存储其自身状态</code>，当需要时，可以使用 ref 查询 DOM并查找其当前值：</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { <span class="hljs-title class_">Component</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnControll</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> {
  <span class="hljs-title function_">constructor</span> (props) {
    <span class="hljs-variable language_">super</span>(props);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputRef</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createRef</span>();
  }
  handleSubmit = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;我们可以获得input内的值为&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputRef</span>.<span class="hljs-property">current</span>.<span class="hljs-property">value</span>);
    e.<span class="hljs-title function_">preventDefault</span>();
  }
  render () {
    <span class="hljs-keyword">return</span> (
      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">{e</span> =&gt;</span> this.handleSubmit(e)}&gt;
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">defaultValue</span>=<span class="hljs-string">&quot;lindaidai&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{this.inputRef}</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span> /&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span>
    )
  }
}
</code></pre>
<p>大部分时候推荐使用受控组件来实现表单，因为在受控组件中，表单数据由React组件负责处理</p>
<p>如果选择非受控组件的话，控制能力较弱，表单数据就由DOM本身处理，但更加方便快捷，代码量少</p>
<p><img src="file:///e:\studying\book_files\72.jpg" alt="受控"></p>
<h3 id="react事件机制">react事件机制</h3>
<p>React基于浏览器的事件机制自身实现了一套事件机制，包括事件注册、事件的合成、事件冒泡、事件派发等</p>
<p>在React中这套事件机制被称之为<code>合成事件</code></p>
<p>合成事件是 React模拟原生 DOM事件所有能力的一个事件对象，即浏览器原生事件的跨浏览器包装器</p>
<p>根据 W3C规范来定义合成事件，兼容所有浏览器，拥有与浏览器原生事件相同的接口，例如：</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> button = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleClick}</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
</code></pre>
<p>如果想要获得原生DOM事件，可以通过<strong>e.nativeEvent</strong>属性获取</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">handleClick</span> = (<span class="hljs-params">e</span>) =&gt; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">nativeEvent</span>);;
<span class="hljs-keyword">const</span> button = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleClick}</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
</code></pre>
<p>虽然onclick看似绑定到DOM元素上，但实际并不会把事件代理函数直接绑定到真实的节点上，而是把所有的事件绑定到结构的最外层，使用一个统一的事件去监听</p>
<p>这个事件监听器上维持了一个映射来保存所有组件内部的事件监听和处理函数。当组件挂载或卸载时，只是在这个统一的事件监听器上插入或删除一些对象</p>
<p>当事件发生时，首先被这个统一的事件监听器处理，然后在映射里找到真正的事件处理函数并调用。这样做简化了事件处理和回收机制，效率也有很大提升</p>
<p>关于React合成事件与原生事件执行顺序，可以看看下面一个例子</p>
<pre><code class="language-js"><span class="hljs-keyword">import</span>  <span class="hljs-title class_">React</span>  <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span>{

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) {
    <span class="hljs-variable language_">super</span>(props);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">parentRef</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createRef</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">childRef</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createRef</span>();
  }
  <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;React componentDidMount！&quot;</span>);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">parentRef</span>.<span class="hljs-property">current</span>?.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;原生事件：父元素 DOM 事件监听！&quot;</span>);
    });
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">childRef</span>.<span class="hljs-property">current</span>?.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function">() =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;原生事件：子元素 DOM 事件监听！&quot;</span>);
    });
    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;原生事件：document DOM 事件监听！&quot;</span>);
    });
  }
  parentClickFun = <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;React 事件：父元素事件监听！&quot;</span>);
  };
  childClickFun = <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;React 事件：子元素事件监听！&quot;</span>);
  };
  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> (
      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{this.parentRef}</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.parentClickFun}</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{this.childRef}</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.childClickFun}</span>&gt;</span>
          分析事件执行顺序
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    );
  }
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;
</code></pre>
<pre><code>原生事件：子元素 DOM 事件监听！ 
原生事件：父元素 DOM 事件监听！ 
React 事件：子元素事件监听！ 
React 事件：父元素事件监听！ 
原生事件：document DOM 事件监听！ 
</code></pre>
<pre><code>React 所有事件都挂载在 document 对象上
当真实 DOM 元素触发事件，会冒泡到 document 对象后，再处理 React 事件
所以会先执行原生事件，然后处理 React 事件
最后真正执行 document 上挂载的事件
</code></pre>
<p><img src="file:///e:\studying\book_files\73.jpg" alt="react事件"></p>
<p>所以想要阻止不同时间段的冒泡行为，对应使用不同的方法，对应如下：</p>
<p>阻止合成事件间的冒泡，用e.stopPropagation()</p>
<p>阻止合成事件与最外层 document 上的事件间的冒泡，用e.nativeEvent.stopImmediatePropagation()</p>
<p>阻止合成事件与除最外层document上的原生事件上的冒泡，通过判断e.target来避免</p>
<pre><code class="language-js"><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {   
    <span class="hljs-keyword">if</span> (e.<span class="hljs-property">target</span> &amp;&amp; e.<span class="hljs-property">target</span>.<span class="hljs-title function_">matches</span>(<span class="hljs-string">&#x27;div.code&#x27;</span>)) {  
        <span class="hljs-keyword">return</span>;    
    }    
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({   <span class="hljs-attr">active</span>: <span class="hljs-literal">false</span>,    });   }); 
}
</code></pre>
<h3 id="react构建组件方式">react构建组件方式</h3>
<ul>
<li>函数式创建</li>
<li>通过 React.createClass 方法创建</li>
<li>继承 React.Component 创建</li>
</ul>
<pre><code class="language-js"><span class="hljs-comment">// 已不推荐</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">HelloComponent</span>(<span class="hljs-params">props</span>) <span class="hljs-comment">/* context */</span>{
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(
    <span class="hljs-string">&quot;div&quot;</span>,
    <span class="hljs-literal">null</span>,
    <span class="hljs-string">&quot;Hello &quot;</span>,
    props.<span class="hljs-property">name</span>
  );
}
</code></pre>
<h3 id="react生命周期">react生命周期</h3>
<p>React整个组件生命周期包括从创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程</p>
<p>react16.4之后</p>
<ul>
<li>创建阶段
<ul>
<li>constructor</li>
<li>getDerivedStateFromProps：该方法是新增的生命周期方法，是一个<code>静态方法</code>，因此不能访问到组件的实例；执行时机：<code>组件创建和更新阶段</code>，不论是props变化还是state变化，也会调用。在每次render方法前调用，第一个参数为即将更新的props，第二个参数为上一个状态的state，可以比较props 和 state来加一些限制条件，防止无用的state更新。该方法需要返回一个新的对象作为<code>新的state</code>或者<code>返回null表示state状态不需要更新</code></li>
<li>render</li>
<li>componentDidMount：组件挂载到真实DOM节点后执行，其在render方法之后执行</li>
</ul>
</li>
<li>更新阶段
<ul>
<li>getDerivedStateFromProps</li>
<li>shouldComponentUpdate:用于告知组件本身基于当前的props和state是否需要重新渲染组件，默认情况返回true.执行时机：到新的props或者state时都会调用，通过返回true或者false告知组件更新与否,一般情况，不建议在该周期方法中进行深层比较，会影响效率,同时也不能调用setState，否则会导致无限循环调用更新</li>
<li>render</li>
<li>getSnapshotBeforeUpdate:该周期函数在render后执行，执行之时DOM元素还没有被更新,此方法的目的在于获取组件更新前的一些信息，比如组件的滚动位置之类的，在组件更新后可以根据这些信息恢复一些UI视觉上的状态</li>
<li>componentDidUpdate</li>
</ul>
</li>
<li>卸载阶段
<ul>
<li>componentWillUnmount</li>
</ul>
</li>
</ul>
<p><img src="file:///e:\studying\book_files\74.jpg" alt="生命周期"></p>
<p>旧版生命周期</p>
<p><img src="file:///e:\studying\book_files\75.jpg" alt="旧版"></p>
<pre><code class="language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> {  
  <span class="hljs-keyword">static</span> <span class="hljs-title function_">getDerivedStateFromProps</span>(<span class="hljs-params">nextProps, prevState</span>) {  
    <span class="hljs-comment">// 不能使用 this.state 或 this.props  </span>
    <span class="hljs-comment">// 只能使用 nextProps 和 prevState  </span>
    <span class="hljs-keyword">if</span> (nextProps.<span class="hljs-property">someProp</span> !== prevState.<span class="hljs-property">someProp</span>) {  
      <span class="hljs-keyword">return</span> { <span class="hljs-attr">someProp</span>: nextProps.<span class="hljs-property">someProp</span> };  
    }  
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  
  }  
  
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) {  
    <span class="hljs-variable language_">super</span>(props);  
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = { <span class="hljs-attr">someProp</span>: props.<span class="hljs-property">someProp</span> };  
  }  
  
  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {  
    <span class="hljs-comment">// ...  </span>
  }  
}
</code></pre>
<h3 id="react组件间通信">react组件间通信</h3>
<ul>
<li>父组件向子组件传递</li>
<li>子组件向父组件传递</li>
<li>兄弟组件之间的通信</li>
<li>父组件向后代组件传递: React.createContext() || useContext ,Context 提供了一种在组件之间共享值而无需显式地通过每一层组件传递 props 的方式</li>
<li>非关系组件传递：redux</li>
</ul>
<pre><code class="language-js"><span class="hljs-comment">// 兄弟组件借助父组件为中间层</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) {
    <span class="hljs-variable language_">super</span>(props)
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = {<span class="hljs-attr">count</span>: <span class="hljs-number">0</span>}
  }
  setCount = <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({<span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span>})
  }
  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> (
      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">SiblingA</span>
          <span class="hljs-attr">count</span>=<span class="hljs-string">{this.state.count}</span>
        /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">SiblingB</span>
          <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.setCount}</span>
        /&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    );
  }
}
</code></pre>
<h4 id="context类组件和函数组件的使用">context类组件和函数组件的使用</h4>
<ul>
<li>React.createContext</li>
<li>xxx.Provider</li>
<li>xxx.Consumer</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>,{<span class="hljs-title class_">Component</span>} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>
<span class="hljs-keyword">import</span> <span class="hljs-variable constant_">P1</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./P1.js&#x27;</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">MyContext</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createContext</span>();
  
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">G1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span>{
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>){
        <span class="hljs-variable language_">super</span>(props)
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> ={<span class="hljs-attr">val</span>:<span class="hljs-number">10</span>}
    }
    <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>){
        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
            <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({<span class="hljs-attr">val</span>:<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">val</span>+<span class="hljs-number">1</span>})
        }, <span class="hljs-number">2000</span>);
    }
    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>){
        <span class="hljs-keyword">return</span> (<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">MyContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{this.state.val}</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">P1</span>/&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">MyContext.Provider</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>)
    }
}
</code></pre>
<pre><code class="language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>,{<span class="hljs-title class_">Component</span>} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>
<span class="hljs-keyword">import</span> <span class="hljs-variable constant_">C1</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./C1.js&#x27;</span>
<span class="hljs-keyword">import</span> <span class="hljs-variable constant_">C2</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./C2.js&#x27;</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">P1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span>{
    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>){
        <span class="hljs-keyword">return</span> (<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">C1</span> /&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">C2</span>/&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>)
    }
 
}
</code></pre>
<pre><code class="language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>,{<span class="hljs-title class_">Component</span>} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">MyContext</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./G1&#x27;</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">C1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span>{
    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>){
        <span class="hljs-keyword">return</span> (<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">MyContext.Consumer</span>&gt;</span>  
                {value =&gt; <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{value}222<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>}
            <span class="hljs-tag">&lt;/<span class="hljs-name">MyContext.Consumer</span>&gt;</span>  
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>)
    }

}
</code></pre>
<pre><code class="language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { useContext } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;  
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">MyContext</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./G1&#x27;</span>
  
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">C2</span>(<span class="hljs-params"></span>) {  
  <span class="hljs-keyword">const</span> value = <span class="hljs-title function_">useContext</span>(<span class="hljs-title class_">MyContext</span>);  
  <span class="hljs-comment">// 使用 value 来渲染组件  </span>
  <span class="hljs-keyword">return</span> value;  
}
</code></pre>
<h3 id="react高阶组件的理解和应用">react高阶组件的理解和应用</h3>
<p>在React中，高阶组件即接受一个或多个组件作为参数并且返回一个组件，本质也就是一个函数，并不是一个组件</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">EnhancedComponent</span> = <span class="hljs-title function_">highOrderComponent</span>(<span class="hljs-title class_">WrappedComponent</span>);
</code></pre>
<p>上述代码中，该函数接受一个组件WrappedComponent作为参数，返回加工过的新组件EnhancedComponent</p>
<p>高阶组件的这种实现方式，本质上是一个<strong>装饰者设计模式</strong></p>
<h4 id="高阶函数">高阶函数</h4>
<p>JavaScript中的高阶函数是指那些操作其他函数的函数。换句话说，<strong>高阶函数可以接受函数作为参数，或者返回一个函数作为结果。</strong></p>
<p>高阶函数在JavaScript编程中非常有用，因为它们允许我们创建更加通用和可重用的代码。通过高阶函数，我们可以将函数作为参数传递给其他函数，从而在不同的上下文中执行相同的操作。同时，高阶函数也可以返回新的函数，这些函数可以根据需要定制行为。</p>
<p>常见的JavaScript高阶函数包括map()、filter()、reduce()等数组方法，以及setTimeout()、setInterval()等异步操作函数。这些函数都接受一个或多个函数作为参数，并在内部执行这些函数。</p>
<h4 id="高阶组件">高阶组件</h4>
<pre><code class="language-js"><span class="hljs-comment">//最基本的高阶组件的编写模板</span>
<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { <span class="hljs-title class_">Component</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (<span class="hljs-title class_">WrappedComponent</span>) =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EnhancedComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> {
    <span class="hljs-comment">// do something</span>
    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {
      <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">WrappedComponent</span> /&gt;</span></span>;
    }
  }
}
</code></pre>
<p>通过对传入的原始组件 WrappedComponent 做一些你想要的操作（比如操作 props，提取 state，给原始组件包裹其他元素等），从而加工出想要的组件 EnhancedComponent</p>
<p>把通用的逻辑放在高阶组件中，对组件实现一致的处理，从而实现代码的复用</p>
<p>所以，高阶组件的主要功能是<strong>封装并分离组件的通用逻辑</strong>，让通用逻辑在组件间更好地被复用</p>
<h4 id="高阶组件的应用场景">高阶组件的应用场景</h4>
<p>高阶组件能够提高代码的复用性和灵活性，在实际应用中，常常用于与核心业务无关但又在多个模块使用的功能，如权限控制、日志记录、数据校验、异常处理、统计上报等</p>
<pre><code class="language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { <span class="hljs-title class_">Component</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">withPersistentData</span>(<span class="hljs-params">WrappedComponent</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> <span class="hljs-title class_">Component</span> {
    <span class="hljs-title function_">componentWillMount</span>(<span class="hljs-params"></span>) {
      <span class="hljs-keyword">let</span> data = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;data&#x27;</span>);
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({data});
    }
    
    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {
      <span class="hljs-comment">// 通过{...this.props} 把传递给当前组件的属性继续传递给被包装的组件WrappedComponent</span>
      <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">WrappedComponent</span> <span class="hljs-attr">data</span>=<span class="hljs-string">{this.state.data}</span> {<span class="hljs-attr">...this.props</span>} /&gt;</span></span>
    }
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyComponent2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> {  
  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{this.props.data}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  }
}

<span class="hljs-keyword">const</span> <span class="hljs-title class_">MyComponentWithPersistentData</span> = <span class="hljs-title function_">withPersistentData</span>(<span class="hljs-title class_">MyComponent2</span>)
</code></pre>
<h3 id="react过渡动画">react过渡动画</h3>
<p>在react中实现过渡动画效果会有很多种选择，如react-transition-group，react-motion，Animated，以及原生的CSS都能完成切换动画</p>
<h4 id="react-transition-group">react-transition-group</h4>
<p>在react中，react-transition-group是一种很好的解决方案，其为元素添加<code>enter，enter-active，exit，exit-active</code>这一系列勾子</p>
<p>可以帮助我们方便的实现组件的入场和离场动画</p>
<p>其主要提供了三个主要的组件：</p>
<ul>
<li>CSSTransition：在前端开发中，结合 CSS 来完成过渡动画效果</li>
<li>SwitchTransition：两个组件显示和隐藏切换时，使用该组件</li>
<li>TransitionGroup：将多个动画组件包裹在其中，一般用于列表中元素的动画</li>
</ul>
<ol>
<li>CSSTransition</li>
</ol>
<p>其实现动画的原理在于，当CSSTransition的in属性置为true时，CSSTransition首先会给其子组件加上xxx-enter、xxx-enter-active的class执行动画</p>
<p>当动画执行结束后，会移除两个class，并且添加-enter-done的class</p>
<p>所以可以利用这一点，通过css的transition属性，让元素在两个状态之间平滑过渡，从而得到相应的动画效果</p>
<p>当in属性置为false时，CSSTransition会给子组件加上xxx-exit和xxx-exit-active的class，然后开始执行动画，当动画结束后，移除两个class，然后添加-enter-done的class</p>
<pre><code class="language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./test.css&#x27;</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">CSSTransition</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-transition-group&#x27;</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.PureComponent</span> {

  state = {<span class="hljs-attr">show</span>: <span class="hljs-literal">true</span>};

  onToggle = <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({<span class="hljs-attr">show</span>: !<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">show</span>});

  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> {show} = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>;
    <span class="hljs-keyword">return</span> (
      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{</span>&#x27;<span class="hljs-attr">container</span>&#x27;}&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{</span>&#x27;<span class="hljs-attr">square-wrapper</span>&#x27;}&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">CSSTransition</span>
            <span class="hljs-attr">in</span>=<span class="hljs-string">{show}</span>
            <span class="hljs-attr">timeout</span>=<span class="hljs-string">{500}</span>
            <span class="hljs-attr">classNames</span>=<span class="hljs-string">{</span>&#x27;<span class="hljs-attr">fade</span>&#x27;}
            <span class="hljs-attr">unmountOnExit</span>=<span class="hljs-string">{true}</span>
          &gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>12345<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
          <span class="hljs-tag">&lt;/<span class="hljs-name">CSSTransition</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.onToggle}</span>&gt;</span>toggle<span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    );
  }
}
</code></pre>
<pre><code class="language-css"><span class="hljs-selector-class">.fade-enter</span> {
  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">100%</span>);
}

<span class="hljs-selector-class">.fade-enter-active</span> {
  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;
  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">0</span>);
  <span class="hljs-attribute">transition</span>: all <span class="hljs-number">500ms</span>;
}

<span class="hljs-selector-class">.fade-exit</span> {
  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;
  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">0</span>);
}

<span class="hljs-selector-class">.fade-exit-active</span> {
  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(-<span class="hljs-number">100%</span>);
  <span class="hljs-attribute">transition</span>: all <span class="hljs-number">500ms</span>;
}
</code></pre>
<ol start="2">
<li>SwitchTransition可以完成两个组件之间切换的炫酷动画</li>
</ol>
<p>比如有一个按钮需要在on和off之间切换，我们希望看到on先从左侧退出，off再从右侧进入</p>
<p>SwitchTransition中主要有一个属性mode，对应两个值：</p>
<ul>
<li>in-out：表示新组件先进入，旧组件再移除；</li>
<li>out-in：表示就组件先移除，新组建再进入</li>
<li>SwitchTransition组件里面要有CSSTransition，不能直接包裹想要切换的组件</li>
<li>里面的CSSTransition组件不再像以前那样接受in属性来判断元素是何种状态，取而代之的是key属性</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./test.css&#x27;</span>

<span class="hljs-keyword">import</span> { <span class="hljs-title class_">SwitchTransition</span>, <span class="hljs-title class_">CSSTransition</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-transition-group&quot;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SwitchAnimation</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.PureComponent</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) {
    <span class="hljs-variable language_">super</span>(props);

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = {
      <span class="hljs-attr">isOn</span>: <span class="hljs-literal">true</span>
    }
  }

  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> {isOn} = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>;

    <span class="hljs-keyword">return</span> (
      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">SwitchTransition</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;in-out&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">CSSTransition</span> <span class="hljs-attr">classNames</span>=<span class="hljs-string">&quot;btn&quot;</span>
                       <span class="hljs-attr">timeout</span>=<span class="hljs-string">{500}</span>
                       <span class="hljs-attr">key</span>=<span class="hljs-string">{isOn</span> ? &quot;<span class="hljs-attr">on1</span>&quot; <span class="hljs-attr">:</span> &quot;<span class="hljs-attr">off1</span>&quot;}&gt;</span>
          {
          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.btnClick.bind(this)}</span>&gt;</span>
            {isOn ? &quot;on1&quot;: &quot;off1&quot;}
          <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        }
        <span class="hljs-tag">&lt;/<span class="hljs-name">CSSTransition</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">SwitchTransition</span>&gt;</span></span>
    )
  }

  <span class="hljs-title function_">btnClick</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({<span class="hljs-attr">isOn</span>: !<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">isOn</span>})
  }
}
</code></pre>
<pre><code class="language-css"><span class="hljs-selector-class">.btn-enter</span> {
  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">100%</span>, <span class="hljs-number">0</span>);
  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;
}

<span class="hljs-selector-class">.btn-enter-active</span> {
  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;
  <span class="hljs-attribute">transition</span>: all <span class="hljs-number">500ms</span>;
}

<span class="hljs-selector-class">.btn-exit</span> {
  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;
}

<span class="hljs-selector-class">.btn-exit-active</span> {
  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">100%</span>, <span class="hljs-number">0</span>);
  <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">transition</span>: all <span class="hljs-number">500ms</span>;
}
</code></pre>
<ol start="3">
<li>TransitionGroup</li>
</ol>
<p>当有一组动画的时候，就可将这些CSSTransition放入到一个TransitionGroup中来完成动画</p>
<p>同样CSSTransition里面没有in属性，用到了key属性</p>
<p>TransitionGroup在感知children发生变化的时候，先保存移除的节点，当动画结束后才真正移除</p>
<p>其处理方式如下：</p>
<ul>
<li>插入的节点，先渲染dom，然后再做动画</li>
<li>删除的节点，先做动画，然后再删除dom</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./test.css&#x27;</span>

<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { <span class="hljs-title class_">PureComponent</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">CSSTransition</span>, <span class="hljs-title class_">TransitionGroup</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-transition-group&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GroupAnimation</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">PureComponent</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) {
    <span class="hljs-variable language_">super</span>(props);

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = {
      <span class="hljs-attr">friends</span>: []
    }
  }

  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> (
      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">TransitionGroup</span>&gt;</span>
          {
            this.state.friends.map((item, index) =&gt; {
              return (
                <span class="hljs-tag">&lt;<span class="hljs-name">CSSTransition</span> <span class="hljs-attr">classNames</span>=<span class="hljs-string">&quot;friend&quot;</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">{300}</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{index}</span>&gt;</span>
                  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{item}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-name">CSSTransition</span>&gt;</span>
              )
            })
          }
        <span class="hljs-tag">&lt;/<span class="hljs-name">TransitionGroup</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{e</span> =&gt;</span> this.addFriend()}&gt;+friend<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    )
  }

  <span class="hljs-title function_">addFriend</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({
      <span class="hljs-attr">friends</span>: [...<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">friends</span>, <span class="hljs-string">&quot;coderwhy&quot;</span>]
    })
  }
}
</code></pre>
<pre><code class="language-css"><span class="hljs-selector-class">.friend-enter</span> {
    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">100%</span>, <span class="hljs-number">0</span>);
    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;
}

<span class="hljs-selector-class">.friend-enter-active</span> {
    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;
    <span class="hljs-attribute">transition</span>: all <span class="hljs-number">500ms</span>;
}

<span class="hljs-selector-class">.friend-exit</span> {
    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">1</span>;
}

<span class="hljs-selector-class">.friend-exit-active</span> {
    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">100%</span>, <span class="hljs-number">0</span>);
    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;
    <span class="hljs-attribute">transition</span>: all <span class="hljs-number">500ms</span>;
}
</code></pre>
<h3 id="react捕获错误">react捕获错误</h3>
<pre><code class="language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ErrorBoundary</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) {
    <span class="hljs-variable language_">super</span>(props);
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = { <span class="hljs-attr">hasError</span>: <span class="hljs-literal">false</span> };
  }

  <span class="hljs-keyword">static</span> <span class="hljs-title function_">getDerivedStateFromError</span>(<span class="hljs-params">error</span>) {
    <span class="hljs-comment">// 更新 state 使下一次渲染能够显示降级后的 UI</span>
    <span class="hljs-keyword">return</span> { <span class="hljs-attr">hasError</span>: <span class="hljs-literal">true</span> };
  }

  <span class="hljs-title function_">componentDidCatch</span>(<span class="hljs-params">error, errorInfo</span>) {
    <span class="hljs-comment">// 你同样可以将错误日志上报给服务器</span>
    <span class="hljs-title function_">logErrorToMyService</span>(error, errorInfo);
  }

  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">hasError</span>) {
      <span class="hljs-comment">// 你可以自定义降级后的 UI 并渲染</span>
      <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Something went wrong.<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">children</span>; 
  }
}
</code></pre>
<p>下面这些情况无法捕获到异常：</p>
<ul>
<li>事件处理</li>
<li>异步代码</li>
<li>服务端渲染</li>
<li>自身抛出来的错误</li>
</ul>
<p>在react 16版本之后，会把渲染期间发生的所有错误打印到控制台.</p>
<p>可以利用trycatch或者window.addEventListener('error', function(event) { ... })去处理</p>
<h3 id="对react-refs-的理解应用场景">对React refs 的理解，应用场景</h3>
<p>React 中的 Refs提供了一种方式，允许我们访问 DOM节点或在 render方法中创建的 React元素</p>
<p>本质为<code>ReactDOM.render()返回的组件实例</code>，如果是渲染组件则返回的是组件实例，如果渲染dom则返回的是具体的dom节点</p>
<ul>
<li><s>传入字符串，使用时通过 this.refs.传入的字符串的格式获取对应的元素(弃用)</s></li>
<li>传入对象，对象是通过 React.createRef() 方式创建出来，使用时获取到创建的对象中存在 <strong>current</strong> 属性就是对应的元素</li>
<li>传入函数，该函数会在 DOM 被挂载时进行回调，这个函数会传入一个 元素对象，可以自己保存，使用时，直接拿到之前保存的元素对象即可</li>
<li>传入hook，hook是通过 useRef() 方式创建，使用时通过生成hook对象的 current 属性就是对应的元素</li>
</ul>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span>	<span class="hljs-attr">ref</span>=<span class="hljs-string">&#x27;k&#x27;</span>/&gt;</span>
<span class="hljs-comment">&lt;!-- 废弃 --&gt;</span>
</code></pre>
<pre><code class="language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { <span class="hljs-title class_">Component</span>, createRef } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;  
  
<span class="hljs-comment">// 类组件  </span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClassComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> {  
  <span class="hljs-title function_">myMethod</span>(<span class="hljs-params"></span>) {  
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;My method was called!&#x27;</span>);  
    <span class="hljs-comment">// 这里可以执行其他逻辑  </span>
  }  
  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {  
    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>This is a class component<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;  
  }  
}  
  
<span class="hljs-comment">// 父组件  </span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ParentComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> {  
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) {  
    <span class="hljs-variable language_">super</span>(props);  
    <span class="hljs-comment">// 创建一个 ref  </span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">myClassComponentRef</span> = <span class="hljs-title function_">createRef</span>();  
  }  
  
  <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) {  
    <span class="hljs-comment">// 通过 ref 访问类组件实例，并调用其方法  </span>
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">myClassComponentRef</span>.<span class="hljs-property">current</span>.<span class="hljs-title function_">myMethod</span>();  
  }  
  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {  
    <span class="hljs-keyword">return</span> (  
      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>  
        <span class="hljs-tag">&lt;<span class="hljs-name">MyClassComponent</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{this.myClassComponentRef}</span> /&gt;</span>  
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  
    );  
  }  
}  
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">ParentComponent</span>;
</code></pre>
<pre><code class="language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { <span class="hljs-title class_">PureComponent</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">PureComponent</span> {
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) {
        <span class="hljs-variable language_">super</span>(props)
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">titleRef</span> = <span class="hljs-literal">null</span>     <span class="hljs-comment">// 定义一个初始值</span>
    }
    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">return</span> (
            <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{arg</span> =&gt;</span> this.titleRef = arg}&gt;Hello,React<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{e</span> =&gt;</span> this.changeText()}&gt;函数改变文本<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
        );
    }
    <span class="hljs-title function_">changeText</span>(<span class="hljs-params"></span>) {
        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">titleRef</span>)
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">titleRef</span>.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&quot;Hello&quot;</span>
    }
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;
</code></pre>
<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params">props</span>) {
  <span class="hljs-keyword">const</span> myref = <span class="hljs-title function_">useRef</span>()
  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{myref}</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/&gt;</span></span>
  )
}
</code></pre>
<h4 id="应用场景-1">应用场景</h4>
<p>过多使用refs，会使组件的实例或者是DOM结构暴露，违反组件封装的原则</p>
<p>例如，避免在 Dialog 组件里暴露 open() 和 close() 方法，最好传递 isOpen 属性</p>
<p>但下面的场景使用refs非常有用：</p>
<ul>
<li>对Dom元素的焦点控制、内容选择、控制</li>
<li>对Dom元素的内容设置及媒体播放</li>
<li>对Dom元素的操作和对组件实例的操作</li>
<li>集成第三方 DOM 库</li>
</ul>
<h3 id="setstate执行机制">setState执行机制</h3>
<p>一个组件的显示形态可以由数据状态和外部参数所决定，而数据状态就是state</p>
<p>当需要修改里面的值的状态需要通过调用setState来改变，从而达到更新组件内部数据的作用</p>
<pre><code class="language-js"><span class="hljs-title function_">changeText</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">message</span> = <span class="hljs-string">&quot;你好啊,李银河&quot;</span>;
}<span class="hljs-comment">// 无作用</span>
</code></pre>
<p>会发现页面并不会有任何反应，但是state的状态是已经发生了改变，这是因为React并不像vue2中调用Object.defineProperty数据响应式或者Vue3调用Proxy监听数据的变化</p>
<p>必须通过<strong>setState</strong>方法来告知react组件state已经发生了改变</p>
<pre><code class="language-js"><span class="hljs-title class_">Component</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">setState</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">partialState, callback</span>) {
  <span class="hljs-title function_">invariant</span>(
    <span class="hljs-keyword">typeof</span> partialState === <span class="hljs-string">&#x27;object&#x27;</span> ||
      <span class="hljs-keyword">typeof</span> partialState === <span class="hljs-string">&#x27;function&#x27;</span> ||
      partialState == <span class="hljs-literal">null</span>,
    <span class="hljs-string">&#x27;setState(...): takes an object of state variables to update or a &#x27;</span> +
      <span class="hljs-string">&#x27;function which returns an object of state variables.&#x27;</span>,
  );
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">updater</span>.<span class="hljs-title function_">enqueueSetState</span>(<span class="hljs-variable language_">this</span>, partialState, callback, <span class="hljs-string">&#x27;setState&#x27;</span>);
};
</code></pre>
<p>可以看到setState第一个参数可以是一个对象，或者是一个函数，而第二个参数是一个回调函数，用于可以实时的获取到更新之后的数据</p>
<h4 id="setstate更新类型">setState更新类型</h4>
<ul>
<li>异步更新</li>
</ul>
<pre><code class="language-js"><span class="hljs-title function_">changeText</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({
    <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;你好啊&quot;</span>
  })
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">message</span>); <span class="hljs-comment">// Hello World</span>
}
<span class="hljs-comment">//最终打印结果为Hello world，并不能在执行完setState之后立马拿到最新的state的结果</span>
</code></pre>
<p>如果想要立刻获取更新后的值，在第二个参数的回调中更新后会执行</p>
<pre><code class="language-js"><span class="hljs-title function_">changeText</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({
    <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;你好啊&quot;</span>
  }, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">message</span>); <span class="hljs-comment">// 你好啊</span>
  });
}
</code></pre>
<ul>
<li>同步更新</li>
</ul>
<pre><code class="language-js"><span class="hljs-title function_">changeText</span>(<span class="hljs-params"></span>) {
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({
      <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;你好啊
    });
    console.log(this.state.message); // 你好啊
  }, 0);
}
</span></code></pre>
<pre><code class="language-js"><span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> btnEl = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;btn&quot;</span>);
  btnEl.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({
      <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;你好啊,李银河&quot;</span>
    });
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">message</span>); <span class="hljs-comment">// 你好啊,李银河</span>
  })
}
</code></pre>
<ul>
<li>在<strong>组件生命周期或React合成事件</strong>中，setState是异步</li>
<li>在<strong>setTimeout或者原生dom事件</strong>中，setState是同步</li>
</ul>
<h4 id="批量更新">批量更新</h4>
<pre><code class="language-js">handleClick = <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({
        <span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span>,
    })
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span>) <span class="hljs-comment">// 1</span>

    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({
        <span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span>,
    })
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span>) <span class="hljs-comment">// 1</span>

    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({
        <span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span>,
    })
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span>) <span class="hljs-comment">// 1</span>
}
</code></pre>
<p>点击按钮触发事件，打印的都是 1，页面显示 count 的值为 2</p>
<p>对同一个值进行多次 setState， setState 的批量更新策略会对其进行覆盖，取最后一次的执行结果,上述的例子，实际等价于如下：</p>
<pre><code class="language-js"><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(
  previousState,
  {<span class="hljs-attr">index</span>: state.<span class="hljs-property">count</span>+ <span class="hljs-number">1</span>},
  {<span class="hljs-attr">index</span>: state.<span class="hljs-property">count</span>+ <span class="hljs-number">1</span>},
  ...
)
</code></pre>
<p>如果是下一个state依赖前一个state的话，推荐给setState一个参数传入一个function</p>
<pre><code class="language-js">onClick = <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<span class="hljs-function">(<span class="hljs-params">prevState, props</span>) =&gt;</span> {
      <span class="hljs-keyword">return</span> {<span class="hljs-attr">count</span>: prevState.<span class="hljs-property">count</span> + <span class="hljs-number">1</span>};
    });
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(<span class="hljs-function">(<span class="hljs-params">prevState, props</span>) =&gt;</span> {
      <span class="hljs-keyword">return</span> {<span class="hljs-attr">count</span>: prevState.<span class="hljs-property">count</span> + <span class="hljs-number">1</span>};
    });
}
</code></pre>
<blockquote>
<p>而在setTimeout或者原生dom事件中，由于是同步的操作，所以并不会进行覆盖现象</p>
</blockquote>
<h3 id="react-render理解">react render理解</h3>
<p>render函数在react中有两种形式</p>
<pre><code class="language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> {
    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span> Foo <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;
    }
}
</code></pre>
<p>在函数组件中，指的是函数组件本身</p>
<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span> Foo <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;
}
</code></pre>
<p>在render中，我们会编写jsx，jsx通过babel编译后就会转化成我们熟悉的js格式</p>
<pre><code class="language-js"><span class="hljs-keyword">return</span> (
  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#x27;cn&#x27;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">Header</span>&gt;</span> hello <span class="hljs-tag">&lt;/<span class="hljs-name">Header</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> start <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    Right Reserve
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
)
</code></pre>
<pre><code class="language-js"><span class="hljs-keyword">return</span> (
  <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(
    <span class="hljs-string">&#x27;div&#x27;</span>,
    {
      className : <span class="hljs-string">&#x27;cn&#x27;</span>
    },
    <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(
      <span class="hljs-title class_">Header</span>,
      <span class="hljs-literal">null</span>,
      <span class="hljs-string">&#x27;hello&#x27;</span>
    ),
    <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(
      <span class="hljs-string">&#x27;div&#x27;</span>,
      <span class="hljs-literal">null</span>,
      <span class="hljs-string">&#x27;start&#x27;</span>
    ),
    <span class="hljs-string">&#x27;Right Reserve&#x27;</span>
  )
)
</code></pre>
<p>在react中，这个元素就是虚拟DOM树的节点，接收三个参数：</p>
<ul>
<li>type：标签</li>
<li>attributes：标签属性，若无则为null</li>
<li>children：标签的子节点</li>
</ul>
<p>这些虚拟DOM树最终会渲染成真实DOM</p>
<p>在render过程中，React 将新调用的 render函数返回的树与旧版本的树进行比较，这一步是决定如何更新 DOM 的必要步骤，然后进行 diff 比较，更新 DOM树</p>
<h4 id="render的触发时机">render的触发时机</h4>
<p>render的执行时机主要分成了两部分：</p>
<ol>
<li>类组件调用 setState 修改状态</li>
</ol>
<pre><code class="language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> {
  state = { <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> };

  increment = <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">const</span> { count } = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>;
    <span class="hljs-keyword">const</span> newCount = count &lt; <span class="hljs-number">10</span> ? count + <span class="hljs-number">1</span> : count;
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({ <span class="hljs-attr">count</span>: newCount });
  };

  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> { count } = <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>;
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Foo render&quot;</span>);
    <span class="hljs-keyword">return</span> (
      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span> {count} <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.increment}</span>&gt;</span>Increment<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    );
  }
}
</code></pre>
<p>点击按钮，则调用setState方法，无论count是否发生变化，控制台都会输出Foo render，证明render执行了</p>
<ol start="2">
<li>函数组件通过useState hook修改状态</li>
</ol>
<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> newCount = count &lt; <span class="hljs-number">10</span> ? count + <span class="hljs-number">1</span> : count;
    <span class="hljs-title function_">setCount</span>(newCount);
  }
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Foo render&quot;</span>);
  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span> {count} <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{increment}</span>&gt;</span>Increment<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
</code></pre>
<p>函数组件通过useState这种形式更新数据，当数组的值不发生改变了，就不会触发render</p>
<p>总结：render函数里面可以编写JSX，转化成createElement这种形式，用于生成虚拟DOM，最终转化成真实DOM；一旦执行了setState就会执行render方法，useState 会判断当前值有无发生改变确定是否执行render方法，<em><strong>一旦父组件发生渲染，子组件也会渲染</strong></em></p>
<h3 id="react中怎样避免子组件无效渲染和减少计算渲染">react中怎样避免子组件无效渲染和减少计算渲染</h3>
<ul>
<li>shouldComponentUpdate，当父组件的更新导致所有子组件都重新渲染，但某些子组件的 props 并未实际改变时；不过不要滥用，会影响性能</li>
<li>16.3引入React.PureComponent(跟shouldComponentUpdate原理基本一致，通过对 props 和 state的浅比较结果来实现)</li>
<li>函数组件中React.memo 是一个高阶组件，它会对组件的 props 进行浅比较，如果 props 没有变化，则不会重新渲染组件。</li>
<li>useMemo:当依赖项变化时采取执行</li>
<li>useCallback</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;  

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">C2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span>{
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>){
    <span class="hljs-variable language_">super</span>(props)
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>)
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> ={<span class="hljs-attr">foo</span>:<span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">foo</span>}
  }
  <span class="hljs-title function_">shouldComponentUpdate</span>(<span class="hljs-params">v1,v2</span>){
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(v1,v2)
    <span class="hljs-keyword">if</span>(v1.<span class="hljs-property">foo</span> === v2.<span class="hljs-property">foo</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
  }
  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>){
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;c2&#x27;</span>)
    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>--{this.props.foo}--<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  }
}
</code></pre>
<pre><code class="language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;  

<span class="hljs-keyword">let</span> <span class="hljs-title class_">MyComponent</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">MyComponent</span>(<span class="hljs-params">{ foo }</span>) {  
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;MyComponent rendered&#x27;</span>);  
  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{foo}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;  
});  
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">MyComponent</span>

  
<span class="hljs-comment">// 当 foo 属性变化时，组件会重新渲染  </span>
<span class="hljs-comment">// 当 foo 属性没有变化时，组件不会重新渲染</span>
</code></pre>
<pre><code class="language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { useMemo } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;  

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">ExpensiveComputationComponent</span>(<span class="hljs-params">{ numbers }</span>) {  
  <span class="hljs-comment">// 使用 useMemo 来缓存计算结果  </span>
  <span class="hljs-keyword">const</span> computedNumbers = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> {  
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;c2usememo&#x27;</span>) <span class="hljs-comment">//父组件变化影响numbers才执行</span>

    <span class="hljs-comment">// 假设这是一个昂贵的计算过程  </span>
    <span class="hljs-keyword">return</span> numbers.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> num * <span class="hljs-number">2</span>);  
  }, [numbers]); <span class="hljs-comment">// 只有在 numbers 数组变化时才会重新计算  </span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;c2&#x27;</span>) <span class="hljs-comment">//父组件变化会执行</span>
  <span class="hljs-keyword">return</span> (  
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>  
      {computedNumbers.map((num, index) =&gt; (  
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{index}</span>&gt;</span>{num}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>  
      ))}  
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  
  );  
}
</code></pre>
<p>使用 useCallback 来记忆 handleClick 函数，这样，即使 ParentComponent 重新渲染，handleClick 的引用也不会改变</p>
<pre><code class="language-js"> <span class="hljs-keyword">const</span> handleClick = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> {  
	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">111</span>) <span class="hljs-comment">// 点击会持续打印</span>
    <span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>); <span class="hljs-comment">//在handleClick的闭包环境中，count的值始终是useCallback首次执行时的count值</span>
  }, []); 
  
  <span class="hljs-comment">// 初始化触发一次</span>
  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ChildComponent</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleClick}</span> /&gt;</span></span>  
</code></pre>
<h3 id="react-jsx转换成真实dom过程">React Jsx转换成真实DOM过程</h3>
<ul>
<li>使用React.createElement或JSX编写React组件，实际上所有的 JSX 代码最后都会转换成React.createElement(...) ，Babel帮助完成了这个转换的过程。</li>
<li>createElement函数对key和ref等特殊的props进行处理，并获取defaultProps对默认props进行赋值，并且对传入的孩子节点进行处理，最终构造成一个虚拟DOM对象</li>
<li>ReactDOM.render将生成好的虚拟DOM渲染到指定容器上，其中采用了批处理、事务等机制并且对特定浏览器进行了性能优化，最终转换为真实DOM</li>
</ul>
<p>jsx</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
  &lt; img src=&quot;avatar.png&quot; className=&quot;profile&quot; /&gt;
  <span class="hljs-tag">&lt;<span class="hljs-name">Hello</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p>babel编译</p>
<pre><code class="language-js"><span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(
  <span class="hljs-string">&quot;div&quot;</span>,
  <span class="hljs-literal">null</span>,
  <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;img&quot;</span>, {
    <span class="hljs-attr">src</span>: <span class="hljs-string">&quot;avatar.png&quot;</span>,
    <span class="hljs-attr">className</span>: <span class="hljs-string">&quot;profile&quot;</span>
  }),
  <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-title class_">Hello</span>, <span class="hljs-literal">null</span>)
);
</code></pre>
<p>React.createElement其被调用时会传入标签类型type，标签属性props及若干子元素children，作用是生成一个虚拟Dom对象</p>
<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-params">type, config, ...children</span>) {
    <span class="hljs-keyword">if</span> (config) {
        <span class="hljs-keyword">delete</span> config.<span class="hljs-property">__self</span>;
        <span class="hljs-keyword">delete</span> config.<span class="hljs-property">__source</span>;
    }
    <span class="hljs-comment">// ! 源码中做了详细处理，⽐如过滤掉key、ref等</span>
    <span class="hljs-keyword">const</span> props = {
        ...config,
        <span class="hljs-attr">children</span>: children.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span>
   <span class="hljs-keyword">typeof</span> child === <span class="hljs-string">&quot;object&quot;</span> ? child : <span class="hljs-title function_">createTextNode</span>(child)
  )
    };
    <span class="hljs-keyword">return</span> {
        type,
        props
    };
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">createTextNode</span>(<span class="hljs-params">text</span>) {
    <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">type</span>: <span class="hljs-variable constant_">TEXT</span>,
        <span class="hljs-attr">props</span>: {
            <span class="hljs-attr">children</span>: [],
            <span class="hljs-attr">nodeValue</span>: text
        }
    };
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
    createElement
};
</code></pre>
<p>render</p>
<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params">vnode, container</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;vnode&quot;</span>, vnode); <span class="hljs-comment">// 虚拟DOM对象</span>
    <span class="hljs-comment">// vnode _&gt; node</span>
    <span class="hljs-keyword">const</span> node = <span class="hljs-title function_">createNode</span>(vnode, container);
    container.<span class="hljs-title function_">appendChild</span>(node);
}

<span class="hljs-comment">// 创建真实DOM节点</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">createNode</span>(<span class="hljs-params">vnode, parentNode</span>) {
    <span class="hljs-keyword">let</span> node = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">const</span> {type, props} = vnode;
    <span class="hljs-keyword">if</span> (type === <span class="hljs-variable constant_">TEXT</span>) {
        node = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createTextNode</span>(<span class="hljs-string">&quot;&quot;</span>);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> type === <span class="hljs-string">&quot;string&quot;</span>) {
        node = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(type);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> type === <span class="hljs-string">&quot;function&quot;</span>) {
        node = type.<span class="hljs-property">isReactComponent</span>
            ? <span class="hljs-title function_">updateClassComponent</span>(vnode, parentNode)
        : <span class="hljs-title function_">updateFunctionComponent</span>(vnode, parentNode);
    } <span class="hljs-keyword">else</span> {
        node = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createDocumentFragment</span>();
    }
    <span class="hljs-title function_">reconcileChildren</span>(props.<span class="hljs-property">children</span>, node);
    <span class="hljs-title function_">updateNode</span>(node, props);
    <span class="hljs-keyword">return</span> node;
}

<span class="hljs-comment">// 遍历下子vnode，然后把子vnode-&gt;真实DOM节点，再插入父node中</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">reconcileChildren</span>(<span class="hljs-params">children, node</span>) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; children.<span class="hljs-property">length</span>; i++) {
        <span class="hljs-keyword">let</span> child = children[i];
        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(child)) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; child.<span class="hljs-property">length</span>; j++) {
                <span class="hljs-title function_">render</span>(child[j], node);
            }
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-title function_">render</span>(child, node);
        }
    }
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">updateNode</span>(<span class="hljs-params">node, nextVal</span>) {
    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(nextVal)
        .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">k</span> =&gt;</span> k !== <span class="hljs-string">&quot;children&quot;</span>)
        .<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">k</span> =&gt;</span> {
        <span class="hljs-keyword">if</span> (k.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>) === <span class="hljs-string">&quot;on&quot;</span>) {
            <span class="hljs-keyword">let</span> eventName = k.<span class="hljs-title function_">slice</span>(<span class="hljs-number">2</span>).<span class="hljs-title function_">toLocaleLowerCase</span>();
            node.<span class="hljs-title function_">addEventListener</span>(eventName, nextVal[k]);
        } <span class="hljs-keyword">else</span> {
            node[k] = nextVal[k];
        }
    });
}

<span class="hljs-comment">// 返回真实dom节点</span>
<span class="hljs-comment">// 执行函数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">updateFunctionComponent</span>(<span class="hljs-params">vnode, parentNode</span>) {
    <span class="hljs-keyword">const</span> {type, props} = vnode;
    <span class="hljs-keyword">let</span> vvnode = <span class="hljs-title function_">type</span>(props);
    <span class="hljs-keyword">const</span> node = <span class="hljs-title function_">createNode</span>(vvnode, parentNode);
    <span class="hljs-keyword">return</span> node;
}

<span class="hljs-comment">// 返回真实dom节点</span>
<span class="hljs-comment">// 先实例化，再执行render函数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">updateClassComponent</span>(<span class="hljs-params">vnode, parentNode</span>) {
    <span class="hljs-keyword">const</span> {type, props} = vnode;
    <span class="hljs-keyword">let</span> cmp = <span class="hljs-keyword">new</span> <span class="hljs-title function_">type</span>(props);
    <span class="hljs-keyword">const</span> vvnode = cmp.<span class="hljs-title function_">render</span>();
    <span class="hljs-keyword">const</span> node = <span class="hljs-title function_">createNode</span>(vvnode, parentNode);
    <span class="hljs-keyword">return</span> node;
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
    render
};
</code></pre>
<p><img src="file:///e:\studying\book_files\76.jpg" alt="render之后流程"></p>
<h3 id="fiber架构的理解">Fiber架构的理解</h3>
<p>JavaScript引擎和页面渲染引擎两个线程是互斥的，当其中一个线程执行时，另一个线程只能挂起等待</p>
<p>如果 JavaScript 线程长时间地占用了主线程，那么渲染层面的更新就不得不长时间地等待，界面长时间不更新，会导致页面响应度变差，用户可能会感觉到卡顿</p>
<p>而这也正是 React 15 的 <code>Stack Reconciler</code>所面临的问题，当 React在渲染组件时，从开始到渲染完成整个过程是一气呵成的，无法中断</p>
<p>如果组件较大，那么js线程会一直执行，然后等到整棵VDOM树计算完成后，才会交给渲染的线程</p>
<p>这就会导致一些用户交互、动画等任务无法立即得到处理，导致卡顿的情况</p>
<h4 id="react-fiber">React Fiber</h4>
<ul>
<li>为每个增加了优先级，优先级高的任务可以中断低优先级的任务。然后再重新，注意是重新执行优先级低的任务</li>
<li>增加了异步任务，调用requestIdleCallback api，浏览器空闲的时候执行</li>
<li>dom diff树变成了链表，一个dom对应两个fiber（一个链表），对应两个队列，这都是为找到被中断的任务，重新执行</li>
</ul>
<p>从架构角度来看，Fiber 是对 React核心算法（即调和过程）的重写</p>
<p>从编码角度来看，Fiber是 React内部所定义的一种数据结构，它是 Fiber树结构的节点单位，也就是 React 16 新架构下的虚拟DOM</p>
<p>一个 fiber就是一个 JavaScript对象，包含了元素的信息、该元素的更新操作队列、类型，其数据结构如下：</p>
<pre><code class="language-js">type <span class="hljs-title class_">Fiber</span> = {
  <span class="hljs-comment">// 用于标记fiber的WorkTag类型，主要表示当前fiber代表的组件类型如FunctionComponent、ClassComponent等</span>
  <span class="hljs-attr">tag</span>: <span class="hljs-title class_">WorkTag</span>,
  <span class="hljs-comment">// ReactElement里面的key</span>
  <span class="hljs-attr">key</span>: <span class="hljs-literal">null</span> | string,
  <span class="hljs-comment">// ReactElement.type，调用`createElement`的第一个参数</span>
  <span class="hljs-attr">elementType</span>: any,
  <span class="hljs-comment">// The resolved function/class/ associated with this fiber.</span>
  <span class="hljs-comment">// 表示当前代表的节点类型</span>
  <span class="hljs-attr">type</span>: any,
  <span class="hljs-comment">// 表示当前FiberNode对应的element组件实例</span>
  <span class="hljs-attr">stateNode</span>: any,

  <span class="hljs-comment">// 指向他在Fiber节点树中的`parent`，用来在处理完这个节点之后向上返回</span>
  <span class="hljs-attr">return</span>: <span class="hljs-title class_">Fiber</span> | <span class="hljs-literal">null</span>,
  <span class="hljs-comment">// 指向自己的第一个子节点</span>
  <span class="hljs-attr">child</span>: <span class="hljs-title class_">Fiber</span> | <span class="hljs-literal">null</span>,
  <span class="hljs-comment">// 指向自己的兄弟结构，兄弟节点的return指向同一个父节点</span>
  <span class="hljs-attr">sibling</span>: <span class="hljs-title class_">Fiber</span> | <span class="hljs-literal">null</span>,
  <span class="hljs-attr">index</span>: number,

  <span class="hljs-attr">ref</span>: <span class="hljs-literal">null</span> | ((<span class="hljs-function">(<span class="hljs-params">handle: mixed</span>) =&gt;</span> <span class="hljs-keyword">void</span>) &amp; { <span class="hljs-attr">_stringRef</span>: ?string }) | <span class="hljs-title class_">RefObject</span>,

  <span class="hljs-comment">// 当前处理过程中的组件props对象</span>
  <span class="hljs-attr">pendingProps</span>: any,
  <span class="hljs-comment">// 上一次渲染完成之后的props</span>
  <span class="hljs-attr">memoizedProps</span>: any,

  <span class="hljs-comment">// 该Fiber对应的组件产生的Update会存放在这个队列里面</span>
  <span class="hljs-attr">updateQueue</span>: <span class="hljs-title class_">UpdateQueue</span>&lt;any&gt; | <span class="hljs-literal">null</span>,

  <span class="hljs-comment">// 上一次渲染的时候的state</span>
  <span class="hljs-attr">memoizedState</span>: any,

  <span class="hljs-comment">// 一个列表，存放这个Fiber依赖的context</span>
  <span class="hljs-attr">firstContextDependency</span>: <span class="hljs-title class_">ContextDependency</span>&lt;mixed&gt; | <span class="hljs-literal">null</span>,

  <span class="hljs-attr">mode</span>: <span class="hljs-title class_">TypeOfMode</span>,

  <span class="hljs-comment">// Effect</span>
  <span class="hljs-comment">// 用来记录Side Effect</span>
  <span class="hljs-attr">effectTag</span>: <span class="hljs-title class_">SideEffectTag</span>,

  <span class="hljs-comment">// 单链表用来快速查找下一个side effect</span>
  <span class="hljs-attr">nextEffect</span>: <span class="hljs-title class_">Fiber</span> | <span class="hljs-literal">null</span>,

  <span class="hljs-comment">// 子树中第一个side effect</span>
  <span class="hljs-attr">firstEffect</span>: <span class="hljs-title class_">Fiber</span> | <span class="hljs-literal">null</span>,
  <span class="hljs-comment">// 子树中最后一个side effect</span>
  <span class="hljs-attr">lastEffect</span>: <span class="hljs-title class_">Fiber</span> | <span class="hljs-literal">null</span>,

  <span class="hljs-comment">// 代表任务在未来的哪个时间点应该被完成，之后版本改名为 lanes</span>
  <span class="hljs-attr">expirationTime</span>: <span class="hljs-title class_">ExpirationTime</span>,

  <span class="hljs-comment">// 快速确定子树中是否有不在等待的变化</span>
  <span class="hljs-attr">childExpirationTime</span>: <span class="hljs-title class_">ExpirationTime</span>,

  <span class="hljs-comment">// fiber的版本池，即记录fiber更新过程，便于恢复</span>
  <span class="hljs-attr">alternate</span>: <span class="hljs-title class_">Fiber</span> | <span class="hljs-literal">null</span>,
}
</code></pre>
<p>Fiber把渲染更新过程拆分成多个子任务，每次只做一小部分，做完看是否还有剩余时间，如果有继续下一个任务；如果没有，挂起当前任务，将时间控制权交给主线程，等主线程不忙的时候在继续执行</p>
<p>即可以中断与恢复，恢复后也可以复用之前的中间状态，并给不同的任务赋予不同的优先级，其中每个任务更新单元为 React Element 对应的 Fiber节点</p>
<p>实现的上述方式的是requestIdleCallback方法</p>
<p>window.requestIdleCallback()方法将在浏览器的空闲时段内调用的函数排队。这使开发者能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，如动画和输入响应</p>
<p>首先 React 中任务切割为多个步骤，分批完成。在完成一部分任务之后，将控制权交回给浏览器，让浏览器有时间再进行页面的渲染。等浏览器忙完之后有剩余时间，再继续之前 React 未完成的任务，是一种合作式调度。</p>
<p>该实现过程是基于 Fiber节点实现，作为静态的数据结构来说，每个 Fiber 节点对应一个 React element，保存了该组件的类型（函数组件/类组件/原生组件等等）、对应的 DOM 节点等信息。</p>
<p>作为动态的工作单元来说，每个 Fiber 节点保存了本次更新中该组件改变的状态、要执行的工作。</p>
<p>每个 Fiber 节点有个对应的 React element，多个 Fiber节点根据如下三个属性构建一颗树：</p>
<pre><code class="language-js"><span class="hljs-comment">// 指向父级Fiber节点</span>
<span class="hljs-variable language_">this</span>.<span class="hljs-property">return</span> = <span class="hljs-literal">null</span>
<span class="hljs-comment">// 指向子Fiber节点</span>
<span class="hljs-variable language_">this</span>.<span class="hljs-property">child</span> = <span class="hljs-literal">null</span>
<span class="hljs-comment">// 指向右边第一个兄弟Fiber节点</span>
<span class="hljs-variable language_">this</span>.<span class="hljs-property">sibling</span> = <span class="hljs-literal">null</span>
</code></pre>
<p>通过这些属性就能找到下一个执行目标</p>
<h3 id="react中key的作用">react中key的作用</h3>
<p>跟Vue一样，React 也存在 Diff算法，而元素key属性的作用是用于判断元素是新创建的还是被移动的元素，从而减少不必要的元素渲染</p>
<p>因此key的值需要为每一个元素赋予一个确定的标识</p>
<p>如果列表数据渲染中，在数据后面插入一条数据，key作用并不大，如下：</p>
<pre><code class="language-js"><span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = {
    <span class="hljs-attr">numbers</span>:[<span class="hljs-number">111</span>,<span class="hljs-number">222</span>,<span class="hljs-number">333</span>]
}

<span class="hljs-title function_">insertMovie</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> newMovies = [...<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">numbers</span>, <span class="hljs-number">444</span>];
  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({
    <span class="hljs-attr">movies</span>: newMovies
  })
}

&lt;ul&gt;
    {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">movies</span>.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> {
            <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>{item}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>
        })
    }
&lt;/ul&gt;
</code></pre>
<p>前面的元素在diff算法中，前面的元素由于是完全相同的，并不会产生删除创建操作，在最后一个比较的时候，则需要插入到新的DOM树中</p>
<p>因此，在这种情况下，元素有无key属性意义并不大</p>
<p>下面再来看看在前面插入数据时，使用key与不使用key的区别：</p>
<pre><code class="language-js"><span class="hljs-title function_">insertMovie</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> newMovies = [<span class="hljs-number">000</span> ,...<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">numbers</span>];
  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({
    <span class="hljs-attr">movies</span>: newMovies
  })
}
</code></pre>
<p>当拥有key的时候，react根据key属性匹配原有树上的子元素以及最新树上的子元素，像上述情况只需要将000元素插入到最前面位置</p>
<p>当没有key的时候，所有的li标签都需要进行修改</p>
<p>同样，并不是拥有key值代表性能越高，如果说只是文本内容改变了，不写key反而性能和效率更高</p>
<p>主要是因为不写key是将所有的文本内容替换一下，节点不会发生变化</p>
<p>而写key则涉及到了节点的增和删，发现旧key不存在了，则将其删除，新key在之前没有，则插入，这就增加性能的开销</p>
<h3 id="react-diff算法">react diff算法</h3>
<p>跟Vue一致，React通过引入Virtual DOM的概念，极大地避免无效的Dom操作，使我们的页面的构建效率提到了极大的提升</p>
<p>传统diff算法通过循环递归对节点进行依次对比，效率低下，算法复杂度达到 O(n^3)，react将算法进行一个优化，复杂度降维O(n)</p>
<h4 id="原理">原理</h4>
<p>react中diff算法主要遵循三个层级的策略：</p>
<ul>
<li>tree层级(对整个组件树进行遍历和比较的过程)
<ul>
<li>DOM节点跨层级的操作不做优化，只会对相同层级的节点进行比较</li>
<li>只有删除、创建操作，没有移动操作</li>
</ul>
</li>
<li>conponent 层级
<ul>
<li>如果是同一个类的组件，则会继续往下diff运算，如果不是一个类的组件，那么直接删除这个组件下的所有子节点，创建新的</li>
</ul>
</li>
<li>element 层级:对于比较同一层级的节点们，每个节点在对应的层级用唯一的key作为标识;提供了 3 种节点操作，分别为 <strong>INSERT_MARKUP(插入)、MOVE_EXISTING (移动)和 REMOVE_NODE (删除)</strong></li>
</ul>
<p><img src="file:///e:\studying\book_files\77.jpg" alt="tree">
<img src="file:///e:\studying\book_files\78.jpg" alt="tree">
react发现新树中，R节点下没有了A，那么直接删除A，在D节点下创建A以及下属节点，上述操作中，只有删除和创建操作</p>
<p><img src="file:///e:\studying\book_files\79.jpg" alt="component">
当component D换成了component G 后，即使两者的结构非常类似，也会将D删除再重新创建G</p>
<p><img src="file:///e:\studying\book_files\80.jpg" alt="element">
通过key可以准确地发现新旧集合中的节点都是相同的节点，因此无需进行节点删除和创建，只需要将旧集合中节点的位置进行移动，更新为新集合中节点的位置
<img src="file:///e:\studying\book_files\81.jpg" alt="index"></p>
<ul>
<li>index： 新集合的遍历下标。</li>
<li>oldIndex：当前节点在老集合中的下标</li>
<li>maxIndex：在新集合访问过的节点中，其在老集合的最大下标</li>
</ul>
<p>如果当前节点在新集合中的位置比老集合中的位置靠前的话，是不会影响后续节点操作的，这里这时候被动字节不用动</p>
<p>操作过程中只比较oldIndex和maxIndex，规则如下：</p>
<ul>
<li>当oldIndex&gt;maxIndex时，将oldIndex的值赋值给maxIndex</li>
<li>当oldIndex=maxIndex时，不操作</li>
<li><code>当oldIndex&lt;maxIndex时，将当前节点移动到index的位置</code></li>
</ul>
<p>diff过程如下：</p>
<ul>
<li>节点B：此时 maxIndex=0，oldIndex=1；满足 maxIndex&lt; oldIndex，因此B节点不动，此时maxIndex= Math.max(oldIndex, maxIndex)，就是1</li>
<li>节点A：此时maxIndex=1，oldIndex=0；不满足maxIndex&lt; oldIndex，因此A节点进行移动操作，此时maxIndex= Math.max(oldIndex, maxIndex)，还是1</li>
<li>节点D：此时maxIndex=1, oldIndex=3；满足maxIndex&lt; oldIndex，因此D节点不动，此时maxIndex= Math.max(oldIndex, maxIndex)，就是3</li>
<li>节点C：此时maxIndex=3，oldIndex=2；不满足maxIndex&lt; oldIndex，因此C节点进行移动操作，当前已经比较完了</li>
</ul>
<p>当ABCD节点比较完成后，diff过程还没完，还会整体遍历老集合中节点，看有没有没用到的节点，有的话，就删除</p>
<blockquote>
<p>old&gt;max,max更新为新值，元素不懂，<code>当old&lt;max</code>，则移动元素到对应的max标记的位置</p>
</blockquote>
<h4 id="简单类型加key和不加key的性能">简单类型加key和不加key的性能</h4>
<p>由于dom节点的移动操作开销是比较昂贵的，没有key的情况下要比有key的性能更好</p>
<pre><code class="language-js"><span class="hljs-number">1.</span>加key
&lt;div key=<span class="hljs-string">&#x27;1&#x27;</span>&gt;<span class="hljs-number">1</span>&lt;<span class="hljs-regexp">/div&gt;             &lt;div key=&#x27;1&#x27;&gt;1&lt;/</span>div&gt;     
<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#x27;2&#x27;</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>             <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#x27;3&#x27;</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  
<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#x27;3&#x27;</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  ========&gt;  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#x27;2&#x27;</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  
<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#x27;4&#x27;</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>             <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#x27;5&#x27;</span>&gt;</span>5<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  
<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#x27;5&#x27;</span>&gt;</span>5<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>             <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#x27;6&#x27;</span>&gt;</span>6<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  
操作：节点<span class="hljs-number">2</span>移动至下标为<span class="hljs-number">2</span>的位置，新增节点<span class="hljs-number">6</span>至下标为<span class="hljs-number">4</span>的位置，删除节点<span class="hljs-number">4</span>。

<span class="hljs-number">2.</span>不加key
&lt;div&gt;<span class="hljs-number">1</span>&lt;<span class="hljs-regexp">/div&gt;             &lt;div&gt;1&lt;/</span>div&gt;     
<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>             <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  
<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  ========&gt;  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  
<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>             <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>5<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  
<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>5<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>             <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>6<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span> 
操作：修改第<span class="hljs-number">1</span>个到第<span class="hljs-number">5</span>个节点的innerText
</code></pre>
<h3 id="react-hooks的理解">react hooks的理解</h3>
<p>Hook 是 React 16.8 的新增特性。它可以在不编写 class 的情况下使用 state 以及其他的 React 特性，其本质是一系列特殊的函数。</p>
<h4 id="常见的hooks">常见的hooks</h4>
<ul>
<li>
<p>useState</p>
</li>
<li>
<p>useEffect</p>
</li>
<li>
<p>useCallback</p>
</li>
<li>
<p>useMemo</p>
</li>
<li>
<p>useRef</p>
</li>
<li>
<p>useReducer:React中用于管理组件内部状态的一个强大工具，它使得状态管理更加灵活和可维护</p>
</li>
<li>
<p>useContext:获取上下文数据</p>
</li>
<li>
<p>useNavigate</p>
</li>
<li>
<p>useLocation</p>
</li>
<li>
<p>useParams</p>
</li>
<li>
<p>useSearchParams</p>
</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { useState, useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Example</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);
 
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {    <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = <span class="hljs-string">`You clicked <span class="hljs-subst">${count}</span> times`</span>;  });
  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>You clicked {count} times&lt;/p &gt;
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setCount(count + 1)}&gt;
        Click me
      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  );
}
</span></code></pre>
<p>在组件中调用useReducer：在组件函数内部，调用useReducer并传入reducer函数和状态的初始值。useReducer返回一个数组，第一个元素是当前的状态，第二个元素是一个dispatch函数，用于分发动作。</p>
<pre><code class="language-js">  
<span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { useReducer } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;  

<span class="hljs-keyword">function</span> <span class="hljs-title function_">reducer</span>(<span class="hljs-params">state, action</span>) {  
  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) {  
    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;increment&#x27;</span>:  
      <span class="hljs-keyword">return</span> { <span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> };  
    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;decrement&#x27;</span>:  
      <span class="hljs-keyword">return</span> { <span class="hljs-attr">count</span>: state.<span class="hljs-property">count</span> - <span class="hljs-number">1</span> };  
    <span class="hljs-attr">default</span>:  
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>();  
  }  
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"></span>) {  
  <span class="hljs-keyword">const</span> [state, dispatch] = <span class="hljs-title function_">useReducer</span>(reducer, { <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> });  
  <span class="hljs-keyword">return</span> (  
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>  
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Count: {state.count}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>  
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> dispatch({ type: &#x27;increment&#x27; })}&gt;Increment<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>  
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> dispatch({ type: &#x27;decrement&#x27; })}&gt;Decrement<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>  
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  
  );  
}
</code></pre>
<h4 id="hooks作用">hooks作用</h4>
<p>hooks能够更容易解决状态相关的重用的问题：</p>
<ul>
<li>每调用useHook一次都会生成一份独立的状态</li>
<li>通过自定义hook能够更好的封装我们的功能</li>
</ul>
<p>编写hooks为函数式编程，每个功能都包裹在函数中，整体风格更清爽，更优雅</p>
<h4 id="自定义hooks">自定义hooks</h4>
<pre><code class="language-js"><span class="hljs-keyword">import</span> { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;  
  
<span class="hljs-comment">// 自定义Hook: useCounter  </span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">useCounter</span>(<span class="hljs-params"></span>) {  
  <span class="hljs-comment">// 使用useState初始化计数值为0  </span>
  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);  
  
  <span class="hljs-comment">// 定义一个增加计数的函数  </span>
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">increment</span> = (<span class="hljs-params"></span>) =&gt; {  
    <span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>);  
  };  
  
  <span class="hljs-comment">// 返回计数状态和增加计数的函数  </span>
  <span class="hljs-keyword">return</span> [count, increment];  
}  
  
<span class="hljs-comment">// 使用自定义Hook的组件  </span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">CounterComponent</span>(<span class="hljs-params"></span>) {  
  <span class="hljs-comment">// 使用自定义Hook获取计数状态和增加计数的函数  </span>
  <span class="hljs-keyword">const</span> [count, increment] = <span class="hljs-title function_">useCounter</span>();  
  
  <span class="hljs-keyword">return</span> (  
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>  
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Count: {count}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>  
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{increment}</span>&gt;</span>Increment<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>  
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  
  );  
}  
  
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">CounterComponent</span>;
</code></pre>
<h3 id="react-性能优化">react 性能优化</h3>
<p>当我们想要更新一个子组件的时候，如下图绿色部分：</p>
<p><img src="file:///e:\studying\book_files\87.jpg" alt="1"></p>
<p>理想状态只调用该路径下的组件render：</p>
<p><img src="file:///e:\studying\book_files\88.jpg" alt="2"></p>
<p>但是react的默认做法是调用所有组件的render，再对生成的虚拟DOM进行对比（黄色部分），如不变则不进行更新</p>
<p><img src="file:///e:\studying\book_files\89.jpg" alt="3"></p>
<p>从上图可见，黄色部分diff算法对比是明显的性能浪费的情况</p>
<p>主要手段是通过shouldComponentUpdate、PureComponent、React.memo</p>
<p>除此之外， 常见性能优化常见的手段有如下：</p>
<ul>
<li>避免使用内联函数</li>
<li>使用 React Fragments 避免额外标记</li>
<li>使用 Immutable</li>
<li>懒加载组件</li>
<li>事件绑定方式</li>
<li>服务端渲染</li>
<li>组件拆分、合理使用hooks等性能优化手段</li>
</ul>
<p>如果使用内联函数，则每次调用render函数时都会创建一个新的函数实例</p>
<pre><code class="language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InlineFunctionComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> {
  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> (
      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Welcome Guest<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{(e)</span> =&gt;</span> { this.setState({inputValue: e.target.value}) }} value=&quot;Click For Inline Function&quot; /&gt;
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    )
  }
}
</code></pre>
<p>应该在组件内部创建一个函数，并将事件绑定到该函数本身。这样每次调用 render 时就不会创建单独的函数实例</p>
<pre><code class="language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InlineFunctionComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> {
  
  setNewStateData = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>({
      <span class="hljs-attr">inputValue</span>: e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>
    })
  }
  
  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> (
      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Welcome Guest<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.setNewStateData}</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Click For Inline Function&quot;</span> /&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    )
  }
}
</code></pre>
<h3 id="react-router理解">react-router理解</h3>
<p>react-router主要分成了几个不同的包：</p>
<ol>
<li>react-router: 实现了路由的核心功能</li>
<li>react-router-dom： 基于 react-router，加入了在浏览器运行环境下的一些功能</li>
<li>react-router-native：基于 react-router，加入了 react-native 运行环境下的一些功能</li>
<li>react-router-config: 用于配置静态路由的工具库</li>
</ol>
<p>react-router-dom v6版本修改了很多属性</p>
<pre><code>默认即精确匹配
移除了子组件的props中默认带着的histroy等属性，现在需要借助useHistory hooks去获取
移除了redirect，用&lt;Navigate to=&quot;/&quot; replace /&gt;取代
移除了switch，用routes取代
</code></pre>
<ul>
<li>NavLink:封装的a，加持了activeStyle【活跃时（匹配时）的样式】和activeClassName（添加className用）</li>
<li>useSearchParams 是 React Router DOM 库中用于处理 URL 查询参数（query parameters）的 React Hook。</li>
<li>useLocation 是 react-router-dom 库中的一个钩子（hook），它主要用于获取当前路由的位置信息。通过 useLocation，可以访问到当前 URL 的详细信息，包括 pathname（路径名）、search（查询字符串）以及 hash（哈希部分）等。</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">BrowserRouter</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">Router</span>, <span class="hljs-title class_">Route</span>, <span class="hljs-title class_">Routes</span>,<span class="hljs-title class_">NavLink</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-router-dom&quot;</span>;  
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Contact</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./component/Contact&quot;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">About</span>  <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./component/About&quot;</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">Detail</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./component/Detail&quot;</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {  
  <span class="hljs-keyword">return</span> (  
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Router</span>&gt;</span>  
      <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span>  
        <span class="hljs-tag">&lt;<span class="hljs-name">nav</span>&gt;</span>  
          <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>  
            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>  
              <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/&quot;</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>  
            <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>  
            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>  
              <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/about&quot;</span>&gt;</span>About<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>  
            <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>  
            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>  
              <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/contact&quot;</span>&gt;</span>Contact<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>  
            <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>  
           
          <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>  
          <span class="hljs-tag">&lt;<span class="hljs-name">NavLink</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/&quot;</span> <span class="hljs-attr">exact</span> <span class="hljs-attr">activeStyle</span>=<span class="hljs-string">{{color:</span> &quot;<span class="hljs-attr">red</span>&quot;}}&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">NavLink</span>&gt;</span>

          {/* {userName &amp;&amp; (  
          <span class="hljs-tag">&lt;<span class="hljs-name">NavLink</span> <span class="hljs-attr">to</span>=<span class="hljs-string">{</span>`/<span class="hljs-attr">about</span>/${<span class="hljs-attr">userName</span>}`}&gt;</span>About<span class="hljs-tag">&lt;/<span class="hljs-name">NavLink</span>&gt;</span>  
        )}   */}
          <span class="hljs-tag">&lt;<span class="hljs-name">NavLink</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/about/tom&quot;</span> <span class="hljs-attr">activeStyle</span>=<span class="hljs-string">{{color:</span> &quot;<span class="hljs-attr">red</span>&quot;}}&gt;</span>关于<span class="hljs-tag">&lt;/<span class="hljs-name">NavLink</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">NavLink</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/contact&quot;</span> <span class="hljs-attr">activeStyle</span>=<span class="hljs-string">{{color:</span> &quot;<span class="hljs-attr">red</span>&quot;}}&gt;</span>链接<span class="hljs-tag">&lt;/<span class="hljs-name">NavLink</span>&gt;</span>
          //   传参
		  <span class="hljs-tag">&lt;<span class="hljs-name">NavLink</span> <span class="hljs-attr">to</span>=<span class="hljs-string">{{</span>
              <span class="hljs-attr">pathname:</span> &quot;/<span class="hljs-attr">detail2</span>&quot;, 
              <span class="hljs-attr">query:</span> {<span class="hljs-attr">name:</span> &quot;<span class="hljs-attr">kobe</span>&quot;, <span class="hljs-attr">age:</span> <span class="hljs-attr">30</span>},
              <span class="hljs-attr">state:</span> {<span class="hljs-attr">height:</span> <span class="hljs-attr">1.98</span>, <span class="hljs-attr">address:</span> &quot;洛杉矶&quot;},
              <span class="hljs-attr">search:</span> &quot;?<span class="hljs-attr">apikey</span>=<span class="hljs-string">123</span>&quot;
            }}&gt;</span>
            详情2
        <span class="hljs-tag">&lt;/<span class="hljs-name">NavLink</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span>  
        <span class="hljs-tag">&lt;<span class="hljs-name">Routes</span>&gt;</span>  
          <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">h1</span>&gt;</span>Welcome to Home!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>} /&gt; 
		   // 传参
          <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/about/:name&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">{</span>&lt;<span class="hljs-attr">About</span>/&gt;</span>} /&gt;  
          <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/contact&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">{</span> &lt;<span class="hljs-attr">Contact</span>/&gt;</span> } /&gt;  
          <span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/detail2&quot;</span> <span class="hljs-attr">element</span>=<span class="hljs-string">{</span> &lt;<span class="hljs-attr">Detail</span>/&gt;</span> } /&gt;  

        <span class="hljs-tag">&lt;/<span class="hljs-name">Routes</span>&gt;</span>  
      <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>  
    <span class="hljs-tag">&lt;/<span class="hljs-name">Router</span>&gt;</span></span>  
  );  
}
</code></pre>
<pre><code class="language-js"><span class="hljs-keyword">import</span> {<span class="hljs-title class_">Fragment</span>} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>
<span class="hljs-keyword">import</span> { useNavigate } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom&#x27;</span>;  
<span class="hljs-keyword">const</span> <span class="hljs-title function_">Contact</span> = (<span class="hljs-params"></span>) =&gt;{
   <span class="hljs-keyword">const</span> navigate = <span class="hljs-title function_">useNavigate</span>();  
   <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Fragment</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Contact<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> navigate(&quot;/&quot;)}&gt;Go to home<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">Fragment</span>&gt;</span></span>
};

  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">Contact</span>
</code></pre>
<pre><code class="language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Fragment</span>, useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Navigate</span>, useLocation,useParams } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-router-dom&quot;</span>;
<span class="hljs-keyword">const</span> <span class="hljs-title function_">About</span> = (<span class="hljs-params"></span>) =&gt; {
  <span class="hljs-keyword">const</span> { name } = <span class="hljs-title function_">useParams</span>();  
  <span class="hljs-keyword">const</span> location = <span class="hljs-title function_">useLocation</span>();

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name);
  }, [name, location]);

  <span class="hljs-comment">// 如果 name 不是 &quot;tom&quot;，则重定向到根路径</span>
  <span class="hljs-keyword">if</span> (name !== <span class="hljs-string">&quot;tom&quot;</span>) {
    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Navigate</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/&quot;</span> <span class="hljs-attr">replace</span> /&gt;</span></span>; <span class="hljs-comment">// 使用 Navigate 组件进行重定向</span>
  }
  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Fragment</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>About {name}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">Fragment</span>&gt;</span></span>
  );
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">About</span>;
</code></pre>
<pre><code class="language-js"><span class="hljs-keyword">import</span> { <span class="hljs-title class_">Fragment</span>, useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;
<span class="hljs-comment">// import {Redirect} from &#x27;react-router-dom&#x27;</span>
<span class="hljs-keyword">import</span> { <span class="hljs-title class_">Navigate</span>, useLocation,useParams, useSearchParams } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-router-dom&quot;</span>;
<span class="hljs-keyword">const</span> <span class="hljs-title function_">Detail</span> = (<span class="hljs-params">props</span>) =&gt; {
   
    <span class="hljs-keyword">const</span> val = <span class="hljs-title function_">useLocation</span>()<span class="hljs-comment">// {pathname: &#x27;/detail2&#x27;, search: &#x27;?apikey=123&#x27;, hash: &#x27;&#x27;, state: null, key: &#x27;gv3sr6yo&#x27;}</span>
    <span class="hljs-keyword">const</span> [search] = <span class="hljs-title function_">useSearchParams</span>() <span class="hljs-comment">//123</span>

    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(search.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;apikey&#x27;</span>))

    <span class="hljs-comment">// console.log(val1)</span>
  <span class="hljs-keyword">return</span> (
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Fragment</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span> Detail <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">Fragment</span>&gt;</span></span>
  );
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>  <span class="hljs-title class_">Detail</span> ;

</code></pre>
<h4 id="usesearchparams的应用">useSearchParams的应用</h4>
<pre><code class="language-js"><span class="hljs-keyword">import</span> { useSearchParams } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router-dom&#x27;</span>;  
  
<span class="hljs-keyword">function</span> <span class="hljs-title function_">MyComponent</span>(<span class="hljs-params"></span>) {  
  <span class="hljs-comment">// 使用 useSearchParams 获取当前的查询参数对象  </span>
  <span class="hljs-keyword">let</span> [searchParams] = <span class="hljs-title function_">useSearchParams</span>();  
  
  <span class="hljs-comment">// 读取查询参数  </span>
  <span class="hljs-keyword">let</span> param1 = searchParams.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;param1&#x27;</span>);  
  <span class="hljs-keyword">let</span> param2 = searchParams.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;param2&#x27;</span>);  
  
  <span class="hljs-comment">// 修改查询参数  </span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleUpdateParam1</span>(<span class="hljs-params">event</span>) {  
    searchParams.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;param1&#x27;</span>, event.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>);  
    <span class="hljs-comment">// 注意：调用 searchParams 的方法并不会自动更新 URL，你需要使用下面的方式触发更新  </span>
  }  
  
  <span class="hljs-comment">// 触发 URL 更新  </span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleSubmit</span>(<span class="hljs-params">event</span>) {  
    event.<span class="hljs-title function_">preventDefault</span>();  
    <span class="hljs-comment">// 使用 replace 或 push 来导航到新 URL  </span>
    <span class="hljs-variable language_">window</span>.<span class="hljs-property">history</span>.<span class="hljs-title function_">replaceState</span>({}, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-variable language_">window</span>.location.pathname}</span>?<span class="hljs-subst">${searchParams}</span>`</span>);  
  }  
  
  <span class="hljs-keyword">return</span> (  
    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">{handleSubmit}</span>&gt;</span>  
      <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>  
        Param 1:  
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span>  
          <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>  
          <span class="hljs-attr">value</span>=<span class="hljs-string">{param1</span> || &#x27;&#x27;}  
          <span class="hljs-attr">onChange</span>=<span class="hljs-string">{handleUpdateParam1}</span>  
        /&gt;</span>  
      <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>  
      {/* 其他表单字段和提交按钮 */}  
    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span>  
  );  
}  
  
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">MyComponent</span>;
</code></pre>
<h4 id="react路由传参的形式">react路由传参的形式</h4>
<p>动态路由</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">NavLink</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/detail/abc123&quot;</span>&gt;</span>详情<span class="hljs-tag">&lt;/<span class="hljs-name">NavLink</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/detail/:id&quot;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">{Detail}/</span>&gt;</span>
</code></pre>
<p>search传递参数</p>
<pre><code class="language-js">&lt;<span class="hljs-title class_">NavLink</span> to=<span class="hljs-string">&quot;/detail2?name=why&amp;age=18&quot;</span>&gt;详情<span class="hljs-number">2</span>&lt;/<span class="hljs-title class_">NavLink</span>&gt;
<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/detail2&quot;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">{Detail2}/</span>&gt;</span></span>
</code></pre>
<p>to传入对象或字符串</p>
<pre><code class="language-js">&lt;<span class="hljs-title class_">NavLink</span> to={{
    <span class="hljs-attr">pathname</span>: <span class="hljs-string">&quot;/detail2&quot;</span>, 
    <span class="hljs-attr">query</span>: {<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kobe&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>},
    <span class="hljs-attr">state</span>: {<span class="hljs-attr">height</span>: <span class="hljs-number">1.98</span>, <span class="hljs-attr">address</span>: <span class="hljs-string">&quot;洛杉矶&quot;</span>},
    <span class="hljs-attr">search</span>: <span class="hljs-string">&quot;?apikey=123&quot;</span>
  }}&gt;
  详情<span class="hljs-number">2</span>
&lt;/<span class="hljs-title class_">NavLink</span>&gt;
<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/detail2&quot;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">{Detail2}/</span>&gt;</span></span>
</code></pre>
<h3 id="项目中使用redux结构划分">项目中使用redux，结构划分</h3>
<p>Redux 是一个用于可预测和可维护的全局状态管理的 JS 库。Redux遵循三大基本原则：</p>
<ul>
<li>单一数据源</li>
<li>state 是只读的</li>
<li>使用纯函数来执行修改</li>
</ul>
<p><img src="file:///e:\studying\book_files\97.jpg" alt="1">
<img src="file:///e:\studying\book_files\98.jpg" alt="2"></p>
<h4 id="react-redux-redux-thunk">react-redux redux-thunk</h4>
<ul>
<li>react-redux 减少手动订阅解除订阅和组件导入store的繁琐问题
<img src="file:///e:\studying\book_files\99.jpg" alt="3"></li>
<li>reudx-thunk action 通常被设计为包含 type 属性（可能还有其他属性）的纯对象。如果试图派发一个函数，Redux 本身不会知道如何处理它，需要借助中间件</li>
</ul>
<pre><code class="language-js"><span class="hljs-comment">//store/index.js</span>
 <span class="hljs-keyword">import</span> {createStore,compose,applyMiddleware} <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>
 <span class="hljs-keyword">import</span> reducer <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./reducer.js&#x27;</span>
 <span class="hljs-keyword">import</span> thunk <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-thunk&#x27;</span>
 
 <span class="hljs-keyword">const</span> composeEnhancers =<span class="hljs-variable language_">window</span>.<span class="hljs-property">__REDUX_DEVTOOLS_EXTENSION_COMPOSE__</span> ?   
     <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">__REDUX_DEVTOOLS_EXTENSION_COMPOSE__</span>({}) : compose;
 	
 <span class="hljs-keyword">const</span> enhancer = <span class="hljs-title function_">composeEnhancers</span>(
   <span class="hljs-title function_">applyMiddleware</span>(thunk),
 );
 <span class="hljs-comment">//如果不需要使用多个中间件，如不使用window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__，</span>
 <span class="hljs-comment">//createStore第二个参数可以直接写成applyMiddleware(thunk)</span>
 <span class="hljs-keyword">const</span> store =<span class="hljs-title function_">createStore</span>(
 reducer,
 enhancer
 ); 
 
 <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store; 
</code></pre>
<pre><code class="language-js"><span class="hljs-comment">//actionCreators.js</span>
 <span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">getInputValue</span>=(<span class="hljs-params">value</span>)=&gt;({
     <span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;change_input_value&#x27;</span>,
     value
 })
 <span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">orgin</span>=(<span class="hljs-params">value</span>)=&gt;({
 	<span class="hljs-attr">type</span>:<span class="hljs-string">&quot;orgin&quot;</span>,
 	value
 })
 
 <span class="hljs-comment">// 如果没有配置react-thunk，那么在actionCreator中使用返回的是函数会报错</span>
 <span class="hljs-comment">// Actions must be plain objects. Use custom middleware for async actions.</span>
 <span class="hljs-comment">// 还可以进行异步操作，比如像后台发起请求等候反馈结果</span>
 <span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">getorgin</span>= (<span class="hljs-params"></span>)=&gt;{
 	<span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">dispatch</span>) =&gt;</span> {
 		<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>{
 			<span class="hljs-keyword">const</span> res=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>];
 			<span class="hljs-keyword">const</span> action=<span class="hljs-title function_">orgin</span>(res)
 			<span class="hljs-title function_">dispatch</span>(action)
 		},<span class="hljs-number">3000</span>)
 	}
 }
</code></pre>
<h2 id="dom">DOM</h2>
<p>文档对象模型（DOM）是 HTML 和 XML 文档的编程接口。Dom的数据结构是一颗树。</p>
<p>DOM包含了以下几种类型的节点：</p>
<ul>
<li>元素节点（Element Nodes）：元素节点对应HTML或XML文档中的标签，如<code>&lt;div&gt;、&lt;p&gt;、&lt;span&gt;</code>等。是文档结构的主要组成部分，可包含其他类型的节点，如属性节点、文本节点等。</li>
<li>属性节点（Attribute Nodes）：代表了元素的属性，如class、id等。包含了元素的附加信息，通常用于定义元素的样式、行为或与其他元素的关联。</li>
<li>文本节点（Text Nodes）：实际文本内容,位于元素节点内部，用于显示给用户或作为其他类型节点的数据。</li>
<li>注释节点（Comment Nodes）</li>
<li>文档节点（Document Nodes）：文档节点代表了整个HTML或XML文档。它是DOM树的根节点，包含了文档中的所有其他节点。</li>
<li>文档类型节点（Document Type Nodes）：这种节点通常代表文档类型定义（DTD）或XML文档中的DOCTYPE声明，它提供了关于文档类型和版本的信息。</li>
<li>文档片段节点（Document Fragment Nodes）：这是一种特殊的节点类型，它并不直接对应于文档中的任何部分。文档片段节点用于临时存储一组DOM节点，以便进行高效的DOM操作。</li>
</ul>
<h3 id="dom操作节点的基本api">DOM操作节点的基本API</h3>
<ul>
<li>创建节点
<ul>
<li>元素 document.createElement('div')</li>
<li>文本 document.createTextNode('xxx')，<code>appendChild</code>添加到对应的元素节点</li>
<li>文档碎片 document.createDocumentFragment()</li>
<li>属性 document.createAttribute('custom')，需要<code>setAttributeNode</code>设置上对应的属性</li>
</ul>
</li>
<li>获取节点
<ul>
<li>document.querySelector('#id/.class/div')返回<code>首个符合</code>要求，没有则返回null</li>
<li>document.querySelectorAll</li>
<li>getElementById、getElementsByClassName、getElementsByTagName...</li>
</ul>
</li>
<li>更新节点
<ul>
<li>innerHTML</li>
<li>innerText（不返回隐藏文本），textContent（返回所有文本）</li>
</ul>
</li>
<li>添加节点
<ul>
<li>innerHTML</li>
<li>appendChild: 把一个子节点添加到父节点最后位置</li>
<li><code>insertBefore</code>:parentElement.insertBefore(newElement, referenceElement),子节点添加到目标节点前</li>
<li>setAttribute：添加/修改属性节点</li>
</ul>
</li>
<li>删除节点
<ul>
<li>removeChild：会变成<code>游离</code>的元素，可再度利用，需要手动处理才可以真实删除。</li>
</ul>
</li>
</ul>
<pre><code class="language-js"><span class="hljs-comment">// 创建一个新的元素  </span>
	<span class="hljs-keyword">var</span> elem = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);  
	elem.<span class="hljs-property">innerHTML</span>=<span class="hljs-string">&#x27;1000&#x27;</span>
	  
	<span class="hljs-comment">// 创建一个新的属性节点  </span>
	<span class="hljs-keyword">var</span> attr = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createAttribute</span>(<span class="hljs-string">&#x27;data-custom&#x27;</span>);  
	<span class="hljs-keyword">var</span> attr1 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createAttribute</span>(<span class="hljs-string">&#x27;id&#x27;</span>);  
	<span class="hljs-comment">// 为新属性设置值  </span>
	attr.<span class="hljs-property">value</span> = <span class="hljs-string">&#x27;Hello, world!&#x27;</span>;  
	attr1.<span class="hljs-property">value</span>= <span class="hljs-string">&#x27;china&#x27;</span>
	  
	<span class="hljs-comment">// 将新属性附加到元素上  </span>
	elem.<span class="hljs-title function_">setAttributeNode</span>(attr);  
	elem.<span class="hljs-title function_">setAttributeNode</span>(attr1);
	  
	<span class="hljs-comment">// 现在，你可以将这个元素添加到DOM中  </span>
	<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(elem);
	
	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;china&#x27;</span>).<span class="hljs-property">innerHTML</span>)<span class="hljs-comment">//1000</span>

  <span class="hljs-comment">// 更简便的方式</span>
  <span class="hljs-keyword">var</span> elem1 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);  
	elem1.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;data-custom11&#x27;</span>, <span class="hljs-string">&#x27;Hello, world!&#x27;</span>);  
	<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(elem1)
</code></pre>
<pre><code class="language-js"><span class="hljs-comment">// 删除一个节点，先找到父级节点，再调用删除方法</span>
<span class="hljs-keyword">const</span> self = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;to-be-removed&#x27;</span>);
<span class="hljs-keyword">const</span> parent = self.<span class="hljs-property">parentElement</span>;
<span class="hljs-keyword">const</span> removed = parent.<span class="hljs-title function_">removeChild</span>(self);
removed === self; <span class="hljs-comment">// true</span>

<span class="hljs-comment">// 移除事件监听器（如果有的话）  </span>
removed.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, someFunction);  
<span class="hljs-comment">// ... 移除其他事件监听器  </span>
  
<span class="hljs-comment">// 将引用设置为null  </span>
removed = <span class="hljs-literal">null</span>;
</code></pre>
<h4 id="innerhtml-outerhtml-createtextnode-innertext-textcontent异同">innerHTML outerHTML createTextNode innerText textContent异同</h4>
<ul>
<li>相对于createTextNode而言，innerHTML和innerText可能会比通过DOM API逐个添加节点更快，因为它允许浏览器<code>一次性解析和渲染HTML内容</code></li>
<li>innerHTML 属性可以设置或获取指定元素内部的HTML内容。可以解析HTML标签、实体字符等，并将它们转换为相应的DOM元素或字符。在使用 innerHTML 时，应始终确保内容是安全的或进行适当的转义(<code>防止XSS攻击</code>)</li>
<li>使用 createTextNode <strong>只会添加纯文本内容</strong>，不会解析HTML标签或实体字符。createTextNode <code>更安全</code>，因为它不涉及HTML解析；在大型文档中，直接操作DOM节点可能会比使用 innerHTML 更慢一些，它所触发的 DOM 操作（如附加节点）可能会间接导致<code>重排</code>和重绘</li>
<li>outerHTML 属性用于获取或设置描述某个元素（包括其所有属性和内容）的序列化 HTML。当设置一个元素的 outerHTML 属性时，浏览器会尝试用新的 HTML 替换旧的元素。然而，如果这个元素没有父节点（即它是一个孤立的节点，没有附加到 DOM 中的任何位置），浏览器就无法执行替换操作，因此会<code>抛出错误</code></li>
<li>innerText 是一个属性，用于获取或设置元素的文本内容。它获取的是元素内所有文本内容的拼接，包括子元素的文本内容</li>
<li><strong>textContent</strong> 属性获取或设置指定元素的文本内容及其所有后代元素的文本内容。由于它只处理文本内容，不涉及 HTML 解析，因此通常比 innerHTML 更快</li>
<li>innerText 知道文本的渲染外观，而 textContent 不知道。所以展示时innerText会自动过滤掉隐藏的元素标签里的文本和一些不渲染的文本</li>
</ul>
<pre><code class="language-js"><span class="hljs-comment">// 创建一个 div 元素  </span>
<span class="hljs-keyword">var</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);  
  
<span class="hljs-comment">// 使用 innerHTML 设置 div 的内部 HTML 内容  </span>
div.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;这是通过 innerHTML 添加的文本，包括 &lt;b&gt;粗体&lt;/b&gt; 文字。&lt;div style=&quot;color:red&quot;&gt;red&lt;/div&gt;&#x27;</span>;  
  
<span class="hljs-comment">// 将 div 元素添加到文档的 body 中  </span>
<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(div);
</code></pre>
<p><img src="file:///e:\studying\book_files\45.jpg" alt="innerHTML"></p>
<pre><code class="language-js"><span class="hljs-comment">// 创建一个 div 元素  </span>
<span class="hljs-keyword">var</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);  
  
<span class="hljs-comment">// 使用 createTextNode 创建一个文本节点  </span>
<span class="hljs-keyword">var</span> textNode = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createTextNode</span>(
<span class="hljs-string">&#x27;这是通过 innerHTML 添加的文本，包括 &lt;b&gt;粗体&lt;/b&gt; 文字。&lt;div style=&quot;color:red&quot;&gt;red&lt;/div&gt;&#x27;</span>
);  
  
<span class="hljs-comment">// 将文本节点附加到 div 元素  </span>
div.<span class="hljs-title function_">appendChild</span>(textNode);  
  
<span class="hljs-comment">// 将 div 元素添加到文档的 body 中  </span>
<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(div);
</code></pre>
<p><img src="file:///e:\studying\book_files\46.jpg" alt="createTextNode"></p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> newElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);  
newElement.<span class="hljs-property">textContent</span> = <span class="hljs-string">&#x27;Some content&#x27;</span>;  
<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(newElement); <span class="hljs-comment">// 先附加到 body  </span>
newElement.<span class="hljs-property">outerHTML</span> = <span class="hljs-string">&#x27;&lt;a&gt;这是通过 innerHTML 添加的文本，包括 &lt;b&gt;粗体&lt;/b&gt; 文字。&lt;div style=&quot;color:red&quot;&gt;red&lt;/div&gt;&lt;/a&gt;&#x27;</span>
</code></pre>
<p><img src="file:///e:\studying\book_files\47.jpg" alt="outHTML"></p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>源元素：<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;source&quot;</span>&gt;</span>
		  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css">
		    <span class="hljs-selector-id">#source</span> {
		      <span class="hljs-attribute">color</span>: red;
		    }
		    <span class="hljs-selector-id">#text</span> {
		      <span class="hljs-attribute">text-transform</span>: uppercase;
		    }
		  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
		  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span>
		    来看看<span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>
		    这段文字<span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>
		    在下方怎么表示。
		  <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
		  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;display:none&quot;</span>&gt;</span>隐藏文字<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
		<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>textContent 结果：<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;textContentOutput&quot;</span> <span class="hljs-attr">rows</span>=<span class="hljs-string">&quot;6&quot;</span> <span class="hljs-attr">cols</span>=<span class="hljs-string">&quot;30&quot;</span> <span class="hljs-attr">readonly</span>&gt;</span>…<span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>innerText 结果：<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;innerTextOutput&quot;</span> <span class="hljs-attr">rows</span>=<span class="hljs-string">&quot;6&quot;</span> <span class="hljs-attr">cols</span>=<span class="hljs-string">&quot;30&quot;</span> <span class="hljs-attr">readonly</span>&gt;</span>…<span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span>
		
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">
	<span class="hljs-keyword">const</span> source = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;source&quot;</span>);
	<span class="hljs-keyword">const</span> textContentOutput = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;textContentOutput&quot;</span>);
	<span class="hljs-keyword">const</span> innerTextOutput = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;innerTextOutput&quot;</span>);
	
	textContentOutput.<span class="hljs-property">value</span> = source.<span class="hljs-property">textContent</span>;
	innerTextOutput.<span class="hljs-property">value</span> = source.<span class="hljs-property">innerText</span>;
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p><img src="file:///e:\studying\book_files\48.jpg" alt="innerText"></p>
<h3 id="property-和attribute使用">property 和attribute使用</h3>
<ol>
<li>Attribute：HTML属性，书写在标签内的属性，使用setAttribute()和getAttribute()进行设置和获取。</li>
<li>Property：DOM属性，html标签对应的DOM节点属性，使用 .属性名 或者 ['属性名']进行设置和获取。</li>
</ol>
<p>简单理解，Attribute就是dom节点自带的属性，例如html中常用的id、class、title、align等;而Property是这个DOM元素作为对象，其附加的内容，例如childNodes、firstChild等。</p>
<p>另外，常用的Attribute，例如id、class等，已经被作为Property附加到DOM对象上，可以和Property一样取值和赋值。但是自定义的Attribute，就不会有这样的优待。</p>
<p>两者都可能造成重新渲染，<strong>优先使用Property</strong>。</p>
<p>不管是修改attribute还是property都会影响到对方的属性值，但是输入框的input value比较特殊例外！</p>
<pre><code class="language-html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span> /&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;switch&quot;</span>&gt;</span>
			<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;k1&quot;</span>&gt;</span>男
			
	<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript">
	<span class="hljs-keyword">let</span> a=<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;input&#x27;</span>)[<span class="hljs-number">0</span>];
	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-property">value</span>===a.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&#x27;value&#x27;</span>))<span class="hljs-comment">//true</span>
	a.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;value&#x27;</span>,<span class="hljs-number">99</span>);
	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-property">value</span>===a.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&#x27;value&#x27;</span>))<span class="hljs-comment">//true</span>
	a.<span class="hljs-property">value</span>=<span class="hljs-string">&quot;19&quot;</span>
	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-property">value</span>===a.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&#x27;value&#x27;</span>))<span class="hljs-comment">//false</span>
	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-property">value</span>)<span class="hljs-comment">//19</span>
	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&quot;value&quot;</span>))<span class="hljs-comment">//99</span>
	a.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;value&#x27;</span>,<span class="hljs-number">88</span>)
	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-property">value</span>)<span class="hljs-comment">//19</span>
	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&quot;value&quot;</span>))<span class="hljs-comment">//88</span>
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

</code></pre>
<ol>
<li>如果input在html中初始设置了value，在没有任何input.value=“xxx”这种操作时，input.value===input.getAttribute(&quot;value&quot;);而且还可以继续通过input.setAttribute('value','xxx')来更改新值，input.value会同步修改。</li>
<li>当修改了input.value='xxx'后，input.getAttribute('value')和input.value似乎再也没任何交集了，input.value会反映在页面上的input框中的数据,而input的attribue中的value也就是打开控制台里的元素结构会看到<code>&lt;input type=&quot;text&quot; value=&quot;1&quot; name=&quot;sex&quot; class=&quot;k1&quot;&gt;</code>是某个值，这个值只能通过setAttribute来修改</li>
<li>value的Attriubte和property没有映射关系</li>
</ol>
<h3 id="说说-real-dom-和-virtual-dom-的区别优缺点">说说 Real DOM 和 Virtual DOM 的区别？优缺点？</h3>
<p>Real DOM，真实 DOM，意思为文档对象模型，是一个结构化文本的抽象，在页面渲染出的每一个结点都是一个真实 DOM结构</p>
<p><img src="file:///e:\studying\book_files\55.jpg" alt="real dom"></p>
<p>Virtual Dom，本质上是以 JavaScript 对象形式存在的对 DOM 的描述</p>
<p>创建虚拟 DOM 目的就是为了更好将虚拟的节点渲染到页面视图中，虚拟 DOM 对象的节点与真实 DOM 的属性一一照应</p>
<pre><code class="language-js"><span class="hljs-comment">// 创建 h1 标签，右边千万不能加引号</span>
<span class="hljs-keyword">const</span> vDom = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>; 
<span class="hljs-comment">// 找到 &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; 节点</span>
<span class="hljs-keyword">const</span> root = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;root&quot;</span>); 
<span class="hljs-comment">// 把创建的 h1 标签渲染到 root 节点上</span>
<span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(vDom, root); 
</code></pre>
<p>JSX 实际是一种语法糖，在使用过程中会被 babel 进行编译转化成 JS 代码</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> vDom = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(
  <span class="hljs-string">&#x27;h1&#x27;</span>，
  { <span class="hljs-attr">className</span>: <span class="hljs-string">&#x27;hClass&#x27;</span>, <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;hId&#x27;</span> },
  <span class="hljs-string">&#x27;hello world&#x27;</span>
)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(vDom)
</code></pre>
<p><img src="file:///e:\studying\book_files\56.jpg" alt="vdom"></p>
<p>JSX 通过 babel 的方式转化成 React.createElement 执行，返回值是一个对象，也就是虚拟 DOM</p>
<ol>
<li>两者的区别如下：
<ul>
<li>虚拟 DOM 不会进行排版与重绘操作，而真实 DOM 会频繁重排与重绘</li>
<li>虚拟 DOM 的总损耗是“虚拟 DOM 增删改+真实 DOM 差异增删改+排版与重绘”，真实 DOM 的总损耗是“真实 DOM 完全增删改+排版与重绘”</li>
</ul>
</li>
</ol>
<p>传统的原生 api 或 jQuery 去操作 DOM 时，浏览器会从构建 DOM 树开始从头到尾执行一遍流程</p>
<p>当你在一次操作时，需要更新 10 个 DOM 节点，浏览器没这么智能，收到第一个更新 DOM 请求后，并不知道后续还有 9 次更新操作，因此会马上执行流程，最终执行 10 次流程</p>
<p>而通过 VNode，同样更新 10 个 DOM 节点，虚拟 DOM 不会立即操作 DOM，而是将这 10 次更新的 diff 内容保存到本地的一个 js 对象中，最终将这个 js 对象一次性 attach 到 DOM 树上，避免大量的无谓计算</p>
<ol start="2">
<li>真实 DOM 的优势：易用</li>
<li>缺点：
<ul>
<li>效率低，解析速度慢，内存占用量过高</li>
<li>性能差：频繁操作真实 DOM，易于导致重绘与回流</li>
</ul>
</li>
</ol>
<p>使用虚拟 DOM 的优势如下：</p>
<ul>
<li>简单方便：如果使用手动操作真实 DOM 来完成页面，繁琐又容易出错，在大规模应用下维护起来也很困难</li>
<li>性能方面：使用 Virtual DOM，能够有效避免真实 DOM 数频繁更新，减少多次引起重绘与回流，提高性能</li>
<li>跨平台：React 借助虚拟 DOM，带来了跨平台的能力，一套代码多端运行</li>
</ul>
<p>缺点：</p>
<ul>
<li>在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化</li>
<li>首次渲染大量 DOM 时，由于多了一层虚拟 DOM 的计算，速度比正常稍慢</li>
</ul>
<h3 id="windowonload和-domcontentloaded即ready区别">Window.onload和 DOMContentLoaded（即ready）区别</h3>
<p>如非必要，优先使用DOMContentLoaded（jquery采用），体验感更好</p>
<p><img src="file:///e:\studying\book_files\57.jpg" alt="load"></p>
<h2 id="bom">BOM</h2>
<h3 id="bom的含义">BOM的含义</h3>
<p>**浏览器对象模型（Browser Object Model）**的简称，它提供了一组JavaScript API，用于管理浏览器窗口和框架。</p>
<p>BOM的核心是window，它表示浏览器的一个实例。</p>
<ul>
<li>navigator.userAgent：判断浏览器类型</li>
</ul>
<h4 id="moveto-moveby-scrollto-scrollby-resizeto-resizeby">moveTo moveBy scrollTo scrollBy resizeTo resizeBy</h4>
<ul>
<li>To:类似绝对，moveTo，以左上方原点，移动scrollTo，窗口滚动条横向最左侧或者纵向最上方位置计算，resizeTo：设置为宽高多少的窗口</li>
<li>By:类似相对，moveBy，以当前位置为原点，移动，scrollBy，以滚动条当前位置，挪动，resizeBy：以当前宽高为基准，增减</li>
</ul>
<pre><code class="language-js"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">resizeTo</span>(<span class="hljs-number">800</span>, <span class="hljs-number">600</span>); <span class="hljs-comment">// 将窗口大小调整为800像素宽，600像素高</span>
<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">resizeBy</span>(<span class="hljs-number">100</span>, -<span class="hljs-number">50</span>); <span class="hljs-comment">// 将窗口宽度增加100像素，高度减少50像素</span>

<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">scrollTo</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1000</span>); <span class="hljs-comment">// 将窗口滚动到垂直位置1000像素处</span>
<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">scrollBy</span>(<span class="hljs-number">50</span>, -<span class="hljs-number">100</span>); <span class="hljs-comment">// 将窗口向右滚动50像素，向上滚动100像素</span>

<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">moveTo</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// 将窗口左上角移动到屏幕左上角  </span>
<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">moveBy</span>(<span class="hljs-number">50</span>, <span class="hljs-number">100</span>); <span class="hljs-comment">// 将窗口向右移动50像素，向下移动100像素  </span>
</code></pre>
<h3 id="location">location</h3>
<p>它提供了关于当前窗口或标签页中显示的URL的信息，并允许你解析URL的各个部分，以及重定向浏览器到新的URL</p>
<p><img src="file:///e:\studying\book_files\49.jpg" alt="location"></p>
<ul>
<li>hash改变，不会发送请求，因为 hash 部分（即URL中 # 符号及其后面的部分）通常用于表示页面内的某个位置或状态</li>
<li>而路由history模式，由于使用了History API【<code>history.pushState()</code> 和 <code>history.replaceState()</code>（在不重新加载页面的情况下修改历史记录）】，它们不会导致页面重新加载或发送HTTP请求到服务器。相反，前端js代码会监听这些URL变化，并相应地更新页面内容或组件，从而实现SPA中的无刷新页面导航。</li>
</ul>
<h3 id="history">history</h3>
<p>History 对象是 window 对象的一部分，可通过 window.history 属性对其进行访问。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>length</td>
<td>返回浏览器历史列表中的 URL 数量。</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>back()</td>
<td>加载 history 列表中的前一个 URL。</td>
</tr>
<tr>
<td>forward()</td>
<td>加载 history 列表中的下一个 URL。</td>
</tr>
<tr>
<td>go()</td>
<td>可加载历史列表中的某个具体的页面。</td>
</tr>
</tbody>
</table>
<p>go() 方法。</p>
<pre><code class="language-js">history.<span class="hljs-title function_">go</span>(number) <span class="hljs-comment">//-1上一个页面，1前进一个页面</span>
</code></pre>
<h3 id="获取当前页面url参数">获取当前页面URL参数</h3>
<pre><code class="language-js"><span class="hljs-comment">// // 传统方式</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">query</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-keyword">const</span> search = location.<span class="hljs-property">search</span>.<span class="hljs-title function_">substr</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">// 类似 array.slice(1)</span>
     <span class="hljs-comment">//a=30&amp;b=40&amp;c=50&amp;d=60</span>
    <span class="hljs-keyword">const</span> reg = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">`(^|&amp;)<span class="hljs-subst">${name}</span>=([^&amp;]*)(&amp;|$)`</span>, <span class="hljs-string">&#x27;i&#x27;</span>)
    <span class="hljs-keyword">const</span> res = search.<span class="hljs-title function_">match</span>(reg)
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(res)
    <span class="hljs-keyword">if</span> (res === <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
    }
    <span class="hljs-keyword">return</span> res[<span class="hljs-number">2</span>]
}
<span class="hljs-comment">// 第一位匹配到的全局，后面依次是每个小括号对应的</span>
<span class="hljs-comment">// ([^&amp;]*)：非&amp;符号的内容</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-title function_">query</span>(<span class="hljs-string">&#x27;a&#x27;</span>))
<span class="hljs-comment">//  [&#x27;&amp;c=50&amp;&#x27;, &#x27;&amp;&#x27;, &#x27;50&#x27;, &#x27;&amp;&#x27;, index: 9, input: &#x27;a=30&amp;b=40&amp;c=50&amp;d=60&#x27;, groups: undefined]</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-title function_">query</span>(<span class="hljs-string">&#x27;c&#x27;</span>))
<span class="hljs-comment">// [&#x27;a=30&amp;&#x27;, &#x27;&#x27;, &#x27;30&#x27;, &#x27;&amp;&#x27;, index: 0, input: &#x27;a=30&amp;b=40&amp;c=50&amp;d=60&#x27;, groups: undefined]</span>
</code></pre>
<p>也可以不使用正则，利用&amp;符合=号拆分两次获取。</p>
<p>利用URLSearchParams这个API，注意兼容性</p>
<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">query</span>(<span class="hljs-params">name</span>) {
        <span class="hljs-keyword">const</span> search = location.<span class="hljs-property">search</span>
        <span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLSearchParams</span>(search)
        <span class="hljs-keyword">return</span> p.<span class="hljs-title function_">get</span>(name)
    }
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( <span class="hljs-title function_">query</span>(<span class="hljs-string">&#x27;b&#x27;</span>) )
</code></pre>
<h2 id="移动端">移动端</h2>
<h3 id="上拉加载下拉刷新实现">上拉加载下拉刷新实现</h3>
<p>上拉加载本质是触底
<img src="file:///e:\studying\book_files\51.jpg" alt="原理"></p>
<pre><code class="language-js">scrollTop + clientHeight &gt;= scrollHeight
</code></pre>
<pre><code class="language-js"><span class="hljs-keyword">let</span> clientHeight = <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">clientHeight</span>; <span class="hljs-comment">//</span>
<span class="hljs-keyword">let</span> scrollHeight = <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">scrollHeight</span>;
<span class="hljs-keyword">let</span> scrollTop = <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">scrollTop</span>;
<span class="hljs-keyword">let</span> distance = <span class="hljs-number">50</span>; <span class="hljs-comment">// 50</span>
<span class="hljs-keyword">if</span> ((scrollTop + clientHeight) &gt;= (scrollHeight - distance)) {
 <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;xxx&quot;</span>);
}
</code></pre>
<p>下拉刷新则是监听touch事件</p>
<h3 id="rem-em-vw-vh-dpr">rem em vw vh dpr</h3>
<ol>
<li>rem: 相对大小，但相对的只是HTML根元素</li>
<li>em:  继承父级元素的字体大小</li>
<li>vw:window.innerWidth = 100vw</li>
<li>vh:window.innerHeight = 100vh</li>
<li>vmax:取vh/vw中大值</li>
<li>vmin: 取vh/vw中小</li>
<li>dpr（设备像素比）：是指<code>设备物理像素的个数</code>除以<code>设备独立像素</code>的大小。物理像素是手机屏幕上一个一个的发光的点，大小是固定的；独立像素也叫做逻辑像素，css设置的像素大小就是逻辑像素。</li>
</ol>
<p><code>window.devicePixelRatio</code>可获取，无缩放的情况下，1个css像素 === 一个设备独立像素</p>
<p><img src="file:///e:\studying\book_files\20.jpg" alt="dpr"></p>
<h4 id="移动端1px实现">移动端1px实现</h4>
<ul>
<li>border-image:需要图片</li>
<li>background-image：因为每个边框都是线性渐变颜色实现，因此无法实现圆角。</li>
<li>box-shadow:不好控制</li>
<li>媒体查询：兼容性</li>
<li>:after transform (其实无非是把1px缩放为0.5px，<strong>0.5px并不是所有都支持</strong>(iOS8以上支持)。)</li>
</ul>
<pre><code class="language-html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>  
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>  
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>  
<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span>  
<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>  
<span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>1px Border with Transform and After<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>  
<span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css">  
  <span class="hljs-selector-class">.border-1px</span> {  
    <span class="hljs-attribute">position</span>: relative;  
    <span class="hljs-attribute">background-color</span>: white;  
  }  
  <span class="hljs-selector-class">.border-1px</span><span class="hljs-selector-pseudo">::after</span> {  
    <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;  
    <span class="hljs-attribute">position</span>: absolute;  
    <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;  
    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;  
    <span class="hljs-attribute">width</span>: <span class="hljs-number">200%</span>;  
    <span class="hljs-attribute">height</span>: <span class="hljs-number">200%</span>;  
    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#000</span>;  
    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">0.5</span>);  
    <span class="hljs-attribute">transform-origin</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span>;  
    <span class="hljs-attribute">box-sizing</span>: border-box;  
    <span class="hljs-attribute">pointer-events</span>: none; <span class="hljs-comment">/* 防止影响点击事件 */</span>  
  }  
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>  
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;border-1px&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 200px; height: 100px;&quot;</span>&gt;</span>  
  使用transform和伪元素的1px边框  
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>  
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<ul>
<li>viewport + rem</li>
</ul>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;WebViewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&quot;</span>&gt;</span>
</code></pre>
<pre><code class="language-js"><span class="hljs-keyword">var</span> viewport = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;meta[name=viewport]&quot;</span>)
<span class="hljs-keyword">if</span> (<span class="hljs-variable language_">window</span>.<span class="hljs-property">devicePixelRatio</span> == <span class="hljs-number">1</span>) {
    viewport.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;content&#x27;</span>, <span class="hljs-string">&#x27;width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&#x27;</span>)
} 
<span class="hljs-keyword">if</span> (<span class="hljs-variable language_">window</span>.<span class="hljs-property">devicePixelRatio</span> == <span class="hljs-number">2</span>) {
    viewport.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;content&#x27;</span>, <span class="hljs-string">&#x27;width=device-width, initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no&#x27;</span>)
} 
<span class="hljs-keyword">if</span> (<span class="hljs-variable language_">window</span>.<span class="hljs-property">devicePixelRatio</span> == <span class="hljs-number">3</span>) {
    viewport.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;content&#x27;</span>, <span class="hljs-string">&#x27;width=device-width, initial-scale=0.333333333, maximum-scale=0.333333333, minimum-scale=0.333333333, user-scalable=no&#x27;</span>)
} 
<span class="hljs-keyword">var</span> docEl = <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>;
<span class="hljs-keyword">var</span> fontsize = <span class="hljs-number">10</span> * (docEl.<span class="hljs-property">clientWidth</span> / <span class="hljs-number">320</span>) + <span class="hljs-string">&#x27;px&#x27;</span>;
docEl.<span class="hljs-property">style</span>.<span class="hljs-property">fontSize</span> = fontsize;
</code></pre>
<ul>
<li>svg，postcss-write-svg(小插件，只适合画直线)</li>
</ul>
<h4 id="移动端2x3x图">移动端2X3X图</h4>
<ul>
<li>srcset</li>
</ul>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">&quot;my-image@1x.png 1x, my-image@2x.png 2x, my-image@3x.png 3x&quot;</span>  
     <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;my-image@1x.png&quot;</span>  
     <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;My Image&quot;</span>  
     <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width:100%;height:auto;&quot;</span>&gt;</span>
</code></pre>
<ul>
<li>媒体查询 兼容性差，目前之余IOS8+才支持，在IOS7及其以下、安卓系统都是显示0px。</li>
</ul>
<pre><code class="language-css"><span class="hljs-selector-class">.my-element</span> {  
  <span class="hljs-comment">/* 默认背景图像，用于1倍像素密度的设备 */</span>  
  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;my-image@1x.png&#x27;</span>);  
}  
  <span class="hljs-comment">/* 针对2倍像素密度的设备 */</span>
<span class="hljs-keyword">@media</span> (<span class="hljs-attribute">-webkit-min-device-pixel-ratio</span>: <span class="hljs-number">2</span>), (<span class="hljs-attribute">min-resolution</span>: <span class="hljs-number">192dpi</span>) { 
  <span class="hljs-selector-class">.my-element</span> {  
    <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;my-image@2x.png&#x27;</span>);  
  }  
}  
  
	<span class="hljs-comment">/* 针对3倍像素密度的设备 */</span>  
<span class="hljs-keyword">@media</span> (<span class="hljs-attribute">-webkit-min-device-pixel-ratio</span>: <span class="hljs-number">3</span>), (<span class="hljs-attribute">min-resolution</span>: <span class="hljs-number">288dpi</span>) {  
  <span class="hljs-selector-class">.my-element</span> {  
    <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;my-image@3x.png&#x27;</span>);  
  }  
}
</code></pre>
<ul>
<li>js处理</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">setAppropriateImageSrc</span>(<span class="hljs-params"></span>) {  
  <span class="hljs-keyword">var</span> image = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;my-image&#x27;</span>);  
  <span class="hljs-keyword">var</span> dpr = <span class="hljs-variable language_">window</span>.<span class="hljs-property">devicePixelRatio</span> || <span class="hljs-number">1</span>;  
  <span class="hljs-keyword">var</span> src;  
  
  <span class="hljs-keyword">if</span> (dpr &gt;= <span class="hljs-number">3</span>) {  
    src = <span class="hljs-string">&#x27;my-image@3x.png&#x27;</span>;  
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dpr &gt;= <span class="hljs-number">2</span>) {  
    src = <span class="hljs-string">&#x27;my-image@2x.png&#x27;</span>;  
  } <span class="hljs-keyword">else</span> {  
    src = <span class="hljs-string">&#x27;my-image@1x.png&#x27;</span>;  
  }  
  
  image.<span class="hljs-property">src</span> = src;  
}  
  
<span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span> = setAppropriateImageSrc;  
<span class="hljs-comment">// 如果需要监听窗口大小变化，可以添加以下事件监听器  </span>
<span class="hljs-variable language_">window</span>.<span class="hljs-property">onresize</span> = setAppropriateImageSrc;
</code></pre>
<h2 id="http">http</h2>
<h3 id="从输入url到渲染页面的整个过程">从输入URL到渲染页面的整个过程</h3>
<ol>
<li>DNS解析：域名=&gt;IP地址</li>
<li>浏览器根据IP地址向服务器发起http请求</li>
<li>服务器处理http请求，并将对应资源返回给浏览器</li>
<li>根据HTML代码生成DOM Tree，根据CSS代码生成CSSOM（css对象模型）</li>
<li>将DOM Tree和 CSSOM整合形成Render Tree</li>
<li>根据Render Tree渲染页面</li>
<li>遇到script标签停止渲染，加载并执行js，完成后再继续执行</li>
<li>直至整个Render 渲染完成</li>
</ol>
<h3 id="http状态码">http状态码</h3>
<table>
<thead>
<tr>
<th>状态码</th>
<th>状态码英文名称</th>
<th>中文描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>100</td>
<td>Continue</td>
<td>继续。客户端应继续其请求</td>
</tr>
<tr>
<td>200</td>
<td>OK</td>
<td>请求成功。一般用于GET与POST请求</td>
</tr>
<tr>
<td>204</td>
<td>No Content</td>
<td>无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td>
</tr>
<tr>
<td><strong>304</strong></td>
<td>Not Modified</td>
<td><strong>未修改</strong> 。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td>
</tr>
<tr>
<td><strong>400</strong></td>
<td><strong>Bad Request</strong></td>
<td><strong>客户端请求的语法错误，服务器无法理解</strong></td>
</tr>
<tr>
<td><strong>401</strong></td>
<td><strong>Unauthorized</strong></td>
<td>请求要求用户的身份认证</td>
</tr>
<tr>
<td>403</td>
<td><strong>Forbidden</strong></td>
<td>服务器理解请求客户端的请求，但是拒绝执行此请求</td>
</tr>
<tr>
<td>404</td>
<td>Not Found</td>
<td>服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置&quot;您所请求的资源无法找到&quot;的个性页面</td>
</tr>
<tr>
<td>405</td>
<td>Method Not Allowed</td>
<td>客户端请求中的方法被禁止，可能是请求方法错误</td>
</tr>
<tr>
<td>412</td>
<td>-</td>
<td>先决条件错误</td>
</tr>
<tr>
<td><strong>413</strong></td>
<td>Request Entity Too Large</td>
<td>由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息【后端可配置放大实体】</td>
</tr>
<tr>
<td>415</td>
<td>Unsupported Media Type</td>
<td>服务器无法处理请求附带的媒体格式</td>
</tr>
<tr>
<td>500</td>
<td>Internal Server Error</td>
<td>服务器内部错误，无法完成请求</td>
</tr>
<tr>
<td>501</td>
<td>Not Implemented</td>
<td>服务器不支持请求的功能，无法完成请求</td>
</tr>
<tr>
<td>502</td>
<td>Bad Gateway</td>
<td>作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td>
</tr>
<tr>
<td>504</td>
<td>Gateway Time-out</td>
<td>充当网关或代理的服务器，未及时从远端服务器获取请求</td>
</tr>
</tbody>
</table>
<h3 id="udp-tcp">UDP TCP</h3>
<p>UDP（<code>User Datagram Protocol，用户数据报协议</code>）和TCP（<code>Transmission Control Protocol，传输控制协议</code>）是两种在计算机网络中广泛使用的传输层协议，它们各自具有不同的特点和适用场景。</p>
<ul>
<li>UDP 协议是面向无连接的，也就是说不需要在正式传递数据之前先连接起双方。特点：不可靠性但高效，如航空信息应用、直播和视频会议等</li>
<li>TCP 一种面向连接的、可靠的、基于字节流的传输层通信协议，为了保证可靠性，速度较慢。TCP适用于那些需要确保数据完整性和顺序性的场景，如文件传输和电子邮件等。</li>
</ul>
<h3 id="http11-和-http2">http1.1 和 http2</h3>
<p>从传输方式和效率上看，HTTP/1.1采用报文形式传输，而HTTP/2则采用<strong>二进制格式传输数据</strong>。这种二进制传输方式使得HTTP/2具有更高的解析效率和更少的传输开销。此外，<strong>HTTP/1.1如果想并发多个请求，必须使用多个TCP链接</strong>，这会导致一定的延时和内存消耗。而在HTTP/2中，由于采用了<strong>二进制分帧技术</strong>，同域名下所有通信都在单个连接上完成，单个连接可以承载任意数量的双向数据流。这使得HTTP/2能够<strong>并行交错</strong>地发送多个请求和响应，提高了网络吞吐量和效率。</p>
<p>其次，在协议细节上，HTTP/2使用了HPACK算法对HTTP<strong>头部进行压缩</strong>，减少了头部传输的数据量，从而进一步减少了网络延迟。同时，HTTP/2还支持<strong>服务器推送</strong>，允许服务器在客户端请求之前推送资源，提高了性能。</p>
<p>最后，HTTP/2与HTTP/1.1的兼容性也是两者之间的一个重要区别。HTTP/2可以与HTTP/1.1共存，服务器可以同时支持HTTP/1.1和HTTP/2。如果客户端不支持HTTP/2，服务器可以回退到HTTP/1.1。</p>
<p>总的来说，HTTP/2在多个方面对HTTP/1.1进行了改进和优化，提供了更高的效率、更低的延迟和更好的兼容性。这使得HTTP/2成为现代Web应用中更受欢迎的选择。</p>
<h3 id="浏览器缓存">浏览器缓存</h3>
<p>浏览器缓存（Browser Caching）是为了节约网络资源、加速浏览而设计的一种机制。</p>
<p><img src="file:///e:\studying\book_files\100.jpg" alt="缓存"></p>
<h4 id="强缓存">强缓存</h4>
<p>可以造成强制缓存的字段是 <code>Cache-control</code>（推荐） 和 <code>Expires</code>(不推荐)。</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);  
<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();  
<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);  
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);  
  
<span class="hljs-comment">// 设置静态文件目录  </span>
app.<span class="hljs-title function_">use</span>(express.<span class="hljs-title function_">static</span>(<span class="hljs-string">&#x27;public&#x27;</span>));  
  
<span class="hljs-comment">// 为特定路由设置强缓存  </span>
app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/cached-resource&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {  
  <span class="hljs-keyword">const</span> filePath = path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;public&#x27;</span>, <span class="hljs-string">&#x27;cached-resource.txt&#x27;</span>);  
  <span class="hljs-keyword">const</span> stats = fs.<span class="hljs-title function_">statSync</span>(filePath);  
  <span class="hljs-keyword">const</span> lastModified = stats.<span class="hljs-property">mtime</span>.<span class="hljs-title function_">toUTCString</span>(); <span class="hljs-comment">// 获取文件最后修改时间  </span>
  <span class="hljs-keyword">const</span> maxAge = <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">24</span> * <span class="hljs-number">7</span>; <span class="hljs-comment">// 设置缓存有效期为7天  </span>
  
  <span class="hljs-comment">// 设置强缓存响应头  </span>
  res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Cache-Control&#x27;</span>, <span class="hljs-string">`public, max-age=<span class="hljs-subst">${maxAge}</span>`</span>);  
  res.<span class="hljs-title function_">setHeader</span>(<span class="hljs-string">&#x27;Last-Modified&#x27;</span>, lastModified);  
  res.<span class="hljs-title function_">sendFile</span>(filePath);  
});  
  
app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> {  
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Server is running on port 3000&#x27;</span>);  
});
</code></pre>
<h4 id="协商缓存">协商缓存</h4>
<p>etag优先级大于lastModified，lastModified最多只能处理秒级的缓存。</p>
<ul>
<li>if-modified-since lastModified</li>
<li>if-none-match etag(更推荐)</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);  
<span class="hljs-keyword">const</span> crypto = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;crypto&#x27;</span>);  
<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);  
<span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);  
  
<span class="hljs-keyword">const</span> server = http.<span class="hljs-title function_">createServer</span>(<span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> {  
  <span class="hljs-keyword">const</span> filePath = path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;path/to/your/file&#x27;</span>);  
  <span class="hljs-keyword">const</span> stats = fs.<span class="hljs-title function_">statSync</span>(filePath);  
  <span class="hljs-keyword">const</span> lastModified = stats.<span class="hljs-property">mtime</span>.<span class="hljs-title function_">toUTCString</span>(); <span class="hljs-comment">// 获取文件的最后修改时间  </span>
  <span class="hljs-keyword">const</span> fileContent = fs.<span class="hljs-title function_">readFileSync</span>(filePath);  
  <span class="hljs-keyword">const</span> etag = crypto.<span class="hljs-title function_">createHash</span>(<span class="hljs-string">&#x27;md5&#x27;</span>).<span class="hljs-title function_">update</span>(fileContent).<span class="hljs-title function_">digest</span>(<span class="hljs-string">&#x27;hex&#x27;</span>); <span class="hljs-comment">// 计算文件的ETag  </span>
  
  <span class="hljs-comment">// 检查If-None-Match请求头  </span>
  <span class="hljs-keyword">if</span> (req.<span class="hljs-property">headers</span>[<span class="hljs-string">&#x27;if-none-match&#x27;</span>] &amp;&amp; req.<span class="hljs-property">headers</span>[<span class="hljs-string">&#x27;if-none-match&#x27;</span>] === etag) {  
    <span class="hljs-comment">// 如果ETag匹配，返回304 Not Modified  </span>
    res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">304</span>, {  
      <span class="hljs-string">&#x27;ETag&#x27;</span>: etag,  
      <span class="hljs-string">&#x27;Last-Modified&#x27;</span>: lastModified  
    });  
    res.<span class="hljs-title function_">end</span>();  
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (req.<span class="hljs-property">headers</span>[<span class="hljs-string">&#x27;if-modified-since&#x27;</span>] &amp;&amp; req.<span class="hljs-property">headers</span>[<span class="hljs-string">&#x27;if-modified-since&#x27;</span>] === lastModified) {  
    <span class="hljs-comment">// 如果Last-Modified匹配，也返回304 Not Modified  </span>
    res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">304</span>, {  
      <span class="hljs-string">&#x27;ETag&#x27;</span>: etag,  
      <span class="hljs-string">&#x27;Last-Modified&#x27;</span>: lastModified  
    });  
    res.<span class="hljs-title function_">end</span>();  
  } <span class="hljs-keyword">else</span> {  
    <span class="hljs-comment">// 如果都不匹配，发送新文件内容，并设置Last-Modified和ETag头  </span>
    res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, {  
      <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;text/plain&#x27;</span>,  
      <span class="hljs-string">&#x27;ETag&#x27;</span>: etag,  
      <span class="hljs-string">&#x27;Last-Modified&#x27;</span>: lastModified  
    });  
    res.<span class="hljs-title function_">end</span>(fileContent);  
  }  
});  
  
server.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);
</code></pre>
<h3 id="http头部字段">http头部字段</h3>
<p>有 4 种类型的首部字段：通用首部字段、请求首部字段、响应首部字段和实体首部字段。</p>
<ul>
<li>通用首部字段
<img src="file:///e:\studying\book_files\102.jpg" alt="1"></li>
<li>请求首部字段
<img src="file:///e:\studying\book_files\103.jpg" alt="2">
<img src="file:///e:\studying\book_files\104.jpg" alt="3"></li>
<li>响应首部字段
<img src="file:///e:\studying\book_files\105.jpg" alt="4"></li>
<li>实体首部字段
<img src="file:///e:\studying\book_files\106.jpg" alt="5"></li>
</ul>
<h4 id="if-match的用法">if-match的用法</h4>
<ul>
<li>If-None-Match 通常用于 GET 请求，以验证客户端缓存的资源是否仍然有效。如果有效，服务器返回 304 状态码，客户端继续使用缓存资源；否则，服务器返回新的资源内容和新的 ETag。</li>
<li>If-Match 通常用于 PUT、DELETE 或其他可能修改资源的请求，以确保客户端请求的资源版本与服务器上的版本一致。这有助于防止在并发修改时发生数据冲突。</li>
</ul>
<p>If-Match 和其他与预条件相关的头部字段在以下场景中特别有用：</p>
<ul>
<li>防止丢失更新：当多个客户端尝试同时修改同一个资源时，使用 If-Match 可以确保一个客户端不会覆盖另一个客户端的更改。</li>
<li>条件性请求：在某些情况下，客户端可能只想在特定条件下执行请求。例如，只有当资源自上次检索以来未被修改时，才获取该资源的新表示形式。</li>
</ul>
<p>通过适当使用这些预条件头部字段和处理 412 Precondition Failed 状态码，客户端和服务器可以协同工作，以确保数据的一致性和完整性。</p>
<p>与强缓存和协商缓存不同（浏览器默认操作，前端不需要做操作），这里前端需要主动传递If-Match的值，这个值是某次交互后从后端的response中去获取的。</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> axios = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;axios&#x27;</span>);  
  
<span class="hljs-comment">// 假设你有一个资源的 URL 和它的当前 ETag  </span>
<span class="hljs-keyword">const</span> resourceUrl = <span class="hljs-string">&#x27;http://example.com/some-resource&#x27;</span>;  

<span class="hljs-comment">// // 假设你从服务器的响应头中获取了 ETag  </span>
<span class="hljs-comment">// const etag = response.headers.get(&#x27;ETag&#x27;);  </span>
  
<span class="hljs-comment">// // 将 ETag 保存到 localStorage  </span>
<span class="hljs-comment">// localStorage.setItem(&#x27;resource-etag&#x27;, etag); </span>

<span class="hljs-keyword">const</span> currentETag = <span class="hljs-string">&#x27;&quot;current-etag-value&quot;&#x27;</span>;  
  
<span class="hljs-comment">// 准备 PUT 请求的数据  </span>
<span class="hljs-keyword">const</span> updateData = {  
  <span class="hljs-attr">updatedField</span>: <span class="hljs-string">&#x27;newValue&#x27;</span>  
};  
  
<span class="hljs-comment">// 发送 PUT 请求，包含 If-Match 头部  </span>
<span class="hljs-title function_">axios</span>({  
  <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;put&#x27;</span>,  
  <span class="hljs-attr">url</span>: resourceUrl,  
  <span class="hljs-attr">data</span>: updateData,  
  <span class="hljs-attr">headers</span>: {  
    <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>,  
    <span class="hljs-string">&#x27;If-Match&#x27;</span>: currentETag <span class="hljs-comment">// 设置 If-Match 头部字段  </span>
  }  
})  
.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> {  
  <span class="hljs-comment">// 请求成功，处理响应数据  </span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Resource updated successfully&#x27;</span>, response.<span class="hljs-property">data</span>);  
})  
.<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {  
  <span class="hljs-keyword">if</span> (error.<span class="hljs-property">response</span> &amp;&amp; error.<span class="hljs-property">response</span>.<span class="hljs-property">status</span> === <span class="hljs-number">412</span>) {  
    <span class="hljs-comment">// 收到 412 Precondition Failed 状态码  </span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Precondition Failed: The resource has been modified since last retrieved. Fetch the latest version and try again.&#x27;</span>);  
      
    <span class="hljs-comment">// 在这里，你可以重新获取资源的当前状态，并重新尝试更新  </span>
    <span class="hljs-comment">// 例如，发送一个 GET 请求来获取新的 ETag 和资源状态  </span>
    <span class="hljs-comment">// 然后根据新的信息重新构造并发送 PUT 请求  </span>
  } <span class="hljs-keyword">else</span> {  
    <span class="hljs-comment">// 处理其他类型的错误  </span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;An error occurred:&#x27;</span>, error);  
  }  
});
</code></pre>
<h2 id="性能优化">性能优化</h2>
<p><img src="file:///e:\studying\book_files\101.jpg" alt="性能优化"></p>
<h3 id="为什么css在页面headjs在body尾部">为什么css在页面head，js在body尾部</h3>
<p>CSS在加载过程中，不影响HTML的解析。但影响HTML渲染。</p>
<p>假如将css放在body的尾部，会产生一种情况。解析html生成DOM树，而后没有css。所以直接生成渲染树，然后生成布局树渲染网页。直到解析到css时，生成CSSOM。CSSOM与DOM树合并生成渲染树，然后再一次生成布局树渲染网页。</p>
<p>这样会渲染树多生成了一次，并且页面也多渲染了一次。造成性能损耗。</p>
<p>JS在加载时，HTML会暂停解析。</p>
<p>如果JS在页面的首部，那么会造成一种情况。长时间加载JS导致HTML无法解析，页面长时间无法响应。所以JS放在body尾部。</p>
<p>或者给JS添加defer/async</p>
<p>defer和async都是异步加载JS的方法：</p>
<p>不同：defer脚本加载完后立即执行。</p>
<ul>
<li>async脚本是html完全解析生成DOM树后立即执行。</li>
<li>如果多个JS脚本添加defer 执行顺序是无序的。而async是按加载顺序执行的。</li>
</ul>
<h3 id="浅谈前端性能优化">浅谈前端性能优化</h3>
<p>优化原则：多使用内存，缓存，减少cpu计算量，减少网络加载耗时【空间换时间】</p>
<ol>
<li>减少资源体积：代码压缩</li>
<li>减少访问次数：代码合并，SSR服务端渲染（网页和数据一起渲染），缓存【如webpack打包文件对应的名称和hash值没变，会走304】</li>
<li>使用更快的网络：CDN</li>
<li>css放在头部，js放在底部</li>
<li>尽早的执行js，用DOMContnetLoaded触发</li>
<li>懒加载</li>
<li>对DOM查询进行缓存</li>
<li>利用fragment文档碎片一次插入多条</li>
<li>节流（拖拽） 防抖（输入框）</li>
<li>根据项目需要，按需加载</li>
<li>动画帧代替定时器动画或者结合动画帧优化定时器动画（使用动画帧切屏浏览器会帮助自动停止动画渲染）</li>
</ol>
<h3 id="长列表虚拟列表">长列表虚拟列表</h3>
<ol>
<li>方案1：借助scrollTop + slice + 设置好高度 + startIndex + endIndex</li>
</ol>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model.number</span>=<span class="hljs-string">&quot;dataLength&quot;</span>&gt;</span>条
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;virtual-scroller&quot;</span> @<span class="hljs-attr">scroll</span>=<span class="hljs-string">&quot;onScroll&quot;</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;{ height: 600 + &#x27;px&#x27; }&quot;</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;phantom&quot;</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;{ height: this.dataLength * itemHeight + &#x27;px&#x27; }&quot;</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;{ &#x27;margin-top&#x27;: `${scrollTop}px` }&quot;</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in visibleList&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.brandId&quot;</span>
            <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;{ height: `${itemHeight}px`, &#x27;line-height&#x27;: `${itemHeight}px` }&quot;</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
              <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{{ item.name }}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
          <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;vue-virtual-scroller&quot;</span>,
  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">itemHeight</span>: <span class="hljs-number">60</span>,
      <span class="hljs-attr">dataLength</span>: <span class="hljs-number">500000</span>, <span class="hljs-comment">// 总数量</span>
      <span class="hljs-attr">startIndex</span>: <span class="hljs-number">0</span>,
      <span class="hljs-attr">endIndex</span>: <span class="hljs-number">10</span>,
      <span class="hljs-attr">scrollTop</span>: <span class="hljs-number">0</span>
    }
  },
  <span class="hljs-attr">computed</span>: {
    <span class="hljs-title function_">dataList</span>(<span class="hljs-params"></span>) {
      <span class="hljs-keyword">const</span> newDataList = [...<span class="hljs-title class_">Array</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">dataLength</span> || <span class="hljs-number">0</span>).<span class="hljs-title function_">keys</span>()].<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">v, i</span>) =&gt;</span> ({
        <span class="hljs-attr">brandId</span>: i + <span class="hljs-number">1</span>,
        <span class="hljs-attr">name</span>: <span class="hljs-string">`第<span class="hljs-subst">${i + <span class="hljs-number">1</span>}</span>项`</span>,
        <span class="hljs-attr">height</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">itemHeight</span>
      }));
      <span class="hljs-keyword">return</span> newDataList
    },
    <span class="hljs-title function_">visibleList</span>(<span class="hljs-params"></span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">startIndex</span>)
      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">dataList</span>.<span class="hljs-title function_">slice</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">startIndex</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">endIndex</span>)
    }
  },
  <span class="hljs-attr">methods</span>: {
    <span class="hljs-title function_">onScroll</span>(<span class="hljs-params">e</span>) {
      <span class="hljs-keyword">const</span> scrollTop = e.<span class="hljs-property">target</span>.<span class="hljs-property">scrollTop</span>
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">scrollTop</span> = scrollTop
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;scrollTop&#x27;</span>, scrollTop)
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">startIndex</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(scrollTop / <span class="hljs-variable language_">this</span>.<span class="hljs-property">itemHeight</span>)
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">endIndex</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">startIndex</span> + <span class="hljs-number">10</span>
    }
  }
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="language-css">
<span class="hljs-selector-class">.virtual-scroller</span> {
  <span class="hljs-attribute">border</span>: solid <span class="hljs-number">1px</span> <span class="hljs-number">#eee</span>;
  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">10px</span>;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">600px</span>;
  <span class="hljs-attribute">overflow</span>: auto
}

<span class="hljs-selector-class">.phantom</span> {
  <span class="hljs-attribute">overflow</span>: hidden
}

<span class="hljs-selector-tag">ul</span> {
  <span class="hljs-attribute">background</span>: <span class="hljs-number">#ccc</span>;
  <span class="hljs-attribute">list-style</span>: none;
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;
}

<span class="hljs-selector-tag">li</span> {
  <span class="hljs-attribute">outline</span>: solid <span class="hljs-number">1px</span> <span class="hljs-number">#fff</span>;
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
</code></pre>
<ol start="2">
<li>IntersectionObserver API 交叉视口器</li>
</ol>
<h2 id="数据结构-1">数据结构</h2>
<h3 id="把一个数组改成一个单向链表">把一个数组改成一个单向链表</h3>
<pre><code class="language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createLinkList</span>(<span class="hljs-params">arr: number[]</span>): <span class="hljs-title class_">ILinkListNode</span> {
    <span class="hljs-keyword">const</span> length = arr.<span class="hljs-property">length</span>
    <span class="hljs-keyword">if</span> (length === <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;arr is empty&#x27;</span>)

    <span class="hljs-keyword">let</span> <span class="hljs-attr">curNode</span>: <span class="hljs-title class_">ILinkListNode</span> = {
        <span class="hljs-attr">value</span>: arr[length - <span class="hljs-number">1</span>]
    }
    <span class="hljs-keyword">if</span> (length === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> curNode

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = length - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) {
        curNode = {
            <span class="hljs-attr">value</span>: arr[i],
            <span class="hljs-attr">next</span>: curNode
        }
    }
    <span class="hljs-keyword">return</span> curNode
}
</code></pre>
<h3 id="堆和二叉树的关系">堆和二叉树的关系</h3>
<p>堆是一个完全二叉树，堆在逻辑结构上是一颗二叉树，在物理结构上是个数组
<img src="file:///e:\studying\book_files\107.jpg" alt="1">
<img src="file:///e:\studying\book_files\108.jpg" alt="2">
堆的使用场景：堆的数据，都是在栈中引用的，不需想BST要从root遍历，堆恰巧是数组形式，根据栈的地址，可用O(1)找到目标。</p>
<h2 id="算法">算法</h2>
<h3 id="递归">递归</h3>
<p>递归（Recursion）是计算机科学中的一个重要概念，它指的是一个函数或过程直接或间接地调用自身来解决问题。递归算法通过将问题分解为更小的子问题，并递归地解决这些子问题，最终将子问题的解组合起来形成原问题的解。</p>
<h4 id="递归和尾递归">递归和尾递归</h4>
<p>尾递归：在尾部调用的是函数自身，可通过优化，使得计算仅占用常量栈空间</p>
<pre><code class="language-js"><span class="hljs-comment">// 复杂度：O(n) 在递归调用的过程当中系统为每一层的返回点，局部量等开辟栈来存储</span>
<span class="hljs-comment">// 递归次数多了容易栈溢出</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">factorial</span>(<span class="hljs-params">n</span>) {
 <span class="hljs-keyword">if</span> (n === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
 <span class="hljs-keyword">return</span> n * <span class="hljs-title function_">factorial</span>(n - <span class="hljs-number">1</span>);
}
<span class="hljs-title function_">factorial</span>(<span class="hljs-number">5</span>) <span class="hljs-comment">// 120</span>
</code></pre>
<pre><code class="language-js"><span class="hljs-comment">// 复杂度：O(1)</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">factorial</span>(<span class="hljs-params">n, total</span>) {
 <span class="hljs-keyword">if</span> (n === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> total;
 <span class="hljs-keyword">return</span> <span class="hljs-title function_">factorial</span>(n - <span class="hljs-number">1</span>, n * total);
}
<span class="hljs-title function_">factorial</span>(<span class="hljs-number">5</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// 120</span>
</code></pre>
<h2 id="write">write</h2>
<h3 id="封装一个通用的事件监听函数">封装一个通用的事件监听函数</h3>
<ul>
<li>事件代理原理：<strong>事件冒泡</strong></li>
<li><strong>Element.matches()</strong>：如果元素被指定的选择器字符串选择，Element.matches() 方法返回 true; 否则返回 false。(API可能存在兼容问题)</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">bindEvent</span>(<span class="hljs-params">elem, type, selector, fn</span>) {
    <span class="hljs-keyword">if</span> (fn == <span class="hljs-literal">null</span>) {
        fn = selector
        selector = <span class="hljs-literal">null</span>
    }
    elem.<span class="hljs-title function_">addEventListener</span>(type, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {
        <span class="hljs-keyword">const</span> target = event.<span class="hljs-property">target</span>        
        <span class="hljs-keyword">if</span> (selector) {
            <span class="hljs-comment">// 代理绑定</span>
            <span class="hljs-keyword">if</span> (target.<span class="hljs-title function_">matches</span>(selector)) {
                fn.<span class="hljs-title function_">call</span>(target, event)
            }
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// 普通绑定</span>
            fn.<span class="hljs-title function_">call</span>(target, event)
        }
    })
}

<span class="hljs-comment">// 普通绑定</span>
<span class="hljs-keyword">const</span> btn1 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;btn1&#x27;</span>)
<span class="hljs-title function_">bindEvent</span>(btn1, <span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) {
    <span class="hljs-comment">// console.log(event.target) // 获取触发的元素</span>
    event.<span class="hljs-title function_">preventDefault</span>() <span class="hljs-comment">// 阻止默认行为</span>
    <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">innerHTML</span>)
})

<span class="hljs-comment">// 代理绑定</span>
<span class="hljs-keyword">const</span> div3 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;div3&#x27;</span>)
<span class="hljs-title function_">bindEvent</span>(div3, <span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) {
    event.<span class="hljs-title function_">preventDefault</span>()
    <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">innerHTML</span>)
})
</code></pre>
<h3 id="封装一个ajax函数">封装一个ajax函数</h3>
<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ajax</span>(<span class="hljs-params">url</span>) {
    <span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
        <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>()
        xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;GET&#x27;</span>, url, <span class="hljs-literal">true</span>)
        xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
            <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> === <span class="hljs-number">4</span>) {
                <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) {
                    <span class="hljs-title function_">resolve</span>(
                        <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(xhr.<span class="hljs-property">responseText</span>)
                    )
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">status</span> === <span class="hljs-number">404</span> || xhr.<span class="hljs-property">status</span> === <span class="hljs-number">500</span>) {
                    <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;404 not found&#x27;</span>))
                }
            }
        }
        xhr.<span class="hljs-title function_">send</span>(<span class="hljs-literal">null</span>)
    })
    <span class="hljs-keyword">return</span> p
}

<span class="hljs-keyword">const</span> url = <span class="hljs-string">&#x27;/data/test.json&#x27;</span>
<span class="hljs-title function_">ajax</span>(url)
.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res))
.<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(err))
</code></pre>
<h3 id="手写instanceof">手写instanceOf</h3>
<p>原理：查找原型链</p>
<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">myInstanceOf</span>(<span class="hljs-params">current, fun</span>) {  
	<span class="hljs-comment">// 检查 current 是否为 null 或 undefined  </span>
	<span class="hljs-keyword">if</span> (current === <span class="hljs-literal">null</span> || current === <span class="hljs-literal">undefined</span>) {  
		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  
	}  
	  
	<span class="hljs-comment">// 检查 fun 是否是函数并且拥有 prototype 属性  </span>
	<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fun !== <span class="hljs-string">&#x27;function&#x27;</span> || fun.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> === <span class="hljs-literal">undefined</span>) {  
		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  
	}  
	  
	<span class="hljs-comment">// 遍历原型链  </span>
	<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {  
		<span class="hljs-comment">// 如果找到匹配的原型，则返回 true  </span>
		<span class="hljs-keyword">if</span> (<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(current) === fun.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) {  
			<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  
		}  
		  
		<span class="hljs-comment">// 如果到达原型链的顶端（null），则返回 false  </span>
		current = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(current);  
		<span class="hljs-keyword">if</span> (current === <span class="hljs-literal">null</span>) {  
			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  
		}  
	}  
}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-title function_">myInstanceOf</span>([],<span class="hljs-title class_">Array</span>))<span class="hljs-comment">//true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-title function_">myInstanceOf</span>([],<span class="hljs-title class_">Object</span>))<span class="hljs-comment">//true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-title function_">myInstanceOf</span>([],<span class="hljs-literal">null</span>))<span class="hljs-comment">//false</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-title function_">myInstanceOf</span>(<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-title class_">String</span>))<span class="hljs-comment">//true 可考虑再增加current是否是对象的判断</span>

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span>)<span class="hljs-comment">//false</span>
</code></pre>
<h3 id="手写new操作符">手写new操作符</h3>
<p>原理：绑定原型链 + 显式绑定this + 返回判断</p>
<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mynew</span>(<span class="hljs-params">func, ...args</span>) {
 <span class="hljs-keyword">const</span> obj = {}
 obj.<span class="hljs-property">__proto__</span> = func.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>
 <span class="hljs-keyword">let</span> result = func.<span class="hljs-title function_">apply</span>(obj, args)
 <span class="hljs-keyword">return</span> result <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span> ? result : obj
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age</span>) {
 <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
 <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;
}
<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">say</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
 <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)
}
<span class="hljs-keyword">let</span> p = <span class="hljs-title function_">mynew</span>(<span class="hljs-title class_">Person</span>, <span class="hljs-string">&quot;huihui&quot;</span>, <span class="hljs-number">123</span>)
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p) <span class="hljs-comment">// Person {name: &quot;huihui&quot;, age: 123}</span>
p.<span class="hljs-title function_">say</span>() <span class="hljs-comment">// huihui</span>
</code></pre>
<h3 id="手写call-apply-bind">手写call apply bind</h3>
<p>原理：借，对目标对象添加上函数方法，再删除</p>
<pre><code class="language-js"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myCall</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) {
		  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>) <span class="hljs-comment">//fn a()</span>
		  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&#x27;function&#x27;</span>) {
			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;Error&#x27;</span>)
		  }
		  context = context || <span class="hljs-variable language_">window</span>
		  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(context)<span class="hljs-comment">//obj</span>
		  context.<span class="hljs-property">fn</span> = <span class="hljs-variable language_">this</span>
		  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> context.<span class="hljs-property">fn</span>)<span class="hljs-comment">//function</span>
		  
		  <span class="hljs-keyword">const</span> args = [...<span class="hljs-variable language_">arguments</span>].<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>)
		  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(args)
		  <span class="hljs-comment">//通过隐式绑定的方式调用函数</span>
		  <span class="hljs-keyword">const</span> result = context.<span class="hljs-title function_">fn</span>(...args)
		   <span class="hljs-comment">//删除添加的属性</span>
		  <span class="hljs-keyword">delete</span> context.<span class="hljs-property">fn</span>
		   <span class="hljs-comment">//返回函数调用的返回值</span>
		  <span class="hljs-keyword">return</span> result
}

<span class="hljs-keyword">let</span> obj ={
	<span class="hljs-attr">name</span>:<span class="hljs-number">333</span>
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>){
	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>)
}
a.<span class="hljs-title function_">myCall</span>(obj)

</code></pre>
<p>注意bind的用法，bind可以<code>分批添加参数</code>，所以需要拼接，而且bind返回的是函数，考虑<code>兼容new</code>的情形。</p>
<pre><code class="language-js"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myBind</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">context, ...args</span>) {  
	  <span class="hljs-keyword">const</span> originalFunction = <span class="hljs-variable language_">this</span>;  
	  
	  <span class="hljs-comment">// 返回一个新函数  </span>
	  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">F</span>(<span class="hljs-params">...boundArgs</span>) {  
	    <span class="hljs-comment">// 如果通过 new 调用，则忽略 context，使用新创建的实例  </span>
	    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> F) {  
	      <span class="hljs-comment">// 相当于执行 new originalFunction(...args, ...boundArgs)  </span>
	      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">originalFunction</span>(...args, ...boundArgs);  
	    }  
	  
	    <span class="hljs-comment">// 否则，使用提供的 context 和合并的参数调用原函数  </span>
	    <span class="hljs-keyword">return</span> originalFunction.<span class="hljs-title function_">apply</span>(context, args.<span class="hljs-title function_">concat</span>(boundArgs));  
	  };  
	};  
	  
	<span class="hljs-comment">// 使用示例  </span>
	<span class="hljs-keyword">function</span> <span class="hljs-title function_">MyConstructor</span>(<span class="hljs-params">a, b</span>) {  
	  <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> = a;  
	  <span class="hljs-variable language_">this</span>.<span class="hljs-property">b</span> = b;  
	}  
	  
	<span class="hljs-title class_">MyConstructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getValue</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {  
	  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">b</span>;  
	};  
	  
	<span class="hljs-keyword">const</span> boundConstructor = <span class="hljs-title class_">MyConstructor</span>.<span class="hljs-title function_">myBind</span>(<span class="hljs-literal">null</span>, <span class="hljs-number">1</span>);  
	  
	<span class="hljs-comment">// 使用 new 调用 boundConstructor  </span>
	<span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> <span class="hljs-title function_">boundConstructor</span>(<span class="hljs-number">2</span>);  
	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance.<span class="hljs-title function_">getValue</span>()); <span class="hljs-comment">// 输出 3  </span>
	  
	<span class="hljs-comment">// 普通函数调用  </span>
	<span class="hljs-keyword">const</span> result = <span class="hljs-title function_">boundConstructor</span>(<span class="hljs-number">3</span>);  
	<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// 输出 MyConstructor 的返回值，如果没有显式返回，则为 undefined</span>
</code></pre>
<h3 id="手写防抖节流">手写防抖节流</h3>
<p>原理：借助<code>闭包</code>或者全局变量对时间的把握</p>
<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css">
	<span class="hljs-selector-id">#test</span>{
		<span class="hljs-attribute">width</span>:<span class="hljs-number">400px</span>;
		<span class="hljs-attribute">height</span>:<span class="hljs-number">400px</span>;
		<span class="hljs-attribute">border</span>:<span class="hljs-number">1px</span> solid red
	}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;m-2&quot;</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span>1111<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span>1111<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span>1111<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span>1111<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span>1111<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span>1111<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span>1111<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span>1111<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">
		<span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn, delay</span>) {
		  <span class="hljs-comment">// last为上一次触发回调的时间, timer是定时器</span>
		  <span class="hljs-keyword">let</span> last = <span class="hljs-number">0</span>, timer = <span class="hljs-literal">null</span>
		  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) { 
		    <span class="hljs-comment">// 保留调用时的this上下文</span>
		    <span class="hljs-keyword">let</span> context = <span class="hljs-variable language_">this</span>
		    <span class="hljs-comment">// 保留调用时传入的参数</span>
		    <span class="hljs-keyword">let</span> args = <span class="hljs-variable language_">arguments</span>
		    <span class="hljs-comment">// 记录本次触发回调的时间</span>
		    <span class="hljs-keyword">let</span> now = +<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()
		
		    <span class="hljs-comment">// 判断上次触发的时间和本次触发的时间差是否小于时间间隔的阈值</span>
		    <span class="hljs-keyword">if</span> (now - last &lt; delay) {
		    <span class="hljs-comment">// 如果时间间隔小于我们设定的时间间隔阈值，则为本次触发操作设立一个新的定时器</span>
		       <span class="hljs-built_in">clearTimeout</span>(timer)
		       timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
		          last = now
		          fn.<span class="hljs-title function_">apply</span>(context, args)
		        }, delay)
		    } <span class="hljs-keyword">else</span> {
		        <span class="hljs-comment">// 如果时间间隔超出了我们设定的时间间隔阈值，那就不等了，无论如何要反馈给用户一次响应</span>
		        last = now
		        fn.<span class="hljs-title function_">apply</span>(context, args)
		    }
		  }
		}
		<span class="hljs-comment">// 用新的throttle包装scroll的回调</span>
		<span class="hljs-keyword">const</span> better_scroll = <span class="hljs-title function_">throttle</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;触发了滚动事件&#x27;</span>), <span class="hljs-number">1000</span>)
		
		<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;scroll&#x27;</span>, better_scroll)
  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<h3 id="手写深拷贝">手写深拷贝</h3>
<p>原理：遍历属性，遇到对象数组<code>递归</code></p>
<pre><code class="language-js"><span class="hljs-comment">//定义检测数据类型的功能函数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">checkedType</span>(<span class="hljs-params">target</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(target).<span class="hljs-title function_">slice</span>(<span class="hljs-number">8</span>, -<span class="hljs-number">1</span>)
}
<span class="hljs-comment">//实现深度克隆---对象/数组</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">clone</span>(<span class="hljs-params">target</span>) {
  <span class="hljs-comment">//判断拷贝的数据类型</span>
  <span class="hljs-comment">//初始化变量result 成为最终克隆的数据</span>
  <span class="hljs-keyword">let</span> result,
    targetType = <span class="hljs-title function_">checkedType</span>(target)
  <span class="hljs-keyword">if</span> (targetType === <span class="hljs-string">&#x27;Object&#x27;</span>) {
    result = {}
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (targetType === <span class="hljs-string">&#x27;Array&#x27;</span>) {
    result = []
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> target
  }
  <span class="hljs-comment">//遍历目标数据</span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> target) {
    <span class="hljs-comment">//获取遍历数据结构的每一项值。</span>
    <span class="hljs-keyword">let</span> value = target[i]
    <span class="hljs-comment">//判断目标结构里的每一值是否存在对象/数组</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">checkedType</span>(value) === <span class="hljs-string">&#x27;Object&#x27;</span> || <span class="hljs-title function_">checkedType</span>(value) === <span class="hljs-string">&#x27;Array&#x27;</span>) {
      <span class="hljs-comment">//对象/数组里嵌套了对象/数组</span>
      <span class="hljs-comment">//继续遍历获取到value值</span>
      result[i] = <span class="hljs-title function_">clone</span>(value)
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">//获取到value值是基本的数据类型或者是函数。</span>
      result[i] = value
    }
  }
  <span class="hljs-keyword">return</span> result
}
</code></pre>
<h3 id="手写objectcreate">手写Object.create</h3>
<pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">object</span>(<span class="hljs-params">o</span>) {
　　<span class="hljs-keyword">function</span> <span class="hljs-title function_">F</span>(<span class="hljs-params"></span>) {}
　　F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = o;
　　<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>();
}
</code></pre>
<h3 id="手写简单axios">手写简单axios</h3>
<pre><code class="language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Axios</span> {
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {

    }

    <span class="hljs-title function_">request</span>(<span class="hljs-params">config</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> {
            <span class="hljs-keyword">const</span> {url = <span class="hljs-string">&#x27;&#x27;</span>, method = <span class="hljs-string">&#x27;get&#x27;</span>, data = {}} = config;
            <span class="hljs-comment">// 发送ajax请求</span>
            <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();
            xhr.<span class="hljs-title function_">open</span>(method, url, <span class="hljs-literal">true</span>);
            xhr.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(xhr.<span class="hljs-property">responseText</span>)
                <span class="hljs-title function_">resolve</span>(xhr.<span class="hljs-property">responseText</span>);
            }
            xhr.<span class="hljs-title function_">send</span>(data);
        })
    }
}
</code></pre>
<pre><code class="language-js"><span class="hljs-comment">// 最终导出axios的方法，即实例的request方法</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">CreateAxiosFn</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">let</span> axios = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Axios</span>();
    <span class="hljs-keyword">let</span> req = axios.<span class="hljs-property">request</span>.<span class="hljs-title function_">bind</span>(axios);
    <span class="hljs-keyword">return</span> req;
}

<span class="hljs-comment">// 得到最后的全局变量axios</span>
<span class="hljs-keyword">let</span> axios = <span class="hljs-title class_">CreateAxiosFn</span>();
</code></pre>
<h3 id="手写router">手写router</h3>
<pre><code class="language-js"><span class="hljs-comment">// 定义 Router   hash路由</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Router</span> {  
    <span class="hljs-title function_">constructor</span> () {  
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">routes</span> = {}; <span class="hljs-comment">// 存放路由path及callback  </span>
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentUrl</span> = <span class="hljs-string">&#x27;&#x27;</span>;  
          
        <span class="hljs-comment">// 监听路由change调用相对应的路由回调  </span>
        <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;load&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">refresh</span>, <span class="hljs-literal">false</span>);  
        <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;hashchange&#x27;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">refresh</span>, <span class="hljs-literal">false</span>);  
    }  
      
    <span class="hljs-title function_">route</span>(<span class="hljs-params">path, callback</span>){  
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">routes</span>[path] = callback;  
    }  
      
    <span class="hljs-title function_">push</span>(<span class="hljs-params">path</span>) {  
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">routes</span>[path] &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">routes</span>[path]()  
    }  
}  
  
<span class="hljs-comment">// 使用 router  </span>
<span class="hljs-variable language_">window</span>.<span class="hljs-property">miniRouter</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Router</span>();  
miniRouter.<span class="hljs-title function_">route</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;page1&#x27;</span>))  
miniRouter.<span class="hljs-title function_">route</span>(<span class="hljs-string">&#x27;/page2&#x27;</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;page2&#x27;</span>))  
  
miniRouter.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;/&#x27;</span>) <span class="hljs-comment">// page1  </span>
miniRouter.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;/page2&#x27;</span>) <span class="hljs-comment">// page2  </span>
</code></pre>
<ul>
<li>history.pushState 浏览器历史纪录添加记录</li>
<li>history.replaceState修改浏览器历史纪录中当前纪录</li>
<li>history.popState 当 history 发生变化时触发</li>
</ul>
<pre><code class="language-js"><span class="hljs-comment">// 定义 Router  </span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Router</span> {  
    <span class="hljs-title function_">constructor</span> () {  
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">routes</span> = {};  
        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">listerPopState</span>()  
    }  
      
    <span class="hljs-title function_">init</span>(<span class="hljs-params">path</span>) {  
        history.<span class="hljs-title function_">replaceState</span>({<span class="hljs-attr">path</span>: path}, <span class="hljs-literal">null</span>, path);  
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">routes</span>[path] &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">routes</span>[path]();  
    }  
      
    <span class="hljs-title function_">route</span>(<span class="hljs-params">path, callback</span>){  
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">routes</span>[path] = callback;  
    }  
      
    <span class="hljs-title function_">push</span>(<span class="hljs-params">path</span>) {  
        history.<span class="hljs-title function_">pushState</span>({<span class="hljs-attr">path</span>: path}, <span class="hljs-literal">null</span>, path);  
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">routes</span>[path] &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">routes</span>[path]();  
    }  
      
    listerPopState () {  
        <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;popstate&#x27;</span> , <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {  
            <span class="hljs-keyword">const</span> path = e.<span class="hljs-property">state</span> &amp;&amp; e.<span class="hljs-property">state</span>.<span class="hljs-property">path</span>;  
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">routers</span>[path] &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">routers</span>[path]()  
        })  
    }  
}  
  
<span class="hljs-comment">// 使用 Router  </span>
  
<span class="hljs-variable language_">window</span>.<span class="hljs-property">miniRouter</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Router</span>();  
miniRouter.<span class="hljs-title function_">route</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">()=&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;page1&#x27;</span>))  
miniRouter.<span class="hljs-title function_">route</span>(<span class="hljs-string">&#x27;/page2&#x27;</span>, <span class="hljs-function">()=&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;page2&#x27;</span>))  
  
<span class="hljs-comment">// 跳转  </span>
miniRouter.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;/page2&#x27;</span>)  <span class="hljs-comment">// page2  </span>
</code></pre>
<h2 id="webpack">webpack</h2>
<p>webpack是一个<code>打包模块化js工具</code>，在webpack里一切文件皆模块，通过loader转换文件，通过plugin注入钩子，最后输出由多个模块组合成的文件，webpack专注构建模块化项目。
<img src="file:///e:\studying\book_files\93.jpg" alt="webpack"></p>
<h3 id="webpack五个核心概念">webpack五个核心概念</h3>
<ol>
<li>Entry</li>
<li>Output</li>
<li>Loader:可以用于对模块的源代码进行转换(主要职责：转成webpack可识别的文件)</li>
<li>Plugins:插件，可在打包优化、资源管理、环境变量注入</li>
<li>Mode</li>
</ol>
<h3 id="谈谈webpack升级变化">谈谈webpack升级变化</h3>
<ol>
<li>从v3到v4
<ul>
<li>提出零配置概念 - 简化配置</li>
<li>区分开发和编译态
<ul>
<li>mode</li>
<li>提升了开发编译效率，让生成环境更加专注编译产品</li>
</ul>
</li>
<li>配置差异
<ul>
<li>分chunk=&gt; commonTrunkPlugin =&gt; optimization.splitChunks</li>
</ul>
</li>
</ul>
</li>
<li>v4=&gt;v5
<ul>
<li>持久化缓存=&gt; cache =&gt; 直接利用缓存结果反向跳过构建部分</li>
<li>资源模块的优化 =&gt; asset/resource(file-loader url-lodaer raw-loader被内置取代)</li>
<li>打包优化</li>
</ul>
</li>
</ol>
<pre><code class="language-js"><span class="hljs-attr">splitChunks</span>:{
	<span class="hljs-attr">chunks</span>:<span class="hljs-string">&#x27;all&#x27;</span>,
	<span class="hljs-attr">minSize</span>:{
		<span class="hljs-attr">javascript</span>:<span class="hljs-number">30000</span>
	}
}
</code></pre>
<h3 id="说出几个常见的loader和plugin">说出几个常见的loader和plugin</h3>
<ol>
<li>几个常见的webpack-loader
<ul>
<li>file-loader：把文件识别后打包（w4）</li>
<li>url-loader：和 file-loader 类似，但能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去（w4）</li>
<li>image-loader：加载并且压缩图片文件</li>
<li>css-loader：加载 CSS，支持模块化、压缩、文件导入等特性，负责将 Css 文件编译成 Webpack 能识别的模块</li>
<li>style-loader：把 CSS 代码注入到 打包的JavaScript 中，通过 DOM 操作去加载 CSS；会动态创建一个 Style 标签，里面放置 Webpack 中 Css 模块内容</li>
<li>less-loader：负责将 Less 文件编译成 Css 文件</li>
<li>asset：Webpack5 已经将url-loader/file-loader 功能内置到 Webpack 里了，称为asset module type(资源模块类型)</li>
</ul>
</li>
<li>几个常见的webpack-plugin
<ul>
<li>define-plugin：内置定义环境变量</li>
<li>html-webpack-plugin： 为html文件中引入的外部资源，可以生成创建html入口文件</li>
<li>mini-css-extract-plugin：分离css文件</li>
<li>optimize-css-assets-webpack-plugin：处理css文件，W5中更推荐css-minimizer-webpack-plugin</li>
<li>css-minimizer-webpack-plugin: css压缩</li>
<li>clean-webpack-plugin：删除打包文件（w4）【ouput中配置选项clean:true:webpack5中可以不需要再手动安装clean-webpack-plugin，配置clean后，会在打包时自动删除output下的path对应的文件夹内容】</li>
<li>webpack.HotModuleReplacementPlugin (webpack内置热更新组件，新版webpack-dev-server根据devserver中hot值为true会自动调用)</li>
<li>terser-webpack-plugin： w5内置，w4需要安装，处理多进程打包，可以配置在plugins中，也可以在optimization中配置(如果配置了css压缩，这个就算不需要配置多进程打包也最好要配置)</li>
</ul>
</li>
</ol>
<h4 id="loader和plugin">loader和plugin</h4>
<ul>
<li>loader：模块转换器，用于特定的模块类型进行转换，原内容按照需要转成想要的内容</li>
<li>plugin：可以用于执行更加广泛的任务，比如打包优化、资源管理、环境变量注入等，在webpack构建流程中的特定时机注入扩展逻辑，来改变构建结果，是用来自定义webpack打包过程的方式，一个插件是含有apply方法的一个对象，通过这个方法可以参与到整个webpack打包的各个流程(生命周期)。</li>
</ul>
<p><img src="file:///e:\studying\book_files\95.jpg" alt="图解"></p>
<h3 id="bundlechunkmodule是什么">bundle，chunk，module是什么</h3>
<ul>
<li>bundle：是由webpack打包出来的文件。</li>
<li>chunk：代码块，一个chunk由多个模块组合而成，用于代码的合并和分割。</li>
<li>module：是开发中的单个模块，在webpack的世界，一切皆模块，一个模块对应一个文件，webpack会从配置的entry中递归开始找出所有依赖的模块。</li>
</ul>
<p>简单的说：直接写出来的是 module，webpack 处理时是 chunk，最后生成浏览器可以直接运行的 bundle。</p>
<p><img src="file:///e:\studying\book_files\92.jpg" alt="chunk"></p>
<p>在webpack的打包配置entry中有两个入口：index和utils。分别对应index.js和utils.js。其中indexjs文件引用了common.js和index.css。那么打包的时候三个文件看成一个chunk，utilsjs文件作为一个chunk。</p>
<p>但是webpack配置用MiniCssExtractPlugin插件抽离出css文件，所以产生了.css和.js两个bundle文件。</p>
<h3 id="webpack调用和webpack-cli">webpack调用和webpack-cli</h3>
<p>webpack-cli:webpack-cli 是用来处理命令行参数，并通过参数构建 compiler 对象，然后才是对代码进行打包的过程。</p>
<ol>
<li>命令行调用：在cmd控制台中，如果直接使用webpack命令，其实不管项目中有没有安装局部的webpack，都不会被调用，会直接使用全局的webpack；如果要使用项目的webpack，需要加前缀npx webpack。</li>
</ol>
<pre><code class="language-bash"> npx webpack --entry ./src/main.js --output-path ./build
</code></pre>
<ol start="2">
<li>package.json中</li>
</ol>
<pre><code class="language-json"> <span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">&quot;start&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack serve&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-comment">//发现有serve，会自动寻找webpack-dev-serve</span>
      <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack&quot;</span><span class="hljs-comment">// 不需要加npx，它会先找当前目录的webpack</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>如果需要传入process.env.NODE_ENV，windows系统需要这样配置安装cross-env</p>
<pre><code class="language-json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">&quot;start&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cross-env NODE_ENV=development webpack serve&quot;</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cross-env NODE_ENV=production webpack&quot;</span>
    <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
</code></pre>
<h3 id="webpack-loader">webpack loader</h3>
<p>loader 本身仅仅只是一个函数，接收模块代码的内容，然后返回代码内容转化后的结果。</p>
<h4 id="loader写法">loader写法</h4>
<p>loader可以单独写在rules里，也可以用use包裹，如果是使用到多个loader，use应该为数组的形式</p>
<pre><code class="language-js">{
  <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>,
  <span class="hljs-attr">loader</span>: <span class="hljs-string">&quot;loader1&quot;</span>,<span class="hljs-comment">//单个loader</span>
}


{
  <span class="hljs-attr">test</span>:<span class="hljs-regexp">/\.jpg$/</span>,
  <span class="hljs-attr">use</span>:{
    <span class="hljs-attr">loader</span>:<span class="hljs-string">&#x27;file-loader&#x27;</span><span class="hljs-comment">//可以用use包裹loader</span>
  }
}

{
    <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>,
    <span class="hljs-comment">// 多个loader可以写成数组，如果有配置项，对应的loader可写成对象形式</span>
    <span class="hljs-attr">use</span>: [
      <span class="hljs-string">&#x27;style-loader&#x27;</span>,
      {
        <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;css-loader&#x27;</span>,
        <span class="hljs-attr">options</span>: {
          <span class="hljs-attr">modules</span>:<span class="hljs-literal">true</span>,<span class="hljs-comment">//开启css模块化打包</span>
          <span class="hljs-attr">importLoaders</span>: <span class="hljs-number">2</span>, 
        },
      },
      <span class="hljs-string">&#x27;postcss-loader&#x27;</span>,
      <span class="hljs-string">&#x27;sass-loader&#x27;</span>
    ]
}
</code></pre>
<h4 id="loader的执行顺序">loader的执行顺序</h4>
<p>执行顺序:4 类 loader 的执行优级为：pre &gt; normal &gt; inline &gt; post 。</p>
<p>相同优先级的 loader 执行顺序为：从右到左，从下到上。</p>
<pre><code class="language-js"><span class="hljs-comment">// 此时loader执行顺序：loader1 - loader2 - loader3</span>
<span class="hljs-attr">module</span>: {
  <span class="hljs-attr">rules</span>: [
    {
      <span class="hljs-attr">enforce</span>: <span class="hljs-string">&quot;pre&quot;</span>,
      <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>,
      <span class="hljs-attr">loader</span>: <span class="hljs-string">&quot;loader1&quot;</span>,
    },
    {
      <span class="hljs-comment">// 没有enforce就是normal</span>
      <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>,
      <span class="hljs-attr">loader</span>: <span class="hljs-string">&quot;loader2&quot;</span>,
    },
    {
      <span class="hljs-attr">enforce</span>: <span class="hljs-string">&quot;post&quot;</span>,
      <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>,
      <span class="hljs-attr">loader</span>: <span class="hljs-string">&quot;loader3&quot;</span>,
    },
  ],
},
</code></pre>
<h4 id="手写一个loader">手写一个loader</h4>
<p>有同步loader和异步loader，这里举个简单的同步loader</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> loaderUtils = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;loader-utils&#x27;</span>);
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">source</span>) {
	<span class="hljs-keyword">return</span> source.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&#x27;lee&#x27;</span>, <span class="hljs-string">&#x27;world&#x27;</span>);
}
</code></pre>
<h4 id="合并loader">合并loader</h4>
<pre><code class="language-js"><span class="hljs-comment">// 获取处理样式的Loaders</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">getStyleLoaders</span> = (<span class="hljs-params">preProcessor</span>) =&gt; {
  <span class="hljs-keyword">return</span> [
    <span class="hljs-title class_">MiniCssExtractPlugin</span>.<span class="hljs-property">loader</span>,
    <span class="hljs-string">&quot;css-loader&quot;</span>,
    {
      <span class="hljs-attr">loader</span>: <span class="hljs-string">&quot;postcss-loader&quot;</span>,
      <span class="hljs-attr">options</span>: {
        <span class="hljs-attr">postcssOptions</span>: {
          <span class="hljs-attr">plugins</span>: [
            <span class="hljs-string">&quot;postcss-preset-env&quot;</span>, <span class="hljs-comment">// 能解决大多数样式兼容性问题</span>
          ],
        },
      },
    },
    preProcessor,
  ].<span class="hljs-title function_">filter</span>(<span class="hljs-title class_">Boolean</span>);
};

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      {
        <span class="hljs-comment">// 用来匹配 .css 结尾的文件</span>
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>,
        <span class="hljs-comment">// use 数组里面 Loader 执行顺序是从右到左</span>
        <span class="hljs-attr">use</span>: <span class="hljs-title function_">getStyleLoaders</span>(),
      },
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.less$/</span>,
        <span class="hljs-attr">use</span>: <span class="hljs-title function_">getStyleLoaders</span>(<span class="hljs-string">&quot;less-loader&quot;</span>),
      },
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.s[ac]ss$/</span>,
        <span class="hljs-attr">use</span>: <span class="hljs-title function_">getStyleLoaders</span>(<span class="hljs-string">&quot;sass-loader&quot;</span>),
      },
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.styl$/</span>,
        <span class="hljs-attr">use</span>: <span class="hljs-title function_">getStyleLoaders</span>(<span class="hljs-string">&quot;stylus-loader&quot;</span>),
      },
    ],
  },

};
</code></pre>
<h4 id="webpack中的-asset-module-type">webpack中的 asset module type</h4>
<p>在webpack5中，可以直接使用资源模块类型（asset module type），可替代raw-loader 、url-loader、file-loader</p>
<ul>
<li>asset/resource 发送一个单独的文件并导出 URL。相当于file-loader</li>
<li>asset/inline 导出一个资源的 data URI。之前通过使用 url-loader 实现；</li>
<li>asset/source 导出资源的源代码。之前通过使用 raw-loader 实现；</li>
<li>asset 在导出一个 data URI 和发送一个单独的文件之间自动选择。相当于url-loader, 将文件转化成 Webpack 能识别的资源，同时小于某个大小的资源会处理成 data URI 形式</li>
</ul>
<pre><code class="language-js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>);

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">entry</span>: <span class="hljs-string">&quot;./src/main.js&quot;</span>,
  <span class="hljs-attr">output</span>: {
    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&quot;dist&quot;</span>),
    <span class="hljs-attr">filename</span>: <span class="hljs-string">&quot;static/js/main.js&quot;</span>, <span class="hljs-comment">// 将 js 文件输出到 static/js 目录中</span>
    <span class="hljs-attr">clean</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 自动将上次打包目录资源清空</span>
  },
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.s[ac]ss$/</span>,
        <span class="hljs-attr">use</span>: [<span class="hljs-string">&quot;style-loader&quot;</span>, <span class="hljs-string">&quot;css-loader&quot;</span>, <span class="hljs-string">&quot;sass-loader&quot;</span>],
      },
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(png|jpe?g|gif|webp)$/</span>,
        <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;asset&quot;</span>,
        <span class="hljs-attr">parser</span>: {
          <span class="hljs-attr">dataUrlCondition</span>: {
            <span class="hljs-attr">maxSize</span>: <span class="hljs-number">10</span> * <span class="hljs-number">1024</span>, <span class="hljs-comment">// 小于10kb的图片会被base64处理</span>
          },
        },
        <span class="hljs-attr">generator</span>: {
          <span class="hljs-comment">// 将图片文件输出到 static/imgs 目录中</span>
          <span class="hljs-comment">// 将图片文件命名 [hash:8][ext][query]</span>
          <span class="hljs-comment">// [hash:8]: hash值取8位</span>
          <span class="hljs-comment">// [ext]: 使用之前的文件扩展名</span>
          <span class="hljs-comment">// [query]: 添加之前的query参数</span>
          <span class="hljs-attr">filename</span>: <span class="hljs-string">&quot;static/imgs/[hash:8][ext][query]&quot;</span>,
        },
      },
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(ttf|woff2?|map4|map3|avi)$/</span>,
        <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;asset/resource&quot;</span>,
        <span class="hljs-attr">generator</span>: {
          <span class="hljs-attr">filename</span>: <span class="hljs-string">&quot;static/media/[hash:8][ext][query]&quot;</span>,
        },
      },
    ],
  },
  <span class="hljs-attr">mode</span>: <span class="hljs-string">&quot;development&quot;</span>,
};
</code></pre>
<h3 id="webpack对css处理">webpack对css处理</h3>
<ul>
<li>style-loader:添加style标签，把css添加到页面中</li>
<li>css-loader：解析css</li>
<li>postcss-loader：解决css兼容代码</li>
<li>sass-loader：预编译语言处理loader</li>
<li>MiniCssExtractPlugin</li>
</ul>
<pre><code class="language-js"><span class="hljs-comment">//webpack.config.js</span>
<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>) 
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>={
	<span class="hljs-attr">mode</span>:<span class="hljs-string">&#x27;production&#x27;</span>,
	<span class="hljs-attr">entry</span>:<span class="hljs-string">&#x27;./index.js&#x27;</span>,
	<span class="hljs-attr">module</span>:{
		{
			<span class="hljs-attr">test</span>:<span class="hljs-regexp">/\.scss$/</span>,
			<span class="hljs-attr">use</span>: [
				{<span class="hljs-attr">loader</span>:<span class="hljs-string">&#x27;style-loader&#x27;</span>},
				{<span class="hljs-attr">loader</span>:<span class="hljs-string">&#x27;css-loader&#x27;</span>,
				<span class="hljs-attr">options</span>:{
					 <span class="hljs-attr">modules</span>:<span class="hljs-literal">true</span>,
					<span class="hljs-attr">importLoaders</span>:<span class="hljs-number">1</span>	   
					}
				},
				{<span class="hljs-attr">loader</span>:<span class="hljs-string">&#x27;postcss-loader&#x27;</span>}
				{<span class="hljs-attr">loader</span>:<span class="hljs-string">&#x27;sass-loader&#x27;</span>},
			  ]
		}
		]
	},
	<span class="hljs-attr">output</span>:{
		<span class="hljs-attr">filename</span>:<span class="hljs-string">&#x27;bundle.js&#x27;</span>,
		<span class="hljs-attr">path</span>:path.<span class="hljs-title function_">resolve</span>(__dirname,<span class="hljs-string">&#x27;zip&#x27;</span>)
	}
}
</code></pre>
<p>对于兼容css可以创建一个postcss.config.js去配置</p>
<pre><code class="language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {  
  <span class="hljs-attr">plugins</span>: [  
    <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;postcss-preset-env&#x27;</span>)({  
      <span class="hljs-comment">// 可以在这里配置选项，例如stage、browsers、features等  </span>
      <span class="hljs-comment">// 默认情况下，它会使用package.json中的browserslist配置或默认的browserslist配置  </span>
    }),  
  ],  
};
</code></pre>
<p>也可以在webpack中的loader之中配置</p>
<pre><code class="language-js"> {  
   <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;postcss-loader&#x27;</span>,  
	<span class="hljs-attr">options</span>: {  
	  <span class="hljs-attr">postcssOptions</span>: {  
		<span class="hljs-attr">plugins</span>: [  
		  <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;postcss-preset-env&#x27;</span>)({  
			<span class="hljs-comment">// 配置选项  </span>
		  }),  
		],  
	  },  
	},  
  }
</code></pre>
<p>package.json中配置的browserlist，可以使对象，也可以是数组形式</p>
<pre><code class="language-json"><span class="hljs-attr">&quot;browserslist&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">&quot;production&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
        <span class="hljs-string">&quot;defaults&quot;</span><span class="hljs-punctuation">,</span>
        <span class="hljs-string">&quot;last 3 versions&quot;</span>
      <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
      <span class="hljs-attr">&quot;development&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
        <span class="hljs-string">&quot;last 1 chrome version&quot;</span><span class="hljs-punctuation">,</span>
        <span class="hljs-string">&quot;last 1 firefox version&quot;</span><span class="hljs-punctuation">,</span>
        <span class="hljs-string">&quot;last 1 safari version&quot;</span>
      <span class="hljs-punctuation">]</span>
    <span class="hljs-punctuation">}</span>
</code></pre>
<h4 id="抽离单独css文件">抽离单独css文件</h4>
<pre><code class="language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.styl$/</span>,
        <span class="hljs-attr">use</span>: [
          <span class="hljs-title class_">MiniCssExtractPlugin</span>.<span class="hljs-property">loader</span>,<span class="hljs-comment">// 需要引入插件</span>
          {
			 <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;css-loader&#x27;</span>,
			 <span class="hljs-attr">options</span>: {
			  <span class="hljs-attr">modules</span>:<span class="hljs-literal">true</span>,<span class="hljs-comment">//开启css模块化打包，避免全局污染</span>
			   <span class="hljs-attr">importLoaders</span>: <span class="hljs-number">2</span>, 
			  <span class="hljs-comment">// 0 =&gt; no loaders (default);</span>
			  <span class="hljs-comment">//1 =&gt; postcss-loader; </span>
			 <span class="hljs-comment">// 2 =&gt; postcss-loader, sass-loader</span>
			 },
		   },
          {
            <span class="hljs-attr">loader</span>: <span class="hljs-string">&quot;postcss-loader&quot;</span>,
            <span class="hljs-attr">options</span>: {
              <span class="hljs-attr">postcssOptions</span>: {
                <span class="hljs-attr">plugins</span>: [
                  <span class="hljs-string">&quot;postcss-preset-env&quot;</span>, <span class="hljs-comment">// 能解决大多数样式兼容性问题</span>
                ],
              },
            },
          },
          <span class="hljs-string">&quot;stylus-loader&quot;</span>,
        ],
      },
    ],
  },
};
</code></pre>
<h4 id="importloaders-配置">importLoaders 配置</h4>
<p>当遇到 @import 语法，CSS modules and ICSS imports 时，默认会用 css-loader 处理，在 css-loader 前执行的 loader 就不会再回头执行了，如果配置了 importLoaders number类型，例如配置了 n，就会用 css-loader 前的 n 个 loader 去处理，然后再用 css-loader 处理。</p>
<pre><code class="language-js">{  
	<span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>,  
	<span class="hljs-attr">use</span>: [  
	  <span class="hljs-string">&#x27;style-loader&#x27;</span>,  
	  {
		<span class="hljs-attr">loader</span>:<span class="hljs-string">&#x27;css-loader&#x27;</span>,
		<span class="hljs-attr">options</span>:{
		  <span class="hljs-attr">importLoaders</span>: <span class="hljs-number">1</span>, 
		}
	  },
	  <span class="hljs-string">&#x27;postcss-loader&#x27;</span>
	],  
  },  
</code></pre>
<p>如果不配置importLoaders，那么默认为0，则next.css没有被postcsss-loader处理，会有兼容性问题</p>
<pre><code class="language-css"><span class="hljs-keyword">@import</span> url(<span class="hljs-string">&#x27;./next.css&#x27;</span>);
<span class="hljs-selector-class">.k1</span>{
    <span class="hljs-attribute">color</span>:red
}

<span class="hljs-selector-class">.k2</span>{
    <span class="hljs-attribute">color</span>:green
}
</code></pre>
<h3 id="babel-loader">babel-loader</h3>
<p>Babel：JavaScript 编译器。</p>
<p>主要用于将 ES6 语法编写的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。</p>
<p>它的工作原理主要基于<strong>抽象语法树（AST）的转换</strong>。具体来说，Babel首先将源代码解析为AST，然后通过一系列的插件对这个AST进行转换，最后再将转换后的AST生成新的代码。</p>
<pre><code class="language-bash"><span class="hljs-comment"># 安装babel babel-loader 和babel预设</span>
npm i babel-loader @babel/core @babel/preset-env -D
</code></pre>
<pre><code class="language-js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>);

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">module</span>: {
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>,
        <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>, <span class="hljs-comment">// 排除node_modules代码不编译</span>
        <span class="hljs-attr">loader</span>: <span class="hljs-string">&quot;babel-loader&quot;</span>,
      },
    ],
  },
};
</code></pre>
<pre><code class="language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">presets</span>: [<span class="hljs-string">&quot;@babel/preset-env&quot;</span>],
};

</code></pre>
<h4 id="babel不能处理的es语法">babel不能处理的es语法</h4>
<p>core-js可以处理babel不能处理的更高版本的es语法</p>
<pre><code class="language-js">{
	<span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>,
	<span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>, <span class="hljs-comment">// 排除node_modules代码不编译</span>
	<span class="hljs-attr">loader</span>: <span class="hljs-string">&quot;babel-loader&quot;</span>,
  }
</code></pre>
<pre><code class="language-js">在webpack项目中创建babel.<span class="hljs-property">config</span>.<span class="hljs-property">js</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
    <span class="hljs-comment">// 智能预设：能够编译ES6语法</span>
    <span class="hljs-attr">presets</span>: [
      [
        <span class="hljs-string">&quot;@babel/preset-env&quot;</span>,
        <span class="hljs-comment">// 按需加载core-js的polyfill</span>
        {  
            <span class="hljs-attr">useBuiltIns</span>: <span class="hljs-string">&quot;usage&quot;</span>, 
            <span class="hljs-attr">corejs</span>: { <span class="hljs-attr">version</span>: <span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-attr">proposals</span>: <span class="hljs-literal">true</span> },
            <span class="hljs-attr">targets</span>:{
                <span class="hljs-attr">browsers</span>: [  
                    <span class="hljs-string">&quot;ie &gt;= 8&quot;</span>,  
                    <span class="hljs-string">&quot;&gt; 0.1%&quot;</span>
                  ]  
            }
          
        },
         
      ],
    ],
};
</code></pre>
<h4 id="单独使用">单独使用</h4>
<p>不在webpack中使用，安装@babel/core，@babel/preset-env，core-js</p>
<pre><code class="language-js"><span class="hljs-keyword">import</span> babel <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@babel/core&quot;</span>
<span class="hljs-keyword">import</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;node:fs&#x27;</span>
<span class="hljs-keyword">import</span> presetEnv <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@babel/preset-env&quot;</span>

<span class="hljs-keyword">const</span> code = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&#x27;./demo.js&#x27;</span>, <span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-comment">// 不加utf-8是字符串</span>
<span class="hljs-comment">// console.log(code)</span>

<span class="hljs-comment">// 同步转换 第二个参数是一个预设</span>
babel.<span class="hljs-title function_">transformAsync</span>(code, {
  <span class="hljs-attr">presets</span>: [[
    presetEnv,
    {
      <span class="hljs-attr">useBuiltIns</span>: <span class="hljs-string">&#x27;usage&#x27;</span>, <span class="hljs-comment">// 新特性会按需引入 垫片</span>
      <span class="hljs-attr">corejs</span>: <span class="hljs-number">3</span>
    }
  ]]
}).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res.<span class="hljs-property">code</span>) <span class="hljs-comment">// es6 =&gt; es5</span>
})
</code></pre>
<p>需要处理的demojs</p>
<pre><code class="language-js"><span class="hljs-comment">//demo.js</span>
<span class="hljs-keyword">const</span> x = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
<span class="hljs-keyword">const</span> y = x.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item &gt; <span class="hljs-number">1</span>)


<span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>()
</code></pre>
<p>package.json中type修改成module</p>
<pre><code class="language-json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">&quot;devDependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">&quot;@babel/core&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^7.24.5&quot;</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">&quot;@babel/preset-env&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^7.24.5&quot;</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">&quot;core-js&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^3.37.0&quot;</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;module&quot;</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>打印出的结果</p>
<pre><code class="language-js"><span class="hljs-meta">&quot;use strict&quot;</span>;

<span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;core-js/modules/es.array.filter.js&quot;</span>);
<span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;core-js/modules/es.object.to-string.js&quot;</span>);
<span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;core-js/modules/es.promise.js&quot;</span>);
<span class="hljs-keyword">var</span> x = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-keyword">var</span> y = x.<span class="hljs-title function_">filter</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) {
  <span class="hljs-keyword">return</span> item &gt; <span class="hljs-number">1</span>;
});
<span class="hljs-keyword">var</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>();
</code></pre>
<h3 id="webpack-实现生产和测试环境">webpack 实现生产和测试环境</h3>
<p>process.env 是一个包含用户环境信息的对象，它提供了访问系统环境变量的接口。在 Node.js 中，process 是一个全局对象，</p>
<ol>
<li>使用不同的配置文件</li>
</ol>
<pre><code class="language-json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>  
  <span class="hljs-attr">&quot;dev&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack --config webpack.dev.js&quot;</span><span class="hljs-punctuation">,</span>  
  <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack --config webpack.prod.js&quot;</span>  
<span class="hljs-punctuation">}</span>
</code></pre>
<ol start="2">
<li>使用环境变量:可以通过 <strong>process.env</strong> 访问环境变量。你可以在构建之前设置这些环境变量，然后在配置文件中根据这些变量来决定使用哪些配置</li>
</ol>
<pre><code class="language-bash"><span class="hljs-comment"># 在命令行中设置环境变量  （windows不支持这个写法)</span>
<span class="hljs-built_in">export</span> NODE_ENV=development  
npm run dev
</code></pre>
<p>然后在 webpack.config.js 中：</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> isDev = process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> === <span class="hljs-string">&#x27;development&#x27;</span>;  
<span class="hljs-keyword">const</span> isProd = process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> === <span class="hljs-string">&#x27;production&#x27;</span>;  
  
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {  
  <span class="hljs-attr">mode</span>: isProd ? <span class="hljs-string">&#x27;production&#x27;</span> : <span class="hljs-string">&#x27;development&#x27;</span>,  
  <span class="hljs-comment">// 其他配置...  </span>
};
</code></pre>
<ol start="3">
<li>使用 webpack-merge</li>
<li>在 webpack.config.js 中判断环境</li>
</ol>
<pre><code class="language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-function">(<span class="hljs-params">env, options</span>) =&gt;</span> {  
  <span class="hljs-keyword">const</span> isProduction = options.<span class="hljs-property">mode</span> === <span class="hljs-string">&#x27;production&#x27;</span>;  
    
  <span class="hljs-keyword">return</span> {  
    <span class="hljs-attr">mode</span>: isProduction ? <span class="hljs-string">&#x27;production&#x27;</span> : <span class="hljs-string">&#x27;development&#x27;</span>,  
    <span class="hljs-comment">// 根据环境设置不同的配置...  </span>
  };  
};
</code></pre>
<pre><code class="language-json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>  
  <span class="hljs-attr">&quot;dev&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack --mode development&quot;</span><span class="hljs-punctuation">,</span>  
  <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack --mode production&quot;</span>  
<span class="hljs-punctuation">}</span>
</code></pre>
<ol start="5">
<li>在vue脚手架中，.env文件用于存储项目的环境配置信息。这个文件是全局默认配置文件，无论什么环境都会加载并合并。
如果你在.env文件中定义了一个名为VUE_APP_TITLE的属性，那么你可以在项目的其他文件中通过process.env.VUE_APP_TITLE来访问这个属性的值。</li>
</ol>
<p>除了全局的.env文件，Vue CLI还支持创建其他类型的.env文件以定义特定环境的配置。例如：</p>
<ul>
<li>.env.development 是开发环境下的配置文件，仅在开发环境加载。</li>
<li>.env.production 是生产环境下的配置文件（也就是正式环境），仅在生产环境加载。</li>
</ul>

            <script async src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
            
        </body>
        </html>